{
    "docs": [
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\n\n\nIn computer science, a data structure is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an algorithm is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\nBooks\n\n\n\n\n\n\n\n\nNote:\n this notebook is inprogress. Feel free to \ncontribute", 
            "title": "Home"
        }, 
        {
            "location": "/#data-structures-algorithms", 
            "text": "Algorithms + Data Structures = Programs   In computer science, a data structure is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an algorithm is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms"
        }, 
        {
            "location": "/#books", 
            "text": "Note:  this notebook is inprogress. Feel free to  contribute", 
            "title": "Books"
        }, 
        {
            "location": "/d_array/", 
            "text": "Arrays\n\n\nIntroduction\n\n\nAn array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.\n\n\nHere is the list of most important array features you must know (i.e. be able to program)\n\n\n\n\ncopying and cloning\n\n\ninsertion and deletion\n\n\nsearching and sorting\n\n\n\n\nYou already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:\n\n\nint[] a = {9, 5, 4};\nint[] b = a;\n\n\n\n\nThe assignment operator creates an alias to the object, like in the picture below\n\n\n\n\nSince these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,\n\n\nint [] a = {1,2,3};\nint [] b = {1,2,3};\n\n\n\n\na and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.\n\n\nThe Arrays class\n\n\nThe java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:\n\n\nint[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println(\narrays with identical contents\n);\n\n\n\n\nAnother commonly used method is toString() which takes care of of printing\n\n\nint[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nHere is the example of sorting\n\n\nint[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nIn addition to that, the class has other utility methods for supporting operations over multidimensional arrays.\n\n\nCopying arrays\n\n\nThere are four ways to copy arrays\n\n\nusing a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i \n a.length; i++) b[i] = a[i];\n\n\n\n\nThe next choice is to use Arrays.copyOf()\n\n\nint[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);\n\n\n\n\nThe second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.\n\n\nThe most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature\n\n\npublic static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)\n\n\n\n\nThe method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)\n\n\n\n\nAnd the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment\n\n\nint[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();\n\n\n\n\nNote, that casting (int[]) is the must.\n\n\nExamine the code in ArrayCopyPrimitives.java for further details.\n\n\nChallenges\n\n\n\n\nArrays: Left Rotation\n\n\n\n\nReferences\n\n\n\n\nArray Data Structure", 
            "title": "Arrays"
        }, 
        {
            "location": "/d_array/#arrays", 
            "text": "", 
            "title": "Arrays"
        }, 
        {
            "location": "/d_array/#introduction", 
            "text": "An array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.  Here is the list of most important array features you must know (i.e. be able to program)   copying and cloning  insertion and deletion  searching and sorting   You already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:  int[] a = {9, 5, 4};\nint[] b = a;  The assignment operator creates an alias to the object, like in the picture below   Since these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,  int [] a = {1,2,3};\nint [] b = {1,2,3};  a and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.", 
            "title": "Introduction"
        }, 
        {
            "location": "/d_array/#the-arrays-class", 
            "text": "The java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:  int[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println( arrays with identical contents );  Another commonly used method is toString() which takes care of of printing  int[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));  Here is the example of sorting  int[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));  In addition to that, the class has other utility methods for supporting operations over multidimensional arrays.", 
            "title": "The Arrays class"
        }, 
        {
            "location": "/d_array/#copying-arrays", 
            "text": "There are four ways to copy arrays  using a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i   a.length; i++) b[i] = a[i];  The next choice is to use Arrays.copyOf()  int[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);  The second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.  The most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature  public static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)  The method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)  And the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment  int[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();  Note, that casting (int[]) is the must.  Examine the code in ArrayCopyPrimitives.java for further details.", 
            "title": "Copying arrays"
        }, 
        {
            "location": "/d_array/#challenges", 
            "text": "Arrays: Left Rotation", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_array/#references", 
            "text": "Array Data Structure", 
            "title": "References"
        }, 
        {
            "location": "/7_steps/", 
            "text": "7 Steps to Solve Algorithm Problems\n\n\nToday, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of \nCracking the Coding Interview\n book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.\n\n\nStep 1: Listen carefully\n\n\nThe first step you will take is listen (read) your problem carefully.\n\n\nStep 2: Example\n\n\nExample (make example big, no special cases)\n\n\nStep 3: Brute force\n\n\n(better to have a brute force than nothing at all.\n\n\nBecause\n\n\n\n\ncheck that you understand the problem, shows you're at least good enough to get that\n\n\nit's good place to optimize from\n\n\n\n\nStep 4: Optimize\n\n\nStep 5: Walk through your algorithms\n\n\nknow exactly what you're going to do before coding\n\n\n\n\nwhat variables \n data structures?\n\n\nhow, why, why do they change?\n\n\nwhat is the structure of your code\n\n\n\n\nStep 6: Code\n\n\nWhiteboard: write straight, use space wisely\n\n\nWhiteboard or computer\n\n\n\n\n\n\ncoding style matters (consistent braces, consistent variable naming, consistence spaces, descriptive variables)\n\n\n\n\n\n\nmodularize (before. not after)\n\n\n\n\n\n\nStep 7: Test\n\n\nAnalyse: think about each line, double check things that look weired/risky (for-loop that decrement, math) - Use test cases (smalle test-cases first (faster to run, you will problably be more thoroguht, edge cases, big tes cases)\n\n\nREMEMBER:\n\n think as you test (don't be a bot)\n\n test your code, not your algorithm\n* think before you fix bugs. Don't panic! (wrong fixes are worse than no fix)\n\n\nhttps://www.youtube.com/watch?v=GKgAVjJxh9w\nlist=PLM0_NsFSjrgC72cExkBI4Iz99SBTzYG-u\nindex=4", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#7-steps-to-solve-algorithm-problems", 
            "text": "Today, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of  Cracking the Coding Interview  book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#step-1-listen-carefully", 
            "text": "The first step you will take is listen (read) your problem carefully.", 
            "title": "Step 1: Listen carefully"
        }, 
        {
            "location": "/7_steps/#step-2-example", 
            "text": "Example (make example big, no special cases)", 
            "title": "Step 2: Example"
        }, 
        {
            "location": "/7_steps/#step-3-brute-force", 
            "text": "(better to have a brute force than nothing at all.  Because   check that you understand the problem, shows you're at least good enough to get that  it's good place to optimize from", 
            "title": "Step 3: Brute force"
        }, 
        {
            "location": "/7_steps/#step-4-optimize", 
            "text": "", 
            "title": "Step 4: Optimize"
        }, 
        {
            "location": "/7_steps/#step-5-walk-through-your-algorithms", 
            "text": "know exactly what you're going to do before coding   what variables   data structures?  how, why, why do they change?  what is the structure of your code", 
            "title": "Step 5: Walk through your algorithms"
        }, 
        {
            "location": "/7_steps/#step-6-code", 
            "text": "Whiteboard: write straight, use space wisely  Whiteboard or computer    coding style matters (consistent braces, consistent variable naming, consistence spaces, descriptive variables)    modularize (before. not after)", 
            "title": "Step 6: Code"
        }, 
        {
            "location": "/7_steps/#step-7-test", 
            "text": "Analyse: think about each line, double check things that look weired/risky (for-loop that decrement, math) - Use test cases (smalle test-cases first (faster to run, you will problably be more thoroguht, edge cases, big tes cases)  REMEMBER:  think as you test (don't be a bot)  test your code, not your algorithm\n* think before you fix bugs. Don't panic! (wrong fixes are worse than no fix)  https://www.youtube.com/watch?v=GKgAVjJxh9w list=PLM0_NsFSjrgC72cExkBI4Iz99SBTzYG-u index=4", 
            "title": "Step 7: Test"
        }, 
        {
            "location": "/a_graph_theory/", 
            "text": "Graph Theory\n\n\nShortest Path Problem\n\n\n\n\nShortest path (A, C, E, D, F) between vertices A and F in the weighted directed graph\n\n\nIn graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.\n\n\n\n\n\n\n\n\na\n\n\nb\n\n\n\n\n\n\nc\n\n\nd\n\n\n\n\n\n\n\n\n\nSingle-source shortest path problem\n\n\nDijkstra's algorithm\n\n\n\n\nDijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.", 
            "title": "Graph Theory"
        }, 
        {
            "location": "/a_graph_theory/#graph-theory", 
            "text": "", 
            "title": "Graph Theory"
        }, 
        {
            "location": "/a_graph_theory/#shortest-path-problem", 
            "text": "Shortest path (A, C, E, D, F) between vertices A and F in the weighted directed graph  In graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.     a  b    c  d", 
            "title": "Shortest Path Problem"
        }, 
        {
            "location": "/a_graph_theory/#single-source-shortest-path-problem", 
            "text": "", 
            "title": "Single-source shortest path problem"
        }, 
        {
            "location": "/a_graph_theory/#dijkstras-algorithm", 
            "text": "Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.", 
            "title": "Dijkstra's algorithm"
        }
    ]
}