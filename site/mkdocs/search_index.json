{
    "docs": [
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Home"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/gs_introduction/", 
            "text": "Introduction\n\n\nSoftware engineering is the study of ways in which to create large and complex computer applications and that generally involve many programmers and designers. At the heart of software engineering is with the overall design of the applications and on the creation of a design that is based on the needs and requirements of end users. While software engineering involves the full life cycle of a software project, is includes many different components - specification, requirements gathering, design, verification, coding, testing, quality assurance, user acceptance testing, production, and ongoing maintenance.\n\n\nHaving an in-depth understanding on every component of software engineering is not mandatory, however, it is important to understand that the subject of data structures and algorithms is concerned with the coding phase. The use of data structures and algorithms is the nuts-and-blots used by programmers to store and manipulate data.\n\n\nThis article, along with the other examples in this section focuses on the essentials of data structures and algorithms. Attempts will be made to understand how they work, which structure or algorithm is best in a particular situation in an easy to understand environment.\n\n\nData Structures and Algorithms - Defined\n\n\nA data structure is an arrangement of data in a computer's memory or even disk storage. An example of several common data structures are arrays, linked lists, queues, stacks, binary trees, and hash tables. Algorithms, on the other hand, are used to manipulate the data contained in these data structures as in searching and sorting.\n\n\nMany algorithms apply directly to a specific data structures. When working with certain data structures you need to know how to insert new data, search for a specified item, and deleting a specific item.\n\n\nCommonly used algorithms include are useful for:\n\n\n\n\nSearching for a particular data item (or record).\n\n\nSorting the data. There are many ways to sort data. Simple sorting, Advanced sorting\n\n\nIterating through all the items in a data structure. (Visiting each item in turn so as to display it or perform some other action on these items)", 
            "title": "Introduction"
        }, 
        {
            "location": "/gs_introduction/#introduction", 
            "text": "Software engineering is the study of ways in which to create large and complex computer applications and that generally involve many programmers and designers. At the heart of software engineering is with the overall design of the applications and on the creation of a design that is based on the needs and requirements of end users. While software engineering involves the full life cycle of a software project, is includes many different components - specification, requirements gathering, design, verification, coding, testing, quality assurance, user acceptance testing, production, and ongoing maintenance.  Having an in-depth understanding on every component of software engineering is not mandatory, however, it is important to understand that the subject of data structures and algorithms is concerned with the coding phase. The use of data structures and algorithms is the nuts-and-blots used by programmers to store and manipulate data.  This article, along with the other examples in this section focuses on the essentials of data structures and algorithms. Attempts will be made to understand how they work, which structure or algorithm is best in a particular situation in an easy to understand environment.", 
            "title": "Introduction"
        }, 
        {
            "location": "/gs_introduction/#data-structures-and-algorithms-defined", 
            "text": "A data structure is an arrangement of data in a computer's memory or even disk storage. An example of several common data structures are arrays, linked lists, queues, stacks, binary trees, and hash tables. Algorithms, on the other hand, are used to manipulate the data contained in these data structures as in searching and sorting.  Many algorithms apply directly to a specific data structures. When working with certain data structures you need to know how to insert new data, search for a specified item, and deleting a specific item.  Commonly used algorithms include are useful for:   Searching for a particular data item (or record).  Sorting the data. There are many ways to sort data. Simple sorting, Advanced sorting  Iterating through all the items in a data structure. (Visiting each item in turn so as to display it or perform some other action on these items)", 
            "title": "Data Structures and Algorithms - Defined"
        }, 
        {
            "location": "/gs_greedy_algorithms/", 
            "text": "Greedy Algorithms\n\n\nAn algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.\n\n\nGreedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.\n\n\nCounting Coins\n\n\nThis problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of 1, 2, 5 and 10 and we are asked to count 18 then the greedy procedure will be\n\n\n\n\n\n\nSelect one 10 coin, the remaining count is 8\n\n\n\n\n\n\nThen select one 5 coin, the remaining count is 3\n\n\n\n\n\n\nThen select one 2 coin, the remaining count is 1\n\n\n\n\n\n\nAnd finally, the selection of one 1 coins solves the problem\n\n\n\n\n\n\nThough, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.\n\n\nFor the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 + 1 + 1 + 1 + 1 + 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 + 7 + 1)\n\n\nHence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.\n\n\nExamples\n\n\nMost networking algorithms use the greedy approach. Here is a list of few of them\n\n\n\n\nTravelling Salesman Problem\n\n\nPrim's Minimal Spanning Tree Algorithm\n\n\nKruskal's Minimal Spanning Tree Algorithm\n\n\nDijkstra's Minimal Spanning Tree Algorithm\n\n\nGraph - Map Coloring\n\n\nGraph - Vertex Cover\n\n\nKnapsack Problem\n\n\nJob Scheduling Problem\n\n\n\n\nThere are lots of similar problems that uses the greedy approach to find an optimum solution.", 
            "title": "Greedy Algorithms"
        }, 
        {
            "location": "/gs_greedy_algorithms/#greedy-algorithms", 
            "text": "An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.  Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.", 
            "title": "Greedy Algorithms"
        }, 
        {
            "location": "/gs_greedy_algorithms/#counting-coins", 
            "text": "This problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of 1, 2, 5 and 10 and we are asked to count 18 then the greedy procedure will be    Select one 10 coin, the remaining count is 8    Then select one 5 coin, the remaining count is 3    Then select one 2 coin, the remaining count is 1    And finally, the selection of one 1 coins solves the problem    Though, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.  For the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 + 1 + 1 + 1 + 1 + 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 + 7 + 1)  Hence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.", 
            "title": "Counting Coins"
        }, 
        {
            "location": "/gs_greedy_algorithms/#examples", 
            "text": "Most networking algorithms use the greedy approach. Here is a list of few of them   Travelling Salesman Problem  Prim's Minimal Spanning Tree Algorithm  Kruskal's Minimal Spanning Tree Algorithm  Dijkstra's Minimal Spanning Tree Algorithm  Graph - Map Coloring  Graph - Vertex Cover  Knapsack Problem  Job Scheduling Problem   There are lots of similar problems that uses the greedy approach to find an optimum solution.", 
            "title": "Examples"
        }, 
        {
            "location": "/gs_divide_and_conquer/", 
            "text": "Divide and Conquer\n\n\nIn divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those \"atomic\" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.\n\n\n\n\nBroadly, we can understand \ndivide-and-conquer\n approach in a three-step process.\n\n\nDivide/Break\n\n\nThis step involves breaking the problem into smaller sub-problems. Sub-problems should represent a part of the original problem. This step generally takes a recursive approach to divide the problem until no sub-problem is further divisible. At this stage, sub-problems become atomic in nature but still represent some part of the actual problem.\n\n\nConquer/Solve\n\n\nThis step receives a lot of smaller sub-problems to be solved. Generally, at this level, the problems are considered 'solved' on their own.\n\n\nMerge/Combine\n\n\nWhen the smaller sub-problems are solved, this stage recursively combines them until they formulate a solution of the original problem. This algorithmic approach works recursively and conquer \n merge steps works so close that they appear as one.\n\n\nExamples\n\n\nThe following computer algorithms are based on divide-and-conquer programming approach\n\n\n\n\nMerge Sort\n\n\nQuick Sort\n\n\nBinary Search\n\n\nStrassen's Matrix Multiplication\n\n\nClosest pair (points)\n\n\n\n\nThere are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.", 
            "title": "Divide-and-Conquer"
        }, 
        {
            "location": "/gs_divide_and_conquer/#divide-and-conquer", 
            "text": "In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those \"atomic\" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.   Broadly, we can understand  divide-and-conquer  approach in a three-step process.", 
            "title": "Divide and Conquer"
        }, 
        {
            "location": "/gs_divide_and_conquer/#dividebreak", 
            "text": "This step involves breaking the problem into smaller sub-problems. Sub-problems should represent a part of the original problem. This step generally takes a recursive approach to divide the problem until no sub-problem is further divisible. At this stage, sub-problems become atomic in nature but still represent some part of the actual problem.", 
            "title": "Divide/Break"
        }, 
        {
            "location": "/gs_divide_and_conquer/#conquersolve", 
            "text": "This step receives a lot of smaller sub-problems to be solved. Generally, at this level, the problems are considered 'solved' on their own.", 
            "title": "Conquer/Solve"
        }, 
        {
            "location": "/gs_divide_and_conquer/#mergecombine", 
            "text": "When the smaller sub-problems are solved, this stage recursively combines them until they formulate a solution of the original problem. This algorithmic approach works recursively and conquer   merge steps works so close that they appear as one.", 
            "title": "Merge/Combine"
        }, 
        {
            "location": "/gs_divide_and_conquer/#examples", 
            "text": "The following computer algorithms are based on divide-and-conquer programming approach   Merge Sort  Quick Sort  Binary Search  Strassen's Matrix Multiplication  Closest pair (points)   There are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.", 
            "title": "Examples"
        }, 
        {
            "location": "/gs_dynamic_programming/", 
            "text": "Dynamic Programming\n\n\nDynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems.\n\n\nDynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.\n\n\nSo we can say that\n\n\n\n\nThe problem should be able to be divided into smaller overlapping sub-problem.\n\n\nAn optimum solution can be achieved by using an optimum solution of smaller sub-problems.\n\n\nDynamic algorithms use memorization.\n\n\n\n\nComparison\n\n\nIn contrast to greedy algorithms, where local optimization is addressed, dynamic algorithms are motivated for an overall optimization of the problem.\n\n\nIn contrast to divide and conquer algorithms, where solutions are combined to achieve an overall solution, dynamic algorithms use the output of a smaller sub-problem and then try to optimize a bigger sub-problem. Dynamic algorithms use memorization to remember the output of already solved sub-problems.\n\n\nExample\n\n\nThe following computer problems can be solved using dynamic programming approach\n\n\n\n\nFibonacci number series\n\n\nKnapsack problem\n\n\nTower of Hanoi\n\n\nAll pair shortest path by Floyd-Warshall\n\n\nShortest path by Dijkstra\n\n\nProject scheduling\n\n\n\n\nDynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.", 
            "title": "Dynamic Programming"
        }, 
        {
            "location": "/gs_dynamic_programming/#dynamic-programming", 
            "text": "Dynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems.  Dynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.  So we can say that   The problem should be able to be divided into smaller overlapping sub-problem.  An optimum solution can be achieved by using an optimum solution of smaller sub-problems.  Dynamic algorithms use memorization.", 
            "title": "Dynamic Programming"
        }, 
        {
            "location": "/gs_dynamic_programming/#comparison", 
            "text": "In contrast to greedy algorithms, where local optimization is addressed, dynamic algorithms are motivated for an overall optimization of the problem.  In contrast to divide and conquer algorithms, where solutions are combined to achieve an overall solution, dynamic algorithms use the output of a smaller sub-problem and then try to optimize a bigger sub-problem. Dynamic algorithms use memorization to remember the output of already solved sub-problems.", 
            "title": "Comparison"
        }, 
        {
            "location": "/gs_dynamic_programming/#example", 
            "text": "The following computer problems can be solved using dynamic programming approach   Fibonacci number series  Knapsack problem  Tower of Hanoi  All pair shortest path by Floyd-Warshall  Shortest path by Dijkstra  Project scheduling   Dynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.", 
            "title": "Example"
        }, 
        {
            "location": "/7_steps/", 
            "text": "7 Steps to Solve Algorithm Problems\n\n\nToday, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of \nCracking the Coding Interview\n book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.\n\n\nStep 1: Listen carefully\n\n\n\n\nEvery single detail in a question is necessary to solve it.\n\n\n\n\nThe first step is to listen carefully to the problem. So, generally speaking every single detail in a question is necessary to solve that problem - either to solve it all or to solve it optimally. So if there's some detail you haven't used in the question in your algorithm so far think about how you can put that to use because it might be necessary to solve the problem optimally.\n\n\nLet me give you an example.\n\n\nYou have two arrays, sorted and distinct\nHow did you find the number of elements in common between the two arrays?\n\n\n\n\nA lot of people solve this problem and they'll get kind of stuck for awhile and what they'll do is they'll be solving the problem and they'll know the arrays are sorted but they haven't actually used the fact that it's sorted.\n\n\nThis \nsorting\n detail - it's not necessary just to find an algorithm but it is necessary to solve the problem optimally.\n\n\nSo remember every single detail in the problem and make sure you use it.\n\n\nStep 2: Example\n\n\n\n\nMake example big, no special cases\n\n\n\n\nThe second piece is to come up with a good example, so the last problem that I gave two arrays \nsorted\n and \ndistinct\n compute the number of elements in common, most people's examples look like this.\n\n\n# too small and special case\nA: 1, 5, 15, 20\nB: 2, 5, 13, 30\n\n\n\n\nYes technically if it's a problem but it's not very useful.\n\n\nAs soon as you glance at this example you notice that there's only one element common and you know exactly what it is and it's obvious because this example is so small and it's actually kind of a special case.\n\n\nA better example is something like this\n\n\n# larger and avoid special cases\nA: 1, 5, 15, 20, 30, 37\nB: 2, 5, 13, 30, 32, 35, 37, 42\n\n\n\n\nIt's much larger and you've avoided some special cases. One of the easiest ways of improving your performance on algorithm questions is just make your examples \nlarger\n and really \navoid special cases\n.\n\n\nStep 3: Brute force\n\n\n\n\nBetter to have a brute force than nothing at all\n\n\n\n\nThe third step is to come up with a brute force algorithm. Now I'm not saying you need to go out of your way to come up with something slow, I'm really just saying, hey if the first thing you have is only something really really slow and terrible that's okay. It is so much better to start off with something slow then to start off with nothing at all. So it's fine if your first algorithm is slow and terrible whatever. However, and this is very very very important, I'm not saying to code the brute force. I'm saying just state your brute force algorithm, state its runtime, and then immediately go to optimizing.\n\n\nA good chunk of the time on algorithm interview question will often be spent on optimizations. So that's step 4 and spend some good time on it.\n\n\nStep 4: Optimize\n\n\nThe fourth step is optimize and spend some good time on it.\n\n\nStep 5: Walk through your algorithms\n\n\n\n\nKnow exactly what you're going to do before coding\n\n\n\n\n\n\nwhat variables \n data structures?\n\n\nhow, why, why do they change?\n\n\nwhat is the structure of your code\n\n\n\n\nThen once you have an optimal algorithm or you're ready to start coding take a step back and just make sure you \nknow exactly\n what you're going to do in your code.\n\n\nSo many people code prematurely when they aren't really really comfortable with what they're about to do and it ends in disaster. An eighty percent understanding of what you're about to write is really not enough for a whiteboard especially. So take a moment and walk through your algorithm and make sure you know exactly what you're about to do.\n\n\nStep 6: Code\n\n\n\n\nUse space wisely, coding style matters, modularize\n\n\n\n\nStep 6 is to start coding and I'm gonna go into this in a bit of detail. So a couple things to keep in mind particularly when you're coding on a whiteboard. The first couple tips are kind of whiteboard specific but try to write your lines straight. I'm not gonna be judging you on your handwriting and things like that but when people start writing their lines and sharp angles they start to lose track over whether this if statement under this for loop or not. The second thing is use your board space wisely. If you don't need stuff up on the board anymore just erase it. Try to write in this top left corner etc.\n\n\nBasically give yourself as much space as you possibly can to write your code. If you do run out of space though, it's ok to use arrows, that's fine, I'm really not gonna be judging you on this kind of stuff. So more important things.\n\n\nCoding style matters\n (\nconsistent braces\n, \nconsistent variable naming\n, \nconsistence spaces\n, \ndescriptive variables\n)\n\n\nCoding style matters even on a whiteboard but on a computer as well, so that means things like braces, naming conventions, or using camel case or underscores, things like that. Those kind of style things absolutely matter. I'm not that concerned over which style you pick, I don't care if you write braces on the same line or the next line but I do care a lot that you have a style and you stick to it. So be consistent in your style. When it comes to variable names, yeah I know it's an annoying to write long variable names on a whiteboard but descriptive variable names are important to good style. So one compromise here is write the good descriptive variable name first and then just ask your interviewer, hey is it okay if I abbreviate this the next time. So that'll be a nice little compromise - you'd show that you care about good variable names but you also don't waste a lot of time.\n\n\nModularize\n (\nbefore. not after\n)\n\n\nLast thing I want to talk about is modularization. Modularize your code up front and just any little conceptual chunks of code, push that off to another function. So suppose you have three steps in your algorithm - process the first string, process the second string,  and then compare the results. Don't start writing these for loops that walk through each string in the very beginning. Instead write this overall function that wraps these three steps. So step one, step two, step three, and then start drilling in and going into all the details there. Remember any conceptual chunks of code push those off to other functions, don't write them in line. \n\n\nStep 7: Test\n\n\n\n\nAnalyse: think about each line, double check things that look weired/risky (for-loop that decrement, math) \n\n\nUse test cases (smaller test-cases first (faster to run, you will problably be more through, edge cases, big test cases)\n\n\n\n\nThen once you're done with the coding you have to start testing your code. One of the mistakes a lot of people do here is they take their big example from step 2 and throw that in as a test case. The problem with that is it's very large so it will take you a long time to run through but also you just used that to develop your code, so if here's an oversight there, the problem will probably repeat itself here. \n\n\nWhat's a better step to do, what's a better process to do, is just walk through your code line by line and just think about each line up front not with the test case but just consider, is it really doing the right thing?\n\n\nDouble check anything that looks weird, so for loops that decrement instead of increment and any math at all is a really common place for errors. Just think, look at your code analytically and think what are the most likely places for errors to be and double-check those.\n\n\nStart with small rather than big\n\n\nThen once you start with actual test cases start with small test cases rather than big ones. Small test cases work pretty much as effectively as big test cases but they are so much faster to run through, and in fact because they're faster people tend to be much more thorough so you're much more likely to actually find bugs with small test cases than big test cases. So start with small test cases then go in to edge cases after that and then if you have time maybe throw in some big test cases. A couple last techniques with testing. The first one is make sure that when you're testing you're really thinking about what you're doing. A lot of people when they're testing they're just walking through their code almost like they're a bot, and they only look to see if things made sense at the very end when they look at their output. It's much better to really think as you're testing, this way you find the bug as soon as it happens rather than six lines later at the very bottom.\n\n\nTest your code not your algorithm\n\n\nThe second thing is when you're testing make sure that you're actually testing your code and not your algorithm. An amazing number of people will just take their example and like just walk through it again as though they're just walking through their algorithm but they're never even looking at their code, they're not looking at the exact calculations their code actually did. So make sure that you're really testing your code.\n\n\nFind bugs\n\n\nThen the last thing is when you find in a bug, don't panic. Just really think about what caused the bug. A lot of times people will panic and just try to make the first fix that fixes it for that output but they haven't really given it some thought and then they're in a much worse position because if you make the wrong fix to your code, the thing that just fixed the output but didn't fix a real bug you've not fixed the actual bug, you've made your code more complex, and you potentially introduced a brand new bug and you're in a much worse position. It's much better to just when you find the bug, it's ok, it's not that big of a deal to have a bug it's very normal just really think through what the actual bug, where the actual plug came from.\n\n\nRemember\n\n\n\n\nthink as you test (don't be a bot)\n\n\ntest your code, not your algorithm\n\n\nthink before you fix bugs. Don't panic! (wrong fixes are worse than no fix)\n\n\n\n\nSuggested Reading\n\n\n\n\n7 Steps to Solve Algorithm Problems. Gayle Laakmann McDowell", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#7-steps-to-solve-algorithm-problems", 
            "text": "Today, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of  Cracking the Coding Interview  book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#step-1-listen-carefully", 
            "text": "Every single detail in a question is necessary to solve it.   The first step is to listen carefully to the problem. So, generally speaking every single detail in a question is necessary to solve that problem - either to solve it all or to solve it optimally. So if there's some detail you haven't used in the question in your algorithm so far think about how you can put that to use because it might be necessary to solve the problem optimally.  Let me give you an example.  You have two arrays, sorted and distinct\nHow did you find the number of elements in common between the two arrays?  A lot of people solve this problem and they'll get kind of stuck for awhile and what they'll do is they'll be solving the problem and they'll know the arrays are sorted but they haven't actually used the fact that it's sorted.  This  sorting  detail - it's not necessary just to find an algorithm but it is necessary to solve the problem optimally.  So remember every single detail in the problem and make sure you use it.", 
            "title": "Step 1: Listen carefully"
        }, 
        {
            "location": "/7_steps/#step-2-example", 
            "text": "Make example big, no special cases   The second piece is to come up with a good example, so the last problem that I gave two arrays  sorted  and  distinct  compute the number of elements in common, most people's examples look like this.  # too small and special case\nA: 1, 5, 15, 20\nB: 2, 5, 13, 30  Yes technically if it's a problem but it's not very useful.  As soon as you glance at this example you notice that there's only one element common and you know exactly what it is and it's obvious because this example is so small and it's actually kind of a special case.  A better example is something like this  # larger and avoid special cases\nA: 1, 5, 15, 20, 30, 37\nB: 2, 5, 13, 30, 32, 35, 37, 42  It's much larger and you've avoided some special cases. One of the easiest ways of improving your performance on algorithm questions is just make your examples  larger  and really  avoid special cases .", 
            "title": "Step 2: Example"
        }, 
        {
            "location": "/7_steps/#step-3-brute-force", 
            "text": "Better to have a brute force than nothing at all   The third step is to come up with a brute force algorithm. Now I'm not saying you need to go out of your way to come up with something slow, I'm really just saying, hey if the first thing you have is only something really really slow and terrible that's okay. It is so much better to start off with something slow then to start off with nothing at all. So it's fine if your first algorithm is slow and terrible whatever. However, and this is very very very important, I'm not saying to code the brute force. I'm saying just state your brute force algorithm, state its runtime, and then immediately go to optimizing.  A good chunk of the time on algorithm interview question will often be spent on optimizations. So that's step 4 and spend some good time on it.", 
            "title": "Step 3: Brute force"
        }, 
        {
            "location": "/7_steps/#step-4-optimize", 
            "text": "The fourth step is optimize and spend some good time on it.", 
            "title": "Step 4: Optimize"
        }, 
        {
            "location": "/7_steps/#step-5-walk-through-your-algorithms", 
            "text": "Know exactly what you're going to do before coding    what variables   data structures?  how, why, why do they change?  what is the structure of your code   Then once you have an optimal algorithm or you're ready to start coding take a step back and just make sure you  know exactly  what you're going to do in your code.  So many people code prematurely when they aren't really really comfortable with what they're about to do and it ends in disaster. An eighty percent understanding of what you're about to write is really not enough for a whiteboard especially. So take a moment and walk through your algorithm and make sure you know exactly what you're about to do.", 
            "title": "Step 5: Walk through your algorithms"
        }, 
        {
            "location": "/7_steps/#step-6-code", 
            "text": "Use space wisely, coding style matters, modularize   Step 6 is to start coding and I'm gonna go into this in a bit of detail. So a couple things to keep in mind particularly when you're coding on a whiteboard. The first couple tips are kind of whiteboard specific but try to write your lines straight. I'm not gonna be judging you on your handwriting and things like that but when people start writing their lines and sharp angles they start to lose track over whether this if statement under this for loop or not. The second thing is use your board space wisely. If you don't need stuff up on the board anymore just erase it. Try to write in this top left corner etc.  Basically give yourself as much space as you possibly can to write your code. If you do run out of space though, it's ok to use arrows, that's fine, I'm really not gonna be judging you on this kind of stuff. So more important things.  Coding style matters  ( consistent braces ,  consistent variable naming ,  consistence spaces ,  descriptive variables )  Coding style matters even on a whiteboard but on a computer as well, so that means things like braces, naming conventions, or using camel case or underscores, things like that. Those kind of style things absolutely matter. I'm not that concerned over which style you pick, I don't care if you write braces on the same line or the next line but I do care a lot that you have a style and you stick to it. So be consistent in your style. When it comes to variable names, yeah I know it's an annoying to write long variable names on a whiteboard but descriptive variable names are important to good style. So one compromise here is write the good descriptive variable name first and then just ask your interviewer, hey is it okay if I abbreviate this the next time. So that'll be a nice little compromise - you'd show that you care about good variable names but you also don't waste a lot of time.  Modularize  ( before. not after )  Last thing I want to talk about is modularization. Modularize your code up front and just any little conceptual chunks of code, push that off to another function. So suppose you have three steps in your algorithm - process the first string, process the second string,  and then compare the results. Don't start writing these for loops that walk through each string in the very beginning. Instead write this overall function that wraps these three steps. So step one, step two, step three, and then start drilling in and going into all the details there. Remember any conceptual chunks of code push those off to other functions, don't write them in line.", 
            "title": "Step 6: Code"
        }, 
        {
            "location": "/7_steps/#step-7-test", 
            "text": "Analyse: think about each line, double check things that look weired/risky (for-loop that decrement, math)   Use test cases (smaller test-cases first (faster to run, you will problably be more through, edge cases, big test cases)   Then once you're done with the coding you have to start testing your code. One of the mistakes a lot of people do here is they take their big example from step 2 and throw that in as a test case. The problem with that is it's very large so it will take you a long time to run through but also you just used that to develop your code, so if here's an oversight there, the problem will probably repeat itself here.   What's a better step to do, what's a better process to do, is just walk through your code line by line and just think about each line up front not with the test case but just consider, is it really doing the right thing?  Double check anything that looks weird, so for loops that decrement instead of increment and any math at all is a really common place for errors. Just think, look at your code analytically and think what are the most likely places for errors to be and double-check those.  Start with small rather than big  Then once you start with actual test cases start with small test cases rather than big ones. Small test cases work pretty much as effectively as big test cases but they are so much faster to run through, and in fact because they're faster people tend to be much more thorough so you're much more likely to actually find bugs with small test cases than big test cases. So start with small test cases then go in to edge cases after that and then if you have time maybe throw in some big test cases. A couple last techniques with testing. The first one is make sure that when you're testing you're really thinking about what you're doing. A lot of people when they're testing they're just walking through their code almost like they're a bot, and they only look to see if things made sense at the very end when they look at their output. It's much better to really think as you're testing, this way you find the bug as soon as it happens rather than six lines later at the very bottom.  Test your code not your algorithm  The second thing is when you're testing make sure that you're actually testing your code and not your algorithm. An amazing number of people will just take their example and like just walk through it again as though they're just walking through their algorithm but they're never even looking at their code, they're not looking at the exact calculations their code actually did. So make sure that you're really testing your code.  Find bugs  Then the last thing is when you find in a bug, don't panic. Just really think about what caused the bug. A lot of times people will panic and just try to make the first fix that fixes it for that output but they haven't really given it some thought and then they're in a much worse position because if you make the wrong fix to your code, the thing that just fixed the output but didn't fix a real bug you've not fixed the actual bug, you've made your code more complex, and you potentially introduced a brand new bug and you're in a much worse position. It's much better to just when you find the bug, it's ok, it's not that big of a deal to have a bug it's very normal just really think through what the actual bug, where the actual plug came from.  Remember   think as you test (don't be a bot)  test your code, not your algorithm  think before you fix bugs. Don't panic! (wrong fixes are worse than no fix)", 
            "title": "Step 7: Test"
        }, 
        {
            "location": "/7_steps/#suggested-reading", 
            "text": "7 Steps to Solve Algorithm Problems. Gayle Laakmann McDowell", 
            "title": "Suggested Reading"
        }, 
        {
            "location": "/ds_array/", 
            "text": "Arrays\n\n\nAn array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.\n\n\nHere is the list of most important array features you must know (i.e. be able to program)\n\n\n\n\ncopying and cloning\n\n\ninsertion and deletion\n\n\nsearching and sorting\n\n\n\n\nYou already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:\n\n\nint[] a = {9, 5, 4};\nint[] b = a;\n\n\n\n\nThe assignment operator creates an alias to the object, like in the picture below\n\n\n\n\nSince these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,\n\n\nint [] a = {1,2,3};\nint [] b = {1,2,3};\n\n\n\n\na and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.\n\n\nThe Arrays class\n\n\nThe java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:\n\n\nint[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println(\narrays with identical contents\n);\n\n\n\n\nAnother commonly used method is toString() which takes care of of printing\n\n\nint[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nHere is the example of sorting\n\n\nint[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nIn addition to that, the class has other utility methods for supporting operations over multidimensional arrays.\n\n\nCopying arrays\n\n\nThere are four ways to copy arrays\n\n\nusing a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i \n a.length; i++) b[i] = a[i];\n\n\n\n\nThe next choice is to use Arrays.copyOf()\n\n\nint[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);\n\n\n\n\nThe second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.\n\n\nThe most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature\n\n\npublic static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)\n\n\n\n\nThe method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)\n\n\n\n\nAnd the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment\n\n\nint[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();\n\n\n\n\nNote, that casting (int[]) is the must.\n\n\nExamine the code in ArrayCopyPrimitives.java for further details.\n\n\nInsertion and Deletion\n\n\nArrays in Java have no methods and only one \nimmutable\n field \nlength\n. Once an array is created, its length is fixed and cannot be changed. What do you do to resize the array? You allocate the array with a different size and copy the contents of the old array to the new array. This code example demonstrates deletion from an array of primitives\n\n\npublic char[] delete(char[] data, int pos)\n{\n    if(pos \n= 0 \n pos \n data.length)\n    {\n        char[] tmp = new char[data.length-1];\n        System.arraycopy(data, 0, tmp, 0, pos);\n        System.arraycopy(data, pos+1, tmp, pos, data.length-pos-1);\n        return tmp;\n    }\n    else\n        return data;\n}\n\n\n\n\nThe first arraycopy copies the elements from index 0 to index pos-1, the second arraycopy copies the elements from index pos+1 to data.length.\n\n\nExamine the code in ArrayDemo.java for further details.\n\n\nThe ArrayList class\n\n\nThe java.util.ArrayList class supports an idea of a dynamic array - an array that grows and shrinks on demand to accomodate the number of elements in the array. Below is a list of commonly used methods\n\n\n\n\nadd(object)\n - adds to the end\n\n\nadd(index, object)\n - inserts at the index\n\n\nset(index, object)\n - replaces at the index\n\n\nget(index)\n - returns the element at that index\n\n\nremove(index)\n - deletes the element at that index\n\n\nsize()\n - returns the number of elements\n\n\n\n\nThe following code example will give you a heads up into how some of them are used.\n\n\n/* ADD */\n      ArrayList\nInteger\n num = new ArrayList\nInteger\n();\n      for(int i = 0; i \n 10; i++) num.add(i);\n      System.out.println(num);\n\n\n/* REMOVE even integers */\n      for(int i = 0; i \n num.size(); i++)\n        if(num.get(i)%2 == 0) num.remove(i);\n      System.out.println(num);\n\n\n\n\nCopying arrays of objects\n\n\nThis topic is more complex for understanding.. Let us start with a simple loop structure\n\n\nObject[] obj1 = {new Integer(10),\n                new StringBuffer(\nfoobar\n),\n                new Double(12.95)};\nObject[] obj2 = new Object[obj1.length];\nfor(int i = 0; i \u2039 obj1.length; i++)\n    obj2[i] = obj1[i];\n\n\n\n\nAt the first glance we might think that all data is copied. In reality, the internal data is shared between two arrays. The figure below illustrates the inner structure\n\n\n\n\nThe assignment operator \nobj2[i] = obj1[i]\n is a crucial part of understanding the concept. You cannot copy references by assigning one to another. The assignment creates an alias rather than a copy. Let us trace down changes in the above picture after execution the following statements\n\n\nobj1[0] = new Integer(5);\n\n\n\n\n\n\nand \n((StringBuffer) obj1[1]).append('s');\n\n\n\n\nAs you see, \nobj1[0]\n and \nobj2[0]\n now refer to different objects. However, \nobj1[1]\n and \nobj2[1]\n refer to the same object (which is \"foobars\"). Since both arrays shares the data, you must be quite careful when you modify your data, because it might lead to unexpected effects.\n\n\nThe same behavior will take place again, if we use Arrays.copuyOf(), System.arraycopy() and clone(). Examine the code example ArrayCopyReferences.java for further details.\n\n\nMulti-dimensional arrays\n\n\nIn many practical application there is a need to use two- or multi-dimensional arrays. A two-dimensional array can be thought of as a table of rows and columns. This creates a table of 2 rows and 4 columns:\n\n\nint[][] ar1 = new int[2][4];\n\n\n\n\nYou can create and initialize an array by using nested curcly braces. For example, this creates a table of 3 rows and 2 columns:\n\n\nint[][] ar2 = {{1,2},{3,4},{5,6}};\n\n\n\n\nGenerally speaking, a two-dimensional array is not exactly a table - each row in such array can have a different length. Consider this code fragment\n\n\nObject[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10), \nbozo\n, new Double(1.95)}};\n\n\n\n\nThe accompanying picture sheds a bit of light on internal representation\n\n\n\n\nFrom the picture you clearly see that a two-dimensional array in Java is an array of arrays. The array obj has two elements obj[0] and obj[1] that are arrays of length 2 and 3 respectively.\n\n\nCloning 2D arrays\n\n\nThe procedure is even more confusing and less expected. Consider the following code segment\n\n\nObject[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10), \nbozo\n, new Double(1.95)}};\n\nObject[][] twin = (Object[][]) obj.clone();\n\n\n\n\nThe procedure of clonig 2d arrays is virtually the same as cloning an array of references. Unfortunately, built-in clone() method does not actualy clone each row, but rather creates references to them Here is a graphical interpretation of the above code\n\n\n\n\nLet us change the value of \nobj[1][1]\n\n\nobj[1][1] = \nxyz\n;\n\n\n\n\nThis assignment effects the value of \ntwin[1][1]\n as well\n\n\n\n\nSuch a copy is called a \"shallow\" copy. The default behavior of clone() is to return a shallow copy of the object. If we want a \"deep\" copy instead, we must provide our own implementation by overriding Object's clone() method.\n\n\nThe idea of a \"deep\" copy is simple - it makes a distinct copy of each of the object's fields, recursing through the entire object. A deep copy is thus a completely separate object from the original; changes to it don't affect the original, and vise versa. In relevance to the above code, here is a deep clone graphically\n\n\n\n\nFurther, making a complete deep copy is not always needed. Consider an array of immutable objects. As we know, immutable objects cannot be modified, allowing clients to share the same instance without interfering with each other. In this case there is no need to clone them, which leads to the following picture\n\n\n\n\nAlways in this course we will create data structures of immutable objets, therefore implementing the clone method will require copying a structure (a shape) and sharing its internal data. We will discuss these issues later on in the course.\n\n\nChallenges\n\n\n\n\n\"Arrays: Left Rotation\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Array Data Structure\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Arrays"
        }, 
        {
            "location": "/ds_array/#arrays", 
            "text": "An array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.  Here is the list of most important array features you must know (i.e. be able to program)   copying and cloning  insertion and deletion  searching and sorting   You already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:  int[] a = {9, 5, 4};\nint[] b = a;  The assignment operator creates an alias to the object, like in the picture below   Since these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,  int [] a = {1,2,3};\nint [] b = {1,2,3};  a and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.", 
            "title": "Arrays"
        }, 
        {
            "location": "/ds_array/#the-arrays-class", 
            "text": "The java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:  int[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println( arrays with identical contents );  Another commonly used method is toString() which takes care of of printing  int[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));  Here is the example of sorting  int[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));  In addition to that, the class has other utility methods for supporting operations over multidimensional arrays.", 
            "title": "The Arrays class"
        }, 
        {
            "location": "/ds_array/#copying-arrays", 
            "text": "There are four ways to copy arrays  using a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i   a.length; i++) b[i] = a[i];  The next choice is to use Arrays.copyOf()  int[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);  The second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.  The most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature  public static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)  The method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)  And the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment  int[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();  Note, that casting (int[]) is the must.  Examine the code in ArrayCopyPrimitives.java for further details.", 
            "title": "Copying arrays"
        }, 
        {
            "location": "/ds_array/#insertion-and-deletion", 
            "text": "Arrays in Java have no methods and only one  immutable  field  length . Once an array is created, its length is fixed and cannot be changed. What do you do to resize the array? You allocate the array with a different size and copy the contents of the old array to the new array. This code example demonstrates deletion from an array of primitives  public char[] delete(char[] data, int pos)\n{\n    if(pos  = 0   pos   data.length)\n    {\n        char[] tmp = new char[data.length-1];\n        System.arraycopy(data, 0, tmp, 0, pos);\n        System.arraycopy(data, pos+1, tmp, pos, data.length-pos-1);\n        return tmp;\n    }\n    else\n        return data;\n}  The first arraycopy copies the elements from index 0 to index pos-1, the second arraycopy copies the elements from index pos+1 to data.length.  Examine the code in ArrayDemo.java for further details.", 
            "title": "Insertion and Deletion"
        }, 
        {
            "location": "/ds_array/#the-arraylist-class", 
            "text": "The java.util.ArrayList class supports an idea of a dynamic array - an array that grows and shrinks on demand to accomodate the number of elements in the array. Below is a list of commonly used methods   add(object)  - adds to the end  add(index, object)  - inserts at the index  set(index, object)  - replaces at the index  get(index)  - returns the element at that index  remove(index)  - deletes the element at that index  size()  - returns the number of elements   The following code example will give you a heads up into how some of them are used.  /* ADD */\n      ArrayList Integer  num = new ArrayList Integer ();\n      for(int i = 0; i   10; i++) num.add(i);\n      System.out.println(num);\n\n\n/* REMOVE even integers */\n      for(int i = 0; i   num.size(); i++)\n        if(num.get(i)%2 == 0) num.remove(i);\n      System.out.println(num);", 
            "title": "The ArrayList class"
        }, 
        {
            "location": "/ds_array/#copying-arrays-of-objects", 
            "text": "This topic is more complex for understanding.. Let us start with a simple loop structure  Object[] obj1 = {new Integer(10),\n                new StringBuffer( foobar ),\n                new Double(12.95)};\nObject[] obj2 = new Object[obj1.length];\nfor(int i = 0; i \u2039 obj1.length; i++)\n    obj2[i] = obj1[i];  At the first glance we might think that all data is copied. In reality, the internal data is shared between two arrays. The figure below illustrates the inner structure   The assignment operator  obj2[i] = obj1[i]  is a crucial part of understanding the concept. You cannot copy references by assigning one to another. The assignment creates an alias rather than a copy. Let us trace down changes in the above picture after execution the following statements  obj1[0] = new Integer(5);   and  ((StringBuffer) obj1[1]).append('s');   As you see,  obj1[0]  and  obj2[0]  now refer to different objects. However,  obj1[1]  and  obj2[1]  refer to the same object (which is \"foobars\"). Since both arrays shares the data, you must be quite careful when you modify your data, because it might lead to unexpected effects.  The same behavior will take place again, if we use Arrays.copuyOf(), System.arraycopy() and clone(). Examine the code example ArrayCopyReferences.java for further details.", 
            "title": "Copying arrays of objects"
        }, 
        {
            "location": "/ds_array/#multi-dimensional-arrays", 
            "text": "In many practical application there is a need to use two- or multi-dimensional arrays. A two-dimensional array can be thought of as a table of rows and columns. This creates a table of 2 rows and 4 columns:  int[][] ar1 = new int[2][4];  You can create and initialize an array by using nested curcly braces. For example, this creates a table of 3 rows and 2 columns:  int[][] ar2 = {{1,2},{3,4},{5,6}};  Generally speaking, a two-dimensional array is not exactly a table - each row in such array can have a different length. Consider this code fragment  Object[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10),  bozo , new Double(1.95)}};  The accompanying picture sheds a bit of light on internal representation   From the picture you clearly see that a two-dimensional array in Java is an array of arrays. The array obj has two elements obj[0] and obj[1] that are arrays of length 2 and 3 respectively.", 
            "title": "Multi-dimensional arrays"
        }, 
        {
            "location": "/ds_array/#cloning-2d-arrays", 
            "text": "The procedure is even more confusing and less expected. Consider the following code segment  Object[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10),  bozo , new Double(1.95)}};\n\nObject[][] twin = (Object[][]) obj.clone();  The procedure of clonig 2d arrays is virtually the same as cloning an array of references. Unfortunately, built-in clone() method does not actualy clone each row, but rather creates references to them Here is a graphical interpretation of the above code   Let us change the value of  obj[1][1]  obj[1][1] =  xyz ;  This assignment effects the value of  twin[1][1]  as well   Such a copy is called a \"shallow\" copy. The default behavior of clone() is to return a shallow copy of the object. If we want a \"deep\" copy instead, we must provide our own implementation by overriding Object's clone() method.  The idea of a \"deep\" copy is simple - it makes a distinct copy of each of the object's fields, recursing through the entire object. A deep copy is thus a completely separate object from the original; changes to it don't affect the original, and vise versa. In relevance to the above code, here is a deep clone graphically   Further, making a complete deep copy is not always needed. Consider an array of immutable objects. As we know, immutable objects cannot be modified, allowing clients to share the same instance without interfering with each other. In this case there is no need to clone them, which leads to the following picture   Always in this course we will create data structures of immutable objets, therefore implementing the clone method will require copying a structure (a shape) and sharing its internal data. We will discuss these issues later on in the course.", 
            "title": "Cloning 2D arrays"
        }, 
        {
            "location": "/ds_array/#challenges", 
            "text": "\"Arrays: Left Rotation\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/ds_array/#references", 
            "text": "\"Array Data Structure\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/ds_linked_list/", 
            "text": "Linked List\n\n\nA linked list is a sequence of data structures, which are connected together via links.\n\n\nLinked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array. Following are the important terms to understand the concept of Linked List.\n\n\n\n\nLink \u2212 Each link of a linked list can store a data called an element.\n\n\nNext \u2212 Each link of a linked list contains a link to the next link called Next.\n\n\nLinkedList \u2212 A Linked List contains the connection link to the first link called First.\n\n\n\n\nRepresentation\n\n\nLinked list can be visualized as a chain of nodes, where every node points to the next node.\n\n\n\n\nAs per the above illustration, following are the important points to be considered.\n\n\n\n\nLinked List contains a link element called first.\n\n\nEach link carries a data field(s) and a link field called next.\n\n\nEach link is linked with its next link using its next link.\n\n\nLast link carries a link as null to mark the end of the list.\n\n\n\n\nTypes of Linked List\n\n\nFollowing are the various types of linked list.\n\n\n\n\nSimple Linked List \u2212 Item navigation is forward only.\n\n\nDoubly Linked List \u2212 Items can be navigated forward and backward.\n\n\nCircular Linked List \u2212 Last item contains link of the first element as next and the first element has a link to the last element as previous.\n\n\n\n\nBasic Operations\n\n\nFollowing are the basic operations supported by a list.\n\n\n\n\nInsertion \u2212 Adds an element at the beginning of the list.\n\n\nDeletion \u2212 Deletes an element at the beginning of the list.\n\n\nDisplay \u2212 Displays the complete list.\n\n\nSearch \u2212 Searches an element using the given key.\n\n\nDelete \u2212 Deletes an element using the given key.\n\n\n\n\nInsertion Operation\n\n\nAdding a new node in linked list is a more than one step activity. We shall learn this with diagrams here. First, create a node using the same structure and find the location where it has to be inserted.\n\n\n\n\nImagine that we are inserting a node B (NewNode), between A (LeftNode) and C (RightNode). Then point B.next to C\n\n\nNewNode.next \u2212\n RightNode;\n\n\n\n\nIt should look like this\n\n\n\n\nNow, the next node at the left should point to the new node.\n\n\nLeftNode.next \u2212\n NewNode;\n\n\n\n\n\n\nThis will put the new node in the middle of the two. The new list should look like this\n\n\n\n\nSimilar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.\n\n\nDeletion Operation\n\n\nDeletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.\n\n\n\n\nThe left (previous) node of the target node now should point to the next node of the target node\n\n\nLeftNode.next \u2212\n TargetNode.next;\n\n\n\n\n\n\nThis will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.\n\n\nTargetNode.next \u2212\n NULL;\n\n\n\n\n\n\nWe need to use the deleted node. We can keep that in memory otherwise we can simply deallocate memory and wipe off the target node completely.\n\n\nReverse Operation\n\n\nThis operation is a thorough one. We need to make the last node to be pointed by the head node and reverse the whole linked list.\n\n\n\n\nFirst, we traverse to the end of the list. It should be pointing to NULL. Now, we shall make it point to its previous node\n\n\n\n\nWe have to make sure that the last node is not the lost node. So we'll have some temp node, which looks like the head node pointing to the last node. Now, we shall make all left side nodes point to their previous nodes one by one.\n\n\n\n\nExcept the node (first node) pointed by the head node, all nodes should point to their predecessor, making them their new successor. The first node will point to NULL.\n\n\n\n\nWe'll make the head node point to the new first node by using the temp node.\n\n\n\n\nThe linked list is now reversed.", 
            "title": "Linked List"
        }, 
        {
            "location": "/ds_linked_list/#linked-list", 
            "text": "A linked list is a sequence of data structures, which are connected together via links.  Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array. Following are the important terms to understand the concept of Linked List.   Link \u2212 Each link of a linked list can store a data called an element.  Next \u2212 Each link of a linked list contains a link to the next link called Next.  LinkedList \u2212 A Linked List contains the connection link to the first link called First.", 
            "title": "Linked List"
        }, 
        {
            "location": "/ds_linked_list/#representation", 
            "text": "Linked list can be visualized as a chain of nodes, where every node points to the next node.   As per the above illustration, following are the important points to be considered.   Linked List contains a link element called first.  Each link carries a data field(s) and a link field called next.  Each link is linked with its next link using its next link.  Last link carries a link as null to mark the end of the list.", 
            "title": "Representation"
        }, 
        {
            "location": "/ds_linked_list/#types-of-linked-list", 
            "text": "Following are the various types of linked list.   Simple Linked List \u2212 Item navigation is forward only.  Doubly Linked List \u2212 Items can be navigated forward and backward.  Circular Linked List \u2212 Last item contains link of the first element as next and the first element has a link to the last element as previous.", 
            "title": "Types of Linked List"
        }, 
        {
            "location": "/ds_linked_list/#basic-operations", 
            "text": "Following are the basic operations supported by a list.   Insertion \u2212 Adds an element at the beginning of the list.  Deletion \u2212 Deletes an element at the beginning of the list.  Display \u2212 Displays the complete list.  Search \u2212 Searches an element using the given key.  Delete \u2212 Deletes an element using the given key.", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/ds_linked_list/#insertion-operation", 
            "text": "Adding a new node in linked list is a more than one step activity. We shall learn this with diagrams here. First, create a node using the same structure and find the location where it has to be inserted.   Imagine that we are inserting a node B (NewNode), between A (LeftNode) and C (RightNode). Then point B.next to C  NewNode.next \u2212  RightNode;  It should look like this   Now, the next node at the left should point to the new node.  LeftNode.next \u2212  NewNode;   This will put the new node in the middle of the two. The new list should look like this   Similar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.", 
            "title": "Insertion Operation"
        }, 
        {
            "location": "/ds_linked_list/#deletion-operation", 
            "text": "Deletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.   The left (previous) node of the target node now should point to the next node of the target node  LeftNode.next \u2212  TargetNode.next;   This will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.  TargetNode.next \u2212  NULL;   We need to use the deleted node. We can keep that in memory otherwise we can simply deallocate memory and wipe off the target node completely.", 
            "title": "Deletion Operation"
        }, 
        {
            "location": "/ds_linked_list/#reverse-operation", 
            "text": "This operation is a thorough one. We need to make the last node to be pointed by the head node and reverse the whole linked list.   First, we traverse to the end of the list. It should be pointing to NULL. Now, we shall make it point to its previous node   We have to make sure that the last node is not the lost node. So we'll have some temp node, which looks like the head node pointing to the last node. Now, we shall make all left side nodes point to their previous nodes one by one.   Except the node (first node) pointed by the head node, all nodes should point to their predecessor, making them their new successor. The first node will point to NULL.   We'll make the head node point to the new first node by using the temp node.   The linked list is now reversed.", 
            "title": "Reverse Operation"
        }, 
        {
            "location": "/ds_stack_queue/", 
            "text": "Stacks and Queues\n\n\nAn array is a random access data structure, where each element can be accessed directly and in constant time. A typical illustration of random access is a book - each page of the book can be open independently of others. Random access is critical to many algorithms, for example binary search.\n\n\nA linked list is a sequential access data structure, where each element can be accesed only in particular order. A typical illustration of sequential access is a roll of paper or tape - all prior material must be unrolled in order to get to data you want.\n\n\nIn this note we consider a subcase of sequential data structures, so-called limited access data sturctures.\n\n\nStacks\n\n\nA stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO) principle. In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item out of the stack. A stack is a limited access data structure - elements can be added and removed from the stack only at the top. push adds an item to the top of the stack, pop removes the item from the top. A helpful analogy is to think of a stack of books; you can remove only the top book, also you can add a new book on the top.\nA stack is a recursive data structure. Here is a structural definition of a Stack:\n\n\n\n\na stack is either empty or\n\n\nit consistes of a top and the rest which is a stack;\n\n\n\n\n\n\nApplications\n\n\n\n\nThe simplest application of a stack is to reverse a word. You push a given word to stack - letter by letter - and then pop letters from the stack.\n\n\nAnother application is an \"undo\" mechanism in text editors; this operation is accomplished by keeping all text changes in a stack.\n\n\nBacktracking\n. This is a process when you need to access the most recent data element in a series of elements. Think of a labyrinth or maze - how do you find a way from an entrance to an exit?\nOnce you reach a dead end, you must backtrack. But backtrack to where? to the previous choice point. Therefore, at each choice point you store on a stack all possible choices. Then backtracking simply means popping a next choice from the stack.\n\n\n\n\n\n\n\n\nLanguage processing:\n\n\nspace for parameters and local variables is created internally using a stack.\n\n\ncompiler's syntax check for matching braces is implemented by using stack.\n\n\nsupport for recursion\n\n\n\n\n\n\n\n\nImplementation\n\n\nIn the standard library of classes, the data type stack is an adapter class, meaning that a stack is built on top of other data structures. The underlying structure for a stack could be an array, a vector, an ArrayList, a linked list, or any other collection. Regardless of the type of the underlying data structure, a Stack must implement the same functionality. This is achieved by providing a unique interface:\n\n\npublic interface StackInterface\nAnyType\n\n{\n   public void push(AnyType e);\n\n   public AnyType pop();\n\n   public AnyType peek();\n\n   public boolean isEmpty();\n}\n\n\n\n\nThe following picture demonstrates the idea of implementation by composition.\n\n\n\n\nAnother implementation requirement (in addition to the above interface) is that all stack operations must run in constant time O(1). Constant time means that there is some constant k such that an operation takes k nanoseconds of computational time regardless of the stack size.\n\n\nArray-based implementation\n\n\n\n\nIn an array-based implementation we maintain the following fields: an array A of a default size (\u2265 1), the variable top that refers to the top element in the stack and the capacity that refers to the array size. The variable top changes from -1 to capacity - 1. We say that a stack is empty when top = -1, and the stack is full when top = capacity-1.\nIn a fixed-size stack abstraction, the capacity stays unchanged, therefore when top reaches capacity, the stack object throws an exception. See ArrayStack.java for a complete implementation of the stack class.\n\n\nIn a dynamic stack abstraction when top reaches capacity, we double up the stack siz\n\n\nLinked List-based implementation\n\n\n\n\nLinked List-based implementation provides the best (from the efficiency point of view) dynamic stack implementation.\nSee ListStack.java for a complete implementation of the stack class.\n\n\nQueues\n\n\nA queue is a container of objects (a linear collection) that are inserted and removed according to the first-in first-out (FIFO) principle. An excellent example of a queue is a line of students in the food court of the UC. New additions to a line made to the back of the queue, while removal (or serving) happens in the front. In the queue only two operations are allowed enqueue and dequeue. Enqueue means to insert an item into the back of the queue, dequeue means removing the front item. The picture demonstrates the FIFO access.\nThe difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.\n\n\n\n\nImplementation\n\n\nIn the standard library of classes, the data type queue is an adapter class, meaning that a queue is built on top of other data structures. The underlying structure for a queue could be an array, a Vector, an ArrayList, a LinkedList, or any other collection. Regardless of the type of the underlying data structure, a queue must implement the same functionality. This is achieved by providing a unique interface.\n\n\ninterface QueueInterface\u2039AnyType\n\n{\n   public boolean isEmpty();\n\n   public AnyType getFront();\n\n   public AnyType dequeue();\n\n   public void enqueue(AnyType e);\n\n   public void clear();\n}\n\n\n\n\nEach of the above basic operations must run at constant time O(1). The following picture demonstrates the idea of implementation by composition.\n\n\n\n\nCircular Queue\n\n\nGiven an array A of a default size (\u2265 1) with two references back and front, originally set to -1 and 0 respectively. Each time we insert (enqueue) a new item, we increase the back index; when we remove (dequeue) an item - we increase the front index. Here is a picture that illustrates the model after a few steps:\n\n\n\n\nAs you see from the picture, the queue logically moves in the array from left to right. After several moves back reaches the end, leaving no space for adding new elements\n\n\n\n\nHowever, there is a free space before the front index. We shall use that space for enqueueing new items, i.e. the next entry will be stored at index 0, then 1, until front. Such a model is called a wrap around queue or a circular queue\n\n\n\n\nFinally, when back reaches front, the queue is full. There are two choices to handle a full queue:a) throw an exception; b) double the array size.\n\n\nThe circular queue implementation is done by using the modulo operator (denoted %), which is computed by taking the remainder of division (for example, 8%5 is 3). By using the modulo operator, we can view the queue as a circular array, where the \"wrapped around\" can be simulated as \"back % array_size\". In addition to the back and front indexes, we maintain another index: cur - for counting the number of elements in a queue. Having this index simplifies a logic of implementation.\n\n\nSee ArrayQueue.java for a complete implementation of a circular queue.\n\n\nApplications\n\n\nThe simplest two search techniques are known as Depth-First Search(DFS) and Breadth-First Search (BFS). These two searches are described by looking at how the search tree (representing all the possible paths from the start) will be traversed.\n\n\nDeapth-First Search with a Stack\n\n\nIn depth-first search we go down a path until we get to a dead end; then we backtrack or back up (by popping a stack) to get an alternative path.\n\n\nCreate a stack\nCreate a new choice point\nPush the choice point onto the stack\nwhile (not found and stack is not empty)\n    Pop the stack\n    Find all possible choices after the last one tried\n    Push these choices onto the stack\nReturn\n\n\n\n\nBreadth-First Search with a Queue\n\n\nIn breadth-first search we explore all the nearest possibilities by finding all possible successors and enqueue them to a queue.\n\n\nCreate a queue\nCreate a new choice point\nEnqueue the choice point onto the queue\nwhile (not found and queue is not empty)\n    Dequeue the queue\n    Find all possible choices after the last one tried\n    Enqueue these choices onto the queue\nReturn\n\n\n\n\nWe will see more on search techniques later in the course.\n\n\nArithmetic Expression Evaluation\n\n\nAn important application of stacks is in parsing. For example, a compiler must parse arithmetic expressions written using infix notation:\n\n\n1 + ((2 + 3) * 4 + 5)*6\n\n\n\n\nWe break the problem of parsing infix expressions into two stages. First, we convert from infix to a different representation called postfix. Then we parse the postfix expression, which is a somewhat easier problem than directly parsing infix.\n\n\nConverting from Infix to Postfix.\n Typically, we deal with expressions in infix notation\n\n\n2 + 5\n\n\n\n\nwhere the operators (e.g. +, *) are written between the operands (e.q, 2 and 5). Writing the operators after the operands gives a postfix expression 2 and 5 are called operands, and the '+' is operator. The above arithmetic expression is called infix, since the operator is in between operands. The expression\n\n\n2 5 +\n\n\n\n\nWriting the operators before the operands gives a prefix expression\n\n\n+2 5\n\n\n\n\nSuppose you want to compute the cost of your shopping trip. To do so, you add a list of numbers and multiply them by the local sales tax (7.25%):\n\n\n70 + 150 * 1.0725\n\n\n\n\nDepending on the calculator, the answer would be either 235.95 or 230.875. To avoid this confusion we shall use a postfix notation\n\n\n70  150 + 1.0725 *\n\n\n\n\nPostfix has the nice property that parentheses are unnecessary.\n\n\nNow, we describe how to convert from infix to postfix.\n\n\n\n\nRead in the tokens one at a time\n\n\nIf a token is an integer, write it into the output\n\n\nIf a token is an operator, push it to the stack, if the stack is empty. If the stack is not empty, you pop entries with higher or equal priority and only then you push that 1. token to the stack.\n\n\nIf a token is a left parentheses '(', push it to the stack\n\n\nIf a token is a right parentheses ')', you pop entries until you meet '('.\n\n\nWhen you finish reading the string, you pop up all tokens which are left there.\n\n\nArithmetic precedence is in increasing order: '+', '-', '*', '/';\n\n\n\n\nExample. Suppose we have an infix expression:2+(4+3*2+1)/3. We read the string by characters.\n\n\n'2' - send to the output.\n'+' - push on the stack.\n'(' - push on the stack.\n'4' - send to the output.\n'+' - push on the stack.\n'3' - send to the output.\n'*' - push on the stack.\n'2' - send to the output.\n\n\n\n\nEvaluating a Postfix Expression\n. We describe how to parse and evaluate a postfix expression.\n\n\n\n\nWe read the tokens in one at a time.\n\n\nIf it is an integer, push it on the stack\n\n\nIf it is a binary operator, pop the top two elements from the stack, apply the operator, and push the result back on the stack.\n\n\n\n\nConsider the following postfix expression\n\n\n5 9 3 + 4 2 * * 7 + *\n\n\n\n\nHere is a chain of operations\n\n\nStack Operations              Output\n--------------------------------------\npush(5);                        5\npush(9);                        5 9\npush(3);                        5 9 3\npush(pop() + pop())             5 12\npush(4);                        5 12 4\npush(2);                        5 12 4 2\npush(pop() * pop())             5 12 8\npush(pop() * pop())             5 96\npush(7)                         5 96 7\npush(pop() + pop())             5 103\npush(pop() * pop())             515\n\n\n\n\nNote, that division is not a commutative operation, so 2/3 is not the same as 3/2.\n\n\nChallenges\n\n\n\n\nStacks: Balanced Brackets\n\n\nQueues: A Tale of Two Stacks\n\n\n\n\nReferences\n\n\n\n\n\"Stacks and Queues\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Stacks & Queues"
        }, 
        {
            "location": "/ds_stack_queue/#stacks-and-queues", 
            "text": "An array is a random access data structure, where each element can be accessed directly and in constant time. A typical illustration of random access is a book - each page of the book can be open independently of others. Random access is critical to many algorithms, for example binary search.  A linked list is a sequential access data structure, where each element can be accesed only in particular order. A typical illustration of sequential access is a roll of paper or tape - all prior material must be unrolled in order to get to data you want.  In this note we consider a subcase of sequential data structures, so-called limited access data sturctures.", 
            "title": "Stacks and Queues"
        }, 
        {
            "location": "/ds_stack_queue/#stacks", 
            "text": "A stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO) principle. In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item out of the stack. A stack is a limited access data structure - elements can be added and removed from the stack only at the top. push adds an item to the top of the stack, pop removes the item from the top. A helpful analogy is to think of a stack of books; you can remove only the top book, also you can add a new book on the top.\nA stack is a recursive data structure. Here is a structural definition of a Stack:   a stack is either empty or  it consistes of a top and the rest which is a stack;", 
            "title": "Stacks"
        }, 
        {
            "location": "/ds_stack_queue/#applications", 
            "text": "The simplest application of a stack is to reverse a word. You push a given word to stack - letter by letter - and then pop letters from the stack.  Another application is an \"undo\" mechanism in text editors; this operation is accomplished by keeping all text changes in a stack.  Backtracking . This is a process when you need to access the most recent data element in a series of elements. Think of a labyrinth or maze - how do you find a way from an entrance to an exit?\nOnce you reach a dead end, you must backtrack. But backtrack to where? to the previous choice point. Therefore, at each choice point you store on a stack all possible choices. Then backtracking simply means popping a next choice from the stack.     Language processing:  space for parameters and local variables is created internally using a stack.  compiler's syntax check for matching braces is implemented by using stack.  support for recursion", 
            "title": "Applications"
        }, 
        {
            "location": "/ds_stack_queue/#implementation", 
            "text": "In the standard library of classes, the data type stack is an adapter class, meaning that a stack is built on top of other data structures. The underlying structure for a stack could be an array, a vector, an ArrayList, a linked list, or any other collection. Regardless of the type of the underlying data structure, a Stack must implement the same functionality. This is achieved by providing a unique interface:  public interface StackInterface AnyType \n{\n   public void push(AnyType e);\n\n   public AnyType pop();\n\n   public AnyType peek();\n\n   public boolean isEmpty();\n}  The following picture demonstrates the idea of implementation by composition.   Another implementation requirement (in addition to the above interface) is that all stack operations must run in constant time O(1). Constant time means that there is some constant k such that an operation takes k nanoseconds of computational time regardless of the stack size.", 
            "title": "Implementation"
        }, 
        {
            "location": "/ds_stack_queue/#array-based-implementation", 
            "text": "In an array-based implementation we maintain the following fields: an array A of a default size (\u2265 1), the variable top that refers to the top element in the stack and the capacity that refers to the array size. The variable top changes from -1 to capacity - 1. We say that a stack is empty when top = -1, and the stack is full when top = capacity-1.\nIn a fixed-size stack abstraction, the capacity stays unchanged, therefore when top reaches capacity, the stack object throws an exception. See ArrayStack.java for a complete implementation of the stack class.  In a dynamic stack abstraction when top reaches capacity, we double up the stack siz", 
            "title": "Array-based implementation"
        }, 
        {
            "location": "/ds_stack_queue/#linked-list-based-implementation", 
            "text": "Linked List-based implementation provides the best (from the efficiency point of view) dynamic stack implementation.\nSee ListStack.java for a complete implementation of the stack class.", 
            "title": "Linked List-based implementation"
        }, 
        {
            "location": "/ds_stack_queue/#queues", 
            "text": "A queue is a container of objects (a linear collection) that are inserted and removed according to the first-in first-out (FIFO) principle. An excellent example of a queue is a line of students in the food court of the UC. New additions to a line made to the back of the queue, while removal (or serving) happens in the front. In the queue only two operations are allowed enqueue and dequeue. Enqueue means to insert an item into the back of the queue, dequeue means removing the front item. The picture demonstrates the FIFO access.\nThe difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.", 
            "title": "Queues"
        }, 
        {
            "location": "/ds_stack_queue/#implementation_1", 
            "text": "In the standard library of classes, the data type queue is an adapter class, meaning that a queue is built on top of other data structures. The underlying structure for a queue could be an array, a Vector, an ArrayList, a LinkedList, or any other collection. Regardless of the type of the underlying data structure, a queue must implement the same functionality. This is achieved by providing a unique interface.  interface QueueInterface\u2039AnyType \n{\n   public boolean isEmpty();\n\n   public AnyType getFront();\n\n   public AnyType dequeue();\n\n   public void enqueue(AnyType e);\n\n   public void clear();\n}  Each of the above basic operations must run at constant time O(1). The following picture demonstrates the idea of implementation by composition.", 
            "title": "Implementation"
        }, 
        {
            "location": "/ds_stack_queue/#circular-queue", 
            "text": "Given an array A of a default size (\u2265 1) with two references back and front, originally set to -1 and 0 respectively. Each time we insert (enqueue) a new item, we increase the back index; when we remove (dequeue) an item - we increase the front index. Here is a picture that illustrates the model after a few steps:   As you see from the picture, the queue logically moves in the array from left to right. After several moves back reaches the end, leaving no space for adding new elements   However, there is a free space before the front index. We shall use that space for enqueueing new items, i.e. the next entry will be stored at index 0, then 1, until front. Such a model is called a wrap around queue or a circular queue   Finally, when back reaches front, the queue is full. There are two choices to handle a full queue:a) throw an exception; b) double the array size.  The circular queue implementation is done by using the modulo operator (denoted %), which is computed by taking the remainder of division (for example, 8%5 is 3). By using the modulo operator, we can view the queue as a circular array, where the \"wrapped around\" can be simulated as \"back % array_size\". In addition to the back and front indexes, we maintain another index: cur - for counting the number of elements in a queue. Having this index simplifies a logic of implementation.  See ArrayQueue.java for a complete implementation of a circular queue.", 
            "title": "Circular Queue"
        }, 
        {
            "location": "/ds_stack_queue/#applications_1", 
            "text": "The simplest two search techniques are known as Depth-First Search(DFS) and Breadth-First Search (BFS). These two searches are described by looking at how the search tree (representing all the possible paths from the start) will be traversed.", 
            "title": "Applications"
        }, 
        {
            "location": "/ds_stack_queue/#deapth-first-search-with-a-stack", 
            "text": "In depth-first search we go down a path until we get to a dead end; then we backtrack or back up (by popping a stack) to get an alternative path.  Create a stack\nCreate a new choice point\nPush the choice point onto the stack\nwhile (not found and stack is not empty)\n    Pop the stack\n    Find all possible choices after the last one tried\n    Push these choices onto the stack\nReturn", 
            "title": "Deapth-First Search with a Stack"
        }, 
        {
            "location": "/ds_stack_queue/#breadth-first-search-with-a-queue", 
            "text": "In breadth-first search we explore all the nearest possibilities by finding all possible successors and enqueue them to a queue.  Create a queue\nCreate a new choice point\nEnqueue the choice point onto the queue\nwhile (not found and queue is not empty)\n    Dequeue the queue\n    Find all possible choices after the last one tried\n    Enqueue these choices onto the queue\nReturn  We will see more on search techniques later in the course.", 
            "title": "Breadth-First Search with a Queue"
        }, 
        {
            "location": "/ds_stack_queue/#arithmetic-expression-evaluation", 
            "text": "An important application of stacks is in parsing. For example, a compiler must parse arithmetic expressions written using infix notation:  1 + ((2 + 3) * 4 + 5)*6  We break the problem of parsing infix expressions into two stages. First, we convert from infix to a different representation called postfix. Then we parse the postfix expression, which is a somewhat easier problem than directly parsing infix.  Converting from Infix to Postfix.  Typically, we deal with expressions in infix notation  2 + 5  where the operators (e.g. +, *) are written between the operands (e.q, 2 and 5). Writing the operators after the operands gives a postfix expression 2 and 5 are called operands, and the '+' is operator. The above arithmetic expression is called infix, since the operator is in between operands. The expression  2 5 +  Writing the operators before the operands gives a prefix expression  +2 5  Suppose you want to compute the cost of your shopping trip. To do so, you add a list of numbers and multiply them by the local sales tax (7.25%):  70 + 150 * 1.0725  Depending on the calculator, the answer would be either 235.95 or 230.875. To avoid this confusion we shall use a postfix notation  70  150 + 1.0725 *  Postfix has the nice property that parentheses are unnecessary.  Now, we describe how to convert from infix to postfix.   Read in the tokens one at a time  If a token is an integer, write it into the output  If a token is an operator, push it to the stack, if the stack is empty. If the stack is not empty, you pop entries with higher or equal priority and only then you push that 1. token to the stack.  If a token is a left parentheses '(', push it to the stack  If a token is a right parentheses ')', you pop entries until you meet '('.  When you finish reading the string, you pop up all tokens which are left there.  Arithmetic precedence is in increasing order: '+', '-', '*', '/';   Example. Suppose we have an infix expression:2+(4+3*2+1)/3. We read the string by characters.  '2' - send to the output.\n'+' - push on the stack.\n'(' - push on the stack.\n'4' - send to the output.\n'+' - push on the stack.\n'3' - send to the output.\n'*' - push on the stack.\n'2' - send to the output.  Evaluating a Postfix Expression . We describe how to parse and evaluate a postfix expression.   We read the tokens in one at a time.  If it is an integer, push it on the stack  If it is a binary operator, pop the top two elements from the stack, apply the operator, and push the result back on the stack.   Consider the following postfix expression  5 9 3 + 4 2 * * 7 + *  Here is a chain of operations  Stack Operations              Output\n--------------------------------------\npush(5);                        5\npush(9);                        5 9\npush(3);                        5 9 3\npush(pop() + pop())             5 12\npush(4);                        5 12 4\npush(2);                        5 12 4 2\npush(pop() * pop())             5 12 8\npush(pop() * pop())             5 96\npush(7)                         5 96 7\npush(pop() + pop())             5 103\npush(pop() * pop())             515  Note, that division is not a commutative operation, so 2/3 is not the same as 3/2.", 
            "title": "Arithmetic Expression Evaluation"
        }, 
        {
            "location": "/ds_stack_queue/#challenges", 
            "text": "Stacks: Balanced Brackets  Queues: A Tale of Two Stacks", 
            "title": "Challenges"
        }, 
        {
            "location": "/ds_stack_queue/#references", 
            "text": "\"Stacks and Queues\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/ds_tree/", 
            "text": "Tree\n\n\nBinary Tree\n\n\nFundamentally, a binary tree is composed of nodes connected by edges (with further restrictions discussed below). Some binary tree, \nt\n, is either empty or consists of a single root element with two distinct binary tree child elements known as the \nleft subtree\n and the \nright subtree\n of \nt\n. As the name \nbinary\n suggests, a node in a binary tree has a \nmaximum\n of \n2\n children.\n\n\nThe following diagrams depict two different binary trees: \n\n\n \n\n\nHere are the basic facts and terms to know about binary trees:\n\n\n\n\nThe convention for binary tree diagrams is that the \nroot\n is at the top, and the subtrees branch down from it.\n\n\nA node's \nleft\n and \nright\n subtrees are referred to as \nchildren\n, and that node can be referred to as the \nparent\n of those subtrees.\n\n\nA non-root node with no children is called a \nleaf\n.\n\n\nSome node \na\n is an ancestor of some node \nb\n if \nb\n is located in a left or right subtree whose root node is \na\n. This means that the root node of binary tree \nt\n is the ancestor of all other nodes in the tree.\n\n\nIf some node \na\n is an ancestor of some node \nb\n, then the path from \na\n to \nb\n is the sequence of nodes starting with \na\n, moving down the ancestral chain of children, and ending with bb.\n\n\nThe depth (or level) of some node \na\n is its distance (i.e., number of edges) from the tree's root node.\n\n\nSimply put, the height of a tree is the number of edges between the root node and its furthest leaf.\n\n\nMore technically put, it's \n1+max(height(leftSubtree), height(rightSubtree))\n ) (i.e., one more than the maximum of the heights of its left and right subtrees).\n\n\nAny node has a height of \n1\n, and the height of an empty subtree is \n - 1 \n.\n\n\nBecause the height of each node is \n1 + \n the maximum height of its subtrees and an empty subtree's height is \n - 1 \n, the height of a single-element tree or leaf node is \n0\n.\n\n\n\n\n\n\n\n\nLet's apply some of the terms we learned above to the binary tree on the right:\n\n\n\n\n\n\nThe root node is \nA\n.\n\n\n\n\n\n\nThe respective left and right children of \nA\n are \nB\n and \nE\n. The left child of \nB\n is \nC\n. The respective left and right children of \nE\n are \nF\n and \nD\n.\n\n\n\n\n\n\nNodes \nC\n, \nF\n, and \nD\n are leaves (i.e., each node is a leaf).\n\n\n\n\n\n\nThe root is the ancestor of all other nodes, \nB\n is an ancestor of \nC\n, and \nE\n is an ancestor of \nF\n and \nD\n.\n\n\n\n\n\n\nThe path between \nA\n and \nC\n is \n A \\rightarrow B \\rightarrow C \n. The path between \nA\n and \nF\n is \n A \\rightarrow E \\rightarrow F \n. The path between \nA\n and \nD\n is A \n \\rightarrow E \\rightarrow D \n.\n\n\n\n\n\n\nThe depth of root node \nA\n is \n0\n. The depth of nodes \nB\n and \nE\n is \n1\n. The depth of nodes \nC\n, \nF\n, and \nD\n, is \n2\n.\n\n\n\n\n\n\nThe height of the tree, \n height(t) \n, is \n2\n. We calculate this recursively as \n height(t)=1+(max(height(root.leftChild),height(root.rightChild))) \n.\n\n\n\n\n\n\nBecause this is long and complicated when expanded, we'll break it down using an image of a slightly simpler version of \nt\n whose height is still \n2\n: \n\n\n \n\n\nBinary Search Tree\n\n\nA Binary Search Tree (BST), \nt\n, is a binary tree that is either empty or satisfies the following three conditions:\n\n\n\n\n\n\nEach element in the left subtree of \nt\n is less than or equal to the root element of \nt\n (i.e., \n max(leftTree(t).value) \\leq t.valuemax(leftTree(t).value) \\leq t.value \n).\n\n\n\n\n\n\nEach element in the right subtree of \nt\n is greater than the root element of \nt\n (i.e., \n max(rightTree(t).value) \\ge t.valuemax(rightTree(t).value) \\ge t.value\n).\n\n\n\n\n\n\nBoth \n leftTree(t) \n and \n rightTree(t) \n are BSTs.\n\n\n\n\n\n\nYou can essentially think of it as a regular binary tree where for each node parent having a \n leftChild \n and \n rightChild \n, \n leftChild.value \\leq parent.value \\le rightChild.value \n. In the first diagram at the top of this article, the binary tree of integers on the left side is a binary search tree.\n\n\nAdvantages and Drawbacks\n\n\n\n\nSearching for elements is very fast.\n\n\n\n\nWe know that each node has a maximum of two children and we know that the \n \\leq \n items are always in the left subtree and the \n > \n items are always in the right subtree. To search for an element, we simply need to compare the value we want against the value stored in the root node of the current subtree and work our way down the appropriate child subtrees until we either find the value we're looking for or we hit \nnull\n (i.e., an empty subtree) which indicates the item is not in the BST. Inserting or searching for a node in a balanced tree is \n O(\\log n) \n because you're discarding half of the possible values each time you go left or right.\n\n\n\n\nIt can easily become unbalanced.\n\n\n\n\nDepending on the insertion order, the tree can very easily become unbalanced (which makes for longer search times). For example, if we create a new tree where the sequence of inserted nodes is \n 2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \n, we end up with the following unbalanced tree: \n\n\n\n\nObserve that the root's left subtree only has one node, whereas the root's right subtree has four nodes. For this reason, inserting or searching for a node in an unbalanced tree is \n O(n) \n.\n\n\nChallenges\n\n\n\n\n\"Trees: Is This a Binary Search Tree?\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Binary Trees and Binary Search Trees\". \nAllisonP, hackerrank\n. 2016", 
            "title": "Trees"
        }, 
        {
            "location": "/ds_tree/#tree", 
            "text": "", 
            "title": "Tree"
        }, 
        {
            "location": "/ds_tree/#binary-tree", 
            "text": "Fundamentally, a binary tree is composed of nodes connected by edges (with further restrictions discussed below). Some binary tree,  t , is either empty or consists of a single root element with two distinct binary tree child elements known as the  left subtree  and the  right subtree  of  t . As the name  binary  suggests, a node in a binary tree has a  maximum  of  2  children.  The following diagrams depict two different binary trees:      Here are the basic facts and terms to know about binary trees:   The convention for binary tree diagrams is that the  root  is at the top, and the subtrees branch down from it.  A node's  left  and  right  subtrees are referred to as  children , and that node can be referred to as the  parent  of those subtrees.  A non-root node with no children is called a  leaf .  Some node  a  is an ancestor of some node  b  if  b  is located in a left or right subtree whose root node is  a . This means that the root node of binary tree  t  is the ancestor of all other nodes in the tree.  If some node  a  is an ancestor of some node  b , then the path from  a  to  b  is the sequence of nodes starting with  a , moving down the ancestral chain of children, and ending with bb.  The depth (or level) of some node  a  is its distance (i.e., number of edges) from the tree's root node.  Simply put, the height of a tree is the number of edges between the root node and its furthest leaf.  More technically put, it's  1+max(height(leftSubtree), height(rightSubtree))  ) (i.e., one more than the maximum of the heights of its left and right subtrees).  Any node has a height of  1 , and the height of an empty subtree is   - 1  .  Because the height of each node is  1 +   the maximum height of its subtrees and an empty subtree's height is   - 1  , the height of a single-element tree or leaf node is  0 .     Let's apply some of the terms we learned above to the binary tree on the right:    The root node is  A .    The respective left and right children of  A  are  B  and  E . The left child of  B  is  C . The respective left and right children of  E  are  F  and  D .    Nodes  C ,  F , and  D  are leaves (i.e., each node is a leaf).    The root is the ancestor of all other nodes,  B  is an ancestor of  C , and  E  is an ancestor of  F  and  D .    The path between  A  and  C  is   A \\rightarrow B \\rightarrow C  . The path between  A  and  F  is   A \\rightarrow E \\rightarrow F  . The path between  A  and  D  is A   \\rightarrow E \\rightarrow D  .    The depth of root node  A  is  0 . The depth of nodes  B  and  E  is  1 . The depth of nodes  C ,  F , and  D , is  2 .    The height of the tree,   height(t)  , is  2 . We calculate this recursively as   height(t)=1+(max(height(root.leftChild),height(root.rightChild)))  .    Because this is long and complicated when expanded, we'll break it down using an image of a slightly simpler version of  t  whose height is still  2 :", 
            "title": "Binary Tree"
        }, 
        {
            "location": "/ds_tree/#binary-search-tree", 
            "text": "A Binary Search Tree (BST),  t , is a binary tree that is either empty or satisfies the following three conditions:    Each element in the left subtree of  t  is less than or equal to the root element of  t  (i.e.,   max(leftTree(t).value) \\leq t.valuemax(leftTree(t).value) \\leq t.value  ).    Each element in the right subtree of  t  is greater than the root element of  t  (i.e.,   max(rightTree(t).value) \\ge t.valuemax(rightTree(t).value) \\ge t.value ).    Both   leftTree(t)   and   rightTree(t)   are BSTs.    You can essentially think of it as a regular binary tree where for each node parent having a   leftChild   and   rightChild  ,   leftChild.value \\leq parent.value \\le rightChild.value  . In the first diagram at the top of this article, the binary tree of integers on the left side is a binary search tree.", 
            "title": "Binary Search Tree"
        }, 
        {
            "location": "/ds_tree/#advantages-and-drawbacks", 
            "text": "Searching for elements is very fast.   We know that each node has a maximum of two children and we know that the   \\leq   items are always in the left subtree and the   >   items are always in the right subtree. To search for an element, we simply need to compare the value we want against the value stored in the root node of the current subtree and work our way down the appropriate child subtrees until we either find the value we're looking for or we hit  null  (i.e., an empty subtree) which indicates the item is not in the BST. Inserting or searching for a node in a balanced tree is   O(\\log n)   because you're discarding half of the possible values each time you go left or right.   It can easily become unbalanced.   Depending on the insertion order, the tree can very easily become unbalanced (which makes for longer search times). For example, if we create a new tree where the sequence of inserted nodes is   2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6  , we end up with the following unbalanced tree:    Observe that the root's left subtree only has one node, whereas the root's right subtree has four nodes. For this reason, inserting or searching for a node in an unbalanced tree is   O(n)  .", 
            "title": "Advantages and Drawbacks"
        }, 
        {
            "location": "/ds_tree/#challenges", 
            "text": "\"Trees: Is This a Binary Search Tree?\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/ds_tree/#references", 
            "text": "\"Binary Trees and Binary Search Trees\".  AllisonP, hackerrank . 2016", 
            "title": "References"
        }, 
        {
            "location": "/ds_binary_search_tree/", 
            "text": "Binary Search Tree\n\n\nA Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties\n\n\n\n\nThe left sub-tree of a node has a key less than or equal to its parent node's key.\n\n\nThe right sub-tree of a node has a key greater than to its parent node's key.\n\n\n\n\nThus, BST divides all its sub-trees into two segments; the left sub-tree and the right sub-tree and can be defined as\n\n\nleft_subtree (keys)  \u2264  node (key)  \u2264  right_subtree (keys)\n\n\n\n\nRepresentation\n\n\nBST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.\n\n\nFollowing is a pictorial representation of BST \n\n\n\n\nWe observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.\n\n\nBasic Operations\n\n\nFollowing are the basic operations of a tree\n\n\n\n\nSearch\n \u2212 Searches an element in a tree.\n\n\nInsert\n \u2212 Inserts an element in a tree.\n\n\nPre-order Traversal\n \u2212 Traverses a tree in a pre-order manner.\n\n\nIn-order Traversal\n \u2212 Traverses a tree in an in-order manner.\n\n\nPost-order Traversal\n \u2212 Traverses a tree in a post-order manner.\n\n\n\n\nNode\n\n\nDefine a node having some data, references to its left and right child nodes.\n\n\nstruct node {\n   int data;   \n   struct node *leftChild;\n   struct node *rightChild;\n};\n\n\n\n\nSearch Operation\n\n\nWhenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.\n\n\nAlgorithm\n\n\nstruct node* search(int data){\n   struct node *current = root;\n   printf(\nVisiting elements: \n);\n\n   while(current-\ndata != data){\n\n      if(current != NULL) {\n         printf(\n%d \n,current-\ndata);\n\n         //go to left tree\n         if(current-\ndata \n data){\n            current = current-\nleftChild;\n         }//else go to right tree\n         else {                \n            current = current-\nrightChild;\n         }\n\n         //not found\n         if(current == NULL){\n            return NULL;\n         }\n      }         \n   }\n   return current;\n}\n\n\n\n\nInsert Operation\n\n\nWhenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.\n\n\nAlgorithm\n\n\nvoid insert(int data) {\n   struct node *tempNode = (struct node*) malloc(sizeof(struct node));\n   struct node *current;\n   struct node *parent;\n\n   tempNode-\ndata = data;\n   tempNode-\nleftChild = NULL;\n   tempNode-\nrightChild = NULL;\n\n   //if tree is empty\n   if(root == NULL) {\n      root = tempNode;\n   } else {\n      current = root;\n      parent = NULL;\n\n      while(1) {                \n         parent = current;\n\n         //go to left of the tree\n         if(data \n parent-\ndata) {\n            current = current-\nleftChild;                \n            //insert to the left\n\n            if(current == NULL) {\n               parent-\nleftChild = tempNode;\n               return;\n            }\n         }//go to right of the tree\n         else {\n            current = current-\nrightChild;\n\n            //insert to the right\n            if(current == NULL) {\n               parent-\nrightChild = tempNode;\n               return;\n            }\n         }\n      }            \n   }\n}", 
            "title": "Binary Search Trees"
        }, 
        {
            "location": "/ds_binary_search_tree/#binary-search-tree", 
            "text": "A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties   The left sub-tree of a node has a key less than or equal to its parent node's key.  The right sub-tree of a node has a key greater than to its parent node's key.   Thus, BST divides all its sub-trees into two segments; the left sub-tree and the right sub-tree and can be defined as  left_subtree (keys)  \u2264  node (key)  \u2264  right_subtree (keys)", 
            "title": "Binary Search Tree"
        }, 
        {
            "location": "/ds_binary_search_tree/#representation", 
            "text": "BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.  Following is a pictorial representation of BST    We observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.", 
            "title": "Representation"
        }, 
        {
            "location": "/ds_binary_search_tree/#basic-operations", 
            "text": "Following are the basic operations of a tree   Search  \u2212 Searches an element in a tree.  Insert  \u2212 Inserts an element in a tree.  Pre-order Traversal  \u2212 Traverses a tree in a pre-order manner.  In-order Traversal  \u2212 Traverses a tree in an in-order manner.  Post-order Traversal  \u2212 Traverses a tree in a post-order manner.", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/ds_binary_search_tree/#node", 
            "text": "Define a node having some data, references to its left and right child nodes.  struct node {\n   int data;   \n   struct node *leftChild;\n   struct node *rightChild;\n};", 
            "title": "Node"
        }, 
        {
            "location": "/ds_binary_search_tree/#search-operation", 
            "text": "Whenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.  Algorithm  struct node* search(int data){\n   struct node *current = root;\n   printf( Visiting elements:  );\n\n   while(current- data != data){\n\n      if(current != NULL) {\n         printf( %d  ,current- data);\n\n         //go to left tree\n         if(current- data   data){\n            current = current- leftChild;\n         }//else go to right tree\n         else {                \n            current = current- rightChild;\n         }\n\n         //not found\n         if(current == NULL){\n            return NULL;\n         }\n      }         \n   }\n   return current;\n}", 
            "title": "Search Operation"
        }, 
        {
            "location": "/ds_binary_search_tree/#insert-operation", 
            "text": "Whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.  Algorithm  void insert(int data) {\n   struct node *tempNode = (struct node*) malloc(sizeof(struct node));\n   struct node *current;\n   struct node *parent;\n\n   tempNode- data = data;\n   tempNode- leftChild = NULL;\n   tempNode- rightChild = NULL;\n\n   //if tree is empty\n   if(root == NULL) {\n      root = tempNode;\n   } else {\n      current = root;\n      parent = NULL;\n\n      while(1) {                \n         parent = current;\n\n         //go to left of the tree\n         if(data   parent- data) {\n            current = current- leftChild;                \n            //insert to the left\n\n            if(current == NULL) {\n               parent- leftChild = tempNode;\n               return;\n            }\n         }//go to right of the tree\n         else {\n            current = current- rightChild;\n\n            //insert to the right\n            if(current == NULL) {\n               parent- rightChild = tempNode;\n               return;\n            }\n         }\n      }            \n   }\n}", 
            "title": "Insert Operation"
        }, 
        {
            "location": "/ds_heap/", 
            "text": "Heaps\n\n\nA heap is just what it sounds like \u2014  a pile of values organized into a binary tree-like structure adhering to some ordering property. When we add elements to a heap, we fill this tree-like structure from left to right, level by level. This makes heaps really easy to implement in an array, where the value for some index ii's left child is located at index \n 2i+1 \n and the value for its right child is at index \n 2i+2 \n (using zero-indexing). Here are the two most fundamental heap operations:\n\n\n\n\nadd\n: Insert an element into the heap. You may also see this referred to as push.\n\n\npoll\n: Retrieve and remove the root element of the heap. You may also see this referred to as pop.\n\n\n\n\nMax Heap\n\n\nThis type heap orders the maximum value at the root.\n\n\nWhen we \nadd\n the values \n 1\u21922\u21923\u21924 \n to a Max heap, it looks like this:\n\n\n\n\nWhen we \npoll\n the same Max heap until it's empty, it looks like this:\n\n\n\n\nMin Heap\n\n\nThis type of heap orders the minimum value at the root.\n\n\nWhen we \nadd\n the values \n 1\u21922\u21923\u21924 \n to a Min heap, it looks like this:\n\n\n \n\n\nWhen we \npoll\n the same Min heap until it's empty, it looks like this:\n\n\n \n\n\nApplications\n\n\nThe heap data structure has many applications.\n\n\n\n\nHeapsort\n: One of the best sorting methods being in-place and with no quadratic worst-case scenarios.\n\n\nSelection algorithms\n: A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.\n\n\nGraph algorithms\n: By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are Prim's minimal-spanning-tree algorithm and Dijkstra's shortest-path algorithm.\n\n\nPriority Queue\n: A priority queue is an abstract concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods.\n\n\nOrder statistics\n: The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array.\n\n\n\n\nChallenges\n\n\n\n\n\"Heaps: Find the Running Median\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Heaps\". \nAllisonP, hackerrank\n. 2016\n\n\n\"Heap (data structure)\". \nwikipedia\n. 2016", 
            "title": "Heaps"
        }, 
        {
            "location": "/ds_heap/#heaps", 
            "text": "A heap is just what it sounds like \u2014  a pile of values organized into a binary tree-like structure adhering to some ordering property. When we add elements to a heap, we fill this tree-like structure from left to right, level by level. This makes heaps really easy to implement in an array, where the value for some index ii's left child is located at index   2i+1   and the value for its right child is at index   2i+2   (using zero-indexing). Here are the two most fundamental heap operations:   add : Insert an element into the heap. You may also see this referred to as push.  poll : Retrieve and remove the root element of the heap. You may also see this referred to as pop.", 
            "title": "Heaps"
        }, 
        {
            "location": "/ds_heap/#max-heap", 
            "text": "This type heap orders the maximum value at the root.  When we  add  the values   1\u21922\u21923\u21924   to a Max heap, it looks like this:   When we  poll  the same Max heap until it's empty, it looks like this:", 
            "title": "Max Heap"
        }, 
        {
            "location": "/ds_heap/#min-heap", 
            "text": "This type of heap orders the minimum value at the root.  When we  add  the values   1\u21922\u21923\u21924   to a Min heap, it looks like this:     When we  poll  the same Min heap until it's empty, it looks like this:", 
            "title": "Min Heap"
        }, 
        {
            "location": "/ds_heap/#applications", 
            "text": "The heap data structure has many applications.   Heapsort : One of the best sorting methods being in-place and with no quadratic worst-case scenarios.  Selection algorithms : A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.  Graph algorithms : By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are Prim's minimal-spanning-tree algorithm and Dijkstra's shortest-path algorithm.  Priority Queue : A priority queue is an abstract concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods.  Order statistics : The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array.", 
            "title": "Applications"
        }, 
        {
            "location": "/ds_heap/#challenges", 
            "text": "\"Heaps: Find the Running Median\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/ds_heap/#references", 
            "text": "\"Heaps\".  AllisonP, hackerrank . 2016  \"Heap (data structure)\".  wikipedia . 2016", 
            "title": "References"
        }, 
        {
            "location": "/sort_algorithms/", 
            "text": "Sorting Algorithms\n\n\nSorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.\n\n\nThe importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats. Following are some of the examples of sorting in real-life scenarios \u2212\n\n\n\n\nTelephone Directory\n \u2212 The telephone directory stores the telephone numbers of people sorted by their names, so that the names can be searched easily.\n\n\nDictionary\n \u2212 The dictionary stores words in an alphabetical order so that searching of any word becomes easy.\n\n\n\n\nIn-place Sorting and Not-in-place Sorting\n\n\nSorting algorithms may require some extra space for comparison and temporary storage of few data elements. These algorithms do not require any extra space and sorting is said to happen in-place, or for example, within the array itself. This is called in-place sorting. Bubble sort is an example of \nin-place sorting\n.\n\n\nHowever, in some sorting algorithms, the program requires space which is more than or equal to the elements being sorted. Sorting which uses equal or more space is called \nnot-in-place sorting\n. Merge-sort is an example of not-in-place sorting.\n\n\nStable and Not Stable Sorting\n\n\nIf a sorting algorithm, after sorting the contents, does not change the sequence of similar content in which they appear, it is called \nstable sorting\n.\n\n\n\n\nIf a sorting algorithm, after sorting the contents, changes the sequence of similar content in which they appear, it is called \nunstable sorting\n.\n\n\n\n\nStability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.\n\n\nAdaptive and Non-Adaptive Sorting Algorithm\n\n\nA sorting algorithm is said to be adaptive, if it takes advantage of already 'sorted' elements in the list that is to be sorted. That is, while sorting if the source list has some element already sorted, adaptive algorithms will take this into account and will try not to re-order them.\n\n\nA non-adaptive algorithm is one which does not take into account the elements which are already sorted. They try to force every single element to be re-ordered to confirm their sortedness.\n\n\nImportant Terms\n\n\nSome terms are generally coined while discussing sorting techniques, here is a brief introduction to them\n\n\nIncreasing Order\n\n\nA sequence of values is said to be in increasing order, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.\n\n\nDecreasing Order\n\n\nA sequence of values is said to be in decreasing order, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.\n\n\nNon-Increasing Order\n\n\nA sequence of values is said to be in non-increasing order, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.\n\n\nNon-Decreasing Order\n\n\nA sequence of values is said to be in non-decreasing order, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.", 
            "title": "Sorting Algorithms"
        }, 
        {
            "location": "/sort_algorithms/#sorting-algorithms", 
            "text": "Sorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.  The importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats. Following are some of the examples of sorting in real-life scenarios \u2212   Telephone Directory  \u2212 The telephone directory stores the telephone numbers of people sorted by their names, so that the names can be searched easily.  Dictionary  \u2212 The dictionary stores words in an alphabetical order so that searching of any word becomes easy.", 
            "title": "Sorting Algorithms"
        }, 
        {
            "location": "/sort_algorithms/#in-place-sorting-and-not-in-place-sorting", 
            "text": "Sorting algorithms may require some extra space for comparison and temporary storage of few data elements. These algorithms do not require any extra space and sorting is said to happen in-place, or for example, within the array itself. This is called in-place sorting. Bubble sort is an example of  in-place sorting .  However, in some sorting algorithms, the program requires space which is more than or equal to the elements being sorted. Sorting which uses equal or more space is called  not-in-place sorting . Merge-sort is an example of not-in-place sorting.", 
            "title": "In-place Sorting and Not-in-place Sorting"
        }, 
        {
            "location": "/sort_algorithms/#stable-and-not-stable-sorting", 
            "text": "If a sorting algorithm, after sorting the contents, does not change the sequence of similar content in which they appear, it is called  stable sorting .   If a sorting algorithm, after sorting the contents, changes the sequence of similar content in which they appear, it is called  unstable sorting .   Stability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.", 
            "title": "Stable and Not Stable Sorting"
        }, 
        {
            "location": "/sort_algorithms/#adaptive-and-non-adaptive-sorting-algorithm", 
            "text": "A sorting algorithm is said to be adaptive, if it takes advantage of already 'sorted' elements in the list that is to be sorted. That is, while sorting if the source list has some element already sorted, adaptive algorithms will take this into account and will try not to re-order them.  A non-adaptive algorithm is one which does not take into account the elements which are already sorted. They try to force every single element to be re-ordered to confirm their sortedness.", 
            "title": "Adaptive and Non-Adaptive Sorting Algorithm"
        }, 
        {
            "location": "/sort_algorithms/#important-terms", 
            "text": "Some terms are generally coined while discussing sorting techniques, here is a brief introduction to them  Increasing Order  A sequence of values is said to be in increasing order, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.  Decreasing Order  A sequence of values is said to be in decreasing order, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.  Non-Increasing Order  A sequence of values is said to be in non-increasing order, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.  Non-Decreasing Order  A sequence of values is said to be in non-decreasing order, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.", 
            "title": "Important Terms"
        }, 
        {
            "location": "/sort_bubble/", 
            "text": "Bubble Sort\n\n\nBubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of \n\u039f(n^2)\n where n is the number of items.\n\n\nHow Bubble Sort Works?\n\n\nWe take an unsorted array for our example. Bubble sort takes \n\u039f(n^2)\n time so we're keeping it short and precise.\n\n\n\n\nBubble sort starts with very first two elements, comparing them to check which one is greater.\n\n\n\n\nIn this case, value 33 is greater than 14, so it is already in sorted locations. Next, we compare 33 with 27.\n\n\n\n\nWe find that 27 is smaller than 33 and these two values must be swapped.\n\n\n\n\nThe new array should look like this\n\n\n\n\nNext we compare 33 and 35. We find that both are in already sorted positions.\n\n\n\n\nThen we move to the next two values, 35 and 10.\n\n\n\n\nWe know then that 10 is smaller 35. Hence they are not sorted.\n\n\n\n\nWe swap these values. We find that we have reached the end of the array. After one iteration, the array should look like this\n\n\n\n\nTo be precise, we are now showing how an array should look like after each iteration. After the second iteration, it should look like this\n\n\n\n\nNotice that after each iteration, at least one value moves at the end.\n\n\n\n\nAnd when there's no swap required, bubble sorts learns that an array is completely sorted.\n\n\n\n\nNow we should look into some practical aspects of bubble sort.\n\n\nAlgorithm\n\n\nWe assume list is an array of n elements. We further assume that swap function swaps the values of the given array elements.\n\n\nbegin BubbleSort(list)\n\n   for all elements of list\n      if list[i] \n list[i+1]\n         swap(list[i], list[i+1])\n      end if\n   end for\n\n   return list\n\nend BubbleSort\n\n\n\n\nPseudocode\n\n\nWe observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.\n\n\nTo ease-out the issue, we use one flag variable swapped which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.\n\n\nPseudocode of BubbleSort algorithm can be written as follows\n\n\nprocedure bubbleSort( list : array of items )\n\n   loop = list.count;\n\n   for i = 0 to loop-1 do:\n      swapped = false\n\n      for j = 0 to loop-1 do:\n\n         /* compare the adjacent elements */   \n         if list[j] \n list[j+1] then\n            /* swap them */\n            swap( list[j], list[j+1] )       \n            swapped = true\n         end if\n\n      end for\n\n      /*if no number was swapped that means \n      array is sorted now, break the loop.*/\n\n      if(not swapped) then\n         break\n      end if\n\n   end for\n\nend procedure return list\n\n\n\n\nImplementation\n\n\nOne more issue we did not address in our original algorithm and its improvised pseudocode, is that, after every iteration the highest values settles down at the end of the array. Hence, the next iteration need not include already sorted elements. For this purpose, in our implementation, we restrict the inner loop to avoid already sorted values.", 
            "title": "Bubble Sort"
        }, 
        {
            "location": "/sort_bubble/#bubble-sort", 
            "text": "Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of  \u039f(n^2)  where n is the number of items.", 
            "title": "Bubble Sort"
        }, 
        {
            "location": "/sort_bubble/#how-bubble-sort-works", 
            "text": "We take an unsorted array for our example. Bubble sort takes  \u039f(n^2)  time so we're keeping it short and precise.   Bubble sort starts with very first two elements, comparing them to check which one is greater.   In this case, value 33 is greater than 14, so it is already in sorted locations. Next, we compare 33 with 27.   We find that 27 is smaller than 33 and these two values must be swapped.   The new array should look like this   Next we compare 33 and 35. We find that both are in already sorted positions.   Then we move to the next two values, 35 and 10.   We know then that 10 is smaller 35. Hence they are not sorted.   We swap these values. We find that we have reached the end of the array. After one iteration, the array should look like this   To be precise, we are now showing how an array should look like after each iteration. After the second iteration, it should look like this   Notice that after each iteration, at least one value moves at the end.   And when there's no swap required, bubble sorts learns that an array is completely sorted.   Now we should look into some practical aspects of bubble sort.", 
            "title": "How Bubble Sort Works?"
        }, 
        {
            "location": "/sort_bubble/#algorithm", 
            "text": "We assume list is an array of n elements. We further assume that swap function swaps the values of the given array elements.  begin BubbleSort(list)\n\n   for all elements of list\n      if list[i]   list[i+1]\n         swap(list[i], list[i+1])\n      end if\n   end for\n\n   return list\n\nend BubbleSort", 
            "title": "Algorithm"
        }, 
        {
            "location": "/sort_bubble/#pseudocode", 
            "text": "We observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.  To ease-out the issue, we use one flag variable swapped which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.  Pseudocode of BubbleSort algorithm can be written as follows  procedure bubbleSort( list : array of items )\n\n   loop = list.count;\n\n   for i = 0 to loop-1 do:\n      swapped = false\n\n      for j = 0 to loop-1 do:\n\n         /* compare the adjacent elements */   \n         if list[j]   list[j+1] then\n            /* swap them */\n            swap( list[j], list[j+1] )       \n            swapped = true\n         end if\n\n      end for\n\n      /*if no number was swapped that means \n      array is sorted now, break the loop.*/\n\n      if(not swapped) then\n         break\n      end if\n\n   end for\n\nend procedure return list", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/sort_bubble/#implementation", 
            "text": "One more issue we did not address in our original algorithm and its improvised pseudocode, is that, after every iteration the highest values settles down at the end of the array. Hence, the next iteration need not include already sorted elements. For this purpose, in our implementation, we restrict the inner loop to avoid already sorted values.", 
            "title": "Implementation"
        }, 
        {
            "location": "/sort_insertion/", 
            "text": "Insertion Sort\n\n\nThis is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, \ninsertion sort\n.\n\n\nThe array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of \u039f(n2), where n is the number of items.\n\n\nHow Insertion Sort Works?\n\n\nWe take an unsorted array for our example.\n\n\n\n\nInsertion sort compares the first two elements.\n\n\n\n\nIt finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.\n\n\n\n\nInsertion sort moves ahead and compares 33 with 27.\n\n\n\n\nAnd finds that 33 is not in the correct position.\n\n\n\n\nIt swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.\n\n\n\n\nBy now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.\n\n\n\n\nThese values are not in a sorted order.\n\n\n\n\nSo we swap them.\n\n\n\n\nHowever, swapping makes 27 and 10 unsorted.\n\n\n\n\nHence, we swap them too.\n\n\n\n\nAgain we find 14 and 10 in an unsorted order.\n\n\n\n\nWe swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.\n\n\n\n\nThis process goes on until all the unsorted values are covered in a sorted sub-list. Now we shall see some programming aspects of insertion sort.\n\n\nAlgorithm\n\n\nNow we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.\n\n\nStep 1 \u2212 If it is the first element, it is already sorted. return 1;\nStep 2 \u2212 Pick next element\nStep 3 \u2212 Compare with all elements in the sorted sub-list\nStep 4 \u2212 Shift all the elements in the sorted sub-list that is greater than the \n         value to be sorted\nStep 5 \u2212 Insert the value\nStep 6 \u2212 Repeat until list is sorted\n\n\n\n\nPseudocode\n\n\nprocedure insertionSort( A : array of items )\n   int holePosition\n   int valueToInsert\n\n   for i = 1 to length(A) inclusive do:\n\n      /* select value to be inserted */\n      valueToInsert = A[i]\n      holePosition = i\n\n      /*locate hole position for the element to be inserted */\n\n      while holePosition \n 0 and A[holePosition-1] \n valueToInsert do:\n         A[holePosition] = A[holePosition-1]\n         holePosition = holePosition -1\n      end while\n\n      /* insert the number at hole position */\n      A[holePosition] = valueToInsert\n\n   end for\n\nend procedure", 
            "title": "Insertion Sort"
        }, 
        {
            "location": "/sort_insertion/#insertion-sort", 
            "text": "This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name,  insertion sort .  The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of \u039f(n2), where n is the number of items.", 
            "title": "Insertion Sort"
        }, 
        {
            "location": "/sort_insertion/#how-insertion-sort-works", 
            "text": "We take an unsorted array for our example.   Insertion sort compares the first two elements.   It finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.   Insertion sort moves ahead and compares 33 with 27.   And finds that 33 is not in the correct position.   It swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.   By now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.   These values are not in a sorted order.   So we swap them.   However, swapping makes 27 and 10 unsorted.   Hence, we swap them too.   Again we find 14 and 10 in an unsorted order.   We swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.   This process goes on until all the unsorted values are covered in a sorted sub-list. Now we shall see some programming aspects of insertion sort.", 
            "title": "How Insertion Sort Works?"
        }, 
        {
            "location": "/sort_insertion/#algorithm", 
            "text": "Now we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.  Step 1 \u2212 If it is the first element, it is already sorted. return 1;\nStep 2 \u2212 Pick next element\nStep 3 \u2212 Compare with all elements in the sorted sub-list\nStep 4 \u2212 Shift all the elements in the sorted sub-list that is greater than the \n         value to be sorted\nStep 5 \u2212 Insert the value\nStep 6 \u2212 Repeat until list is sorted", 
            "title": "Algorithm"
        }, 
        {
            "location": "/sort_insertion/#pseudocode", 
            "text": "procedure insertionSort( A : array of items )\n   int holePosition\n   int valueToInsert\n\n   for i = 1 to length(A) inclusive do:\n\n      /* select value to be inserted */\n      valueToInsert = A[i]\n      holePosition = i\n\n      /*locate hole position for the element to be inserted */\n\n      while holePosition   0 and A[holePosition-1]   valueToInsert do:\n         A[holePosition] = A[holePosition-1]\n         holePosition = holePosition -1\n      end while\n\n      /* insert the number at hole position */\n      A[holePosition] = valueToInsert\n\n   end for\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/sort_selection/", 
            "text": "Selection Sort\n\n\nSelection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.\n\n\nThe smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.\n\n\nThis algorithm is not suitable for large data sets as its average and worst case complexities are of \n\u039f(n^2)\n, where \nn\n is the number of items.\n\n\nHow Selection Sort Works?\n\n\nConsider the following depicted array as an example.\n\n\n\n\nFor the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.\n\n\n\n\nSo we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.\n\n\n\n\nFor the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.\n\n\n\n\nWe find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.\n\n\n\n\nAfter two iterations, two least values are positioned at the beginning in a sorted manner.\n\n\n\n\nThe same process is applied to the rest of the items in the array.\n\n\nFollowing is a pictorial depiction of the entire sorting process\n\n\n\n\nNow, let us learn some programming aspects of selection sort.\n\n\nAlgorithm\n\n\nStep 1 \u2212 Set MIN to location 0\nStep 2 \u2212 Search the minimum element in the list\nStep 3 \u2212 Swap with value at location MIN\nStep 4 \u2212 Increment MIN to point to next element\nStep 5 \u2212 Repeat until list is sorted\n\n\n\n\nPseudocode\n\n\nprocedure selection sort \n   list  : array of items\n   n     : size of list\n\n   for i = 1 to n - 1\n   /* set current element as minimum*/\n      min = i    \n\n      /* check the element to be minimum */\n\n      for j = i+1 to n \n         if list[j] \n list[min] then\n            min = j;\n         end if\n      end for\n\n      /* swap the minimum element with the current element*/\n      if indexMin != i  then\n         swap list[min] and list[i]\n      end if\n\n   end for\n\nend procedure", 
            "title": "Selection Sort"
        }, 
        {
            "location": "/sort_selection/#selection-sort", 
            "text": "Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.  The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.  This algorithm is not suitable for large data sets as its average and worst case complexities are of  \u039f(n^2) , where  n  is the number of items.", 
            "title": "Selection Sort"
        }, 
        {
            "location": "/sort_selection/#how-selection-sort-works", 
            "text": "Consider the following depicted array as an example.   For the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.   So we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.   For the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.   We find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.   After two iterations, two least values are positioned at the beginning in a sorted manner.   The same process is applied to the rest of the items in the array.  Following is a pictorial depiction of the entire sorting process   Now, let us learn some programming aspects of selection sort.", 
            "title": "How Selection Sort Works?"
        }, 
        {
            "location": "/sort_selection/#algorithm", 
            "text": "Step 1 \u2212 Set MIN to location 0\nStep 2 \u2212 Search the minimum element in the list\nStep 3 \u2212 Swap with value at location MIN\nStep 4 \u2212 Increment MIN to point to next element\nStep 5 \u2212 Repeat until list is sorted", 
            "title": "Algorithm"
        }, 
        {
            "location": "/sort_selection/#pseudocode", 
            "text": "procedure selection sort \n   list  : array of items\n   n     : size of list\n\n   for i = 1 to n - 1\n   /* set current element as minimum*/\n      min = i    \n\n      /* check the element to be minimum */\n\n      for j = i+1 to n \n         if list[j]   list[min] then\n            min = j;\n         end if\n      end for\n\n      /* swap the minimum element with the current element*/\n      if indexMin != i  then\n         swap list[min] and list[i]\n      end if\n\n   end for\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/sort_merge/", 
            "text": "Merge Sort\n\n\nMerge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being \n\u039f(n log n)\n, it is one of the most respected algorithms.\n\n\nMerge sort first divides the array into equal halves and then combines them in a sorted manner.\n\n\nHow Merge Sort Works?\n\n\nTo understand merge sort, we take an unsorted array as the following \u2212\n\n\n\n\nWe know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.\n\n\n\n\nThis does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.\n\n\n\n\nWe further divide these arrays and we achieve atomic value which can no more be divided.\n\n\n\n\nNow, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.\n\n\nWe first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.\n\n\n\n\nIn the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.\n\n\n\n\nAfter the final merging, the list should look like this \u2212\n\n\n\n\nNow we should learn some programming aspects of merge sorting.\n\n\nAlgorithm\n\n\nMerge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.\n\n\nStep 1 \u2212 if it is only one element in the list it is already sorted, return.\nStep 2 \u2212 divide the list recursively into two halves until it can no more be divided.\nStep 3 \u2212 merge the smaller lists into new list in sorted order.\n\n\n\n\nPseudocode\n\n\nWe shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions \u2212 divide \n merge.\n\n\nMerge sort works with recursion and we shall see our implementation in the same way.\n\n\nprocedure mergesort( var a as array )\n   if ( n == 1 ) return a\n\n   var l1 as array = a[0] ... a[n/2]\n   var l2 as array = a[n/2+1] ... a[n]\n\n   l1 = mergesort( l1 )\n   l2 = mergesort( l2 )\n\n   return merge( l1, l2 )\nend procedure\n\nprocedure merge( var a as array, var b as array )\n\n   var c as array\n\n   while ( a and b have elements )\n      if ( a[0] \n b[0] )\n         add b[0] to the end of c\n         remove b[0] from b\n      else\n         add a[0] to the end of c\n         remove a[0] from a\n      end if\n   end while\n\n   while ( a has elements )\n      add a[0] to the end of c\n      remove a[0] from a\n   end while\n\n   while ( b has elements )\n      add b[0] to the end of c\n      remove b[0] from b\n   end while\n\n   return c\n\nend procedure", 
            "title": "Merge Sort"
        }, 
        {
            "location": "/sort_merge/#merge-sort", 
            "text": "Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being  \u039f(n log n) , it is one of the most respected algorithms.  Merge sort first divides the array into equal halves and then combines them in a sorted manner.", 
            "title": "Merge Sort"
        }, 
        {
            "location": "/sort_merge/#how-merge-sort-works", 
            "text": "To understand merge sort, we take an unsorted array as the following \u2212   We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.   This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.   We further divide these arrays and we achieve atomic value which can no more be divided.   Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.  We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.   In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.   After the final merging, the list should look like this \u2212   Now we should learn some programming aspects of merge sorting.", 
            "title": "How Merge Sort Works?"
        }, 
        {
            "location": "/sort_merge/#algorithm", 
            "text": "Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.  Step 1 \u2212 if it is only one element in the list it is already sorted, return.\nStep 2 \u2212 divide the list recursively into two halves until it can no more be divided.\nStep 3 \u2212 merge the smaller lists into new list in sorted order.", 
            "title": "Algorithm"
        }, 
        {
            "location": "/sort_merge/#pseudocode", 
            "text": "We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions \u2212 divide   merge.  Merge sort works with recursion and we shall see our implementation in the same way.  procedure mergesort( var a as array )\n   if ( n == 1 ) return a\n\n   var l1 as array = a[0] ... a[n/2]\n   var l2 as array = a[n/2+1] ... a[n]\n\n   l1 = mergesort( l1 )\n   l2 = mergesort( l2 )\n\n   return merge( l1, l2 )\nend procedure\n\nprocedure merge( var a as array, var b as array )\n\n   var c as array\n\n   while ( a and b have elements )\n      if ( a[0]   b[0] )\n         add b[0] to the end of c\n         remove b[0] from b\n      else\n         add a[0] to the end of c\n         remove a[0] from a\n      end if\n   end while\n\n   while ( a has elements )\n      add a[0] to the end of c\n      remove a[0] from a\n   end while\n\n   while ( b has elements )\n      add b[0] to the end of c\n      remove b[0] from b\n   end while\n\n   return c\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/sort_shell/", 
            "text": "Shell Sort\n\n\nShell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.\n\n\nThis algorithm uses insertion sort on a widely spread elements, first to sort them and then sorts the less widely spaced elements. This spacing is termed as \ninterval\n. This interval is calculated based on Knuth's formula as \u2212\n\n\nKnuth's Formula\n\n\n\n\nh = h * 3 + 1\n\n\n\n\nwhere\n\n\n\n\n\n\nh\n is interval with initial value 1\n\n\n\n\nThis algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of \n\u039f(n)\n, where \nn\n is the number of items.\n\n\nHow Shell Sort Works?\n\n\nLet us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}\n\n\n\n\nWe compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this \u2212\n\n\n\n\nThen, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}\n\n\n\n\nWe compare and swap the values, if required, in the original array. After this step, the array should look like this \u2212\n\n\n\n\nFinally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.\n\n\nFollowing is the step-by-step depiction \u2212\n\n\n\n\nWe see that it required only four swaps to sort the rest of the array.\n\n\nAlgorithm\n\n\nFollowing is the algorithm for shell sort.\n\n\nStep 1 \u2212 Initialize the value of h\nStep 2 \u2212 Divide the list into smaller sub-list of equal interval h\nStep 3 \u2212 Sort these sub-lists using insertion sort\nStep 3 \u2212 Repeat until complete list is sorted\n\n\n\n\nPseudocode\n\n\nFollowing is the pseudocode for shell sort.\n\n\nprocedure shellSort()\n   A : array of items \n\n   /* calculate interval*/\n   while interval \n A.length /3 do:\n      interval = interval * 3 + 1       \n   end while\n\n   while interval \n 0 do:\n\n      for outer = interval; outer \n A.length; outer ++ do:\n\n      /* select value to be inserted */\n      valueToInsert = A[outer]\n      inner = outer;\n\n         /*shift element towards right*/\n         while inner \n interval -1 \n A[inner - interval] \n= valueToInsert do:\n            A[inner] = A[inner - interval]\n            inner = inner - interval\n         end while\n\n      /* insert the number at hole position */\n      A[inner] = valueToInsert\n\n      end for\n\n   /* calculate interval*/\n   interval = (interval -1) /3;   \n\n   end while\n\nend procedure", 
            "title": "Shell Sort"
        }, 
        {
            "location": "/sort_shell/#shell-sort", 
            "text": "Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.  This algorithm uses insertion sort on a widely spread elements, first to sort them and then sorts the less widely spaced elements. This spacing is termed as  interval . This interval is calculated based on Knuth's formula as \u2212", 
            "title": "Shell Sort"
        }, 
        {
            "location": "/sort_shell/#knuths-formula", 
            "text": "h = h * 3 + 1   where    h  is interval with initial value 1   This algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of  \u039f(n) , where  n  is the number of items.", 
            "title": "Knuth's Formula"
        }, 
        {
            "location": "/sort_shell/#how-shell-sort-works", 
            "text": "Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}   We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this \u2212   Then, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}   We compare and swap the values, if required, in the original array. After this step, the array should look like this \u2212   Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.  Following is the step-by-step depiction \u2212   We see that it required only four swaps to sort the rest of the array.", 
            "title": "How Shell Sort Works?"
        }, 
        {
            "location": "/sort_shell/#algorithm", 
            "text": "Following is the algorithm for shell sort.  Step 1 \u2212 Initialize the value of h\nStep 2 \u2212 Divide the list into smaller sub-list of equal interval h\nStep 3 \u2212 Sort these sub-lists using insertion sort\nStep 3 \u2212 Repeat until complete list is sorted", 
            "title": "Algorithm"
        }, 
        {
            "location": "/sort_shell/#pseudocode", 
            "text": "Following is the pseudocode for shell sort.  procedure shellSort()\n   A : array of items \n\n   /* calculate interval*/\n   while interval   A.length /3 do:\n      interval = interval * 3 + 1       \n   end while\n\n   while interval   0 do:\n\n      for outer = interval; outer   A.length; outer ++ do:\n\n      /* select value to be inserted */\n      valueToInsert = A[outer]\n      inner = outer;\n\n         /*shift element towards right*/\n         while inner   interval -1   A[inner - interval]  = valueToInsert do:\n            A[inner] = A[inner - interval]\n            inner = inner - interval\n         end while\n\n      /* insert the number at hole position */\n      A[inner] = valueToInsert\n\n      end for\n\n   /* calculate interval*/\n   interval = (interval -1) /3;   \n\n   end while\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/sort_quick/", 
            "text": "Quick Sort\n\n\nQuick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.\n\n\nQuick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of \u039f(n2), where n is the number of items.\n\n\nPartition in Quick Sort\n\n\nFollowing animated representation explains how to find the pivot value in an array.\n\n\n\n\nThe pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.\n\n\nQuick Sort Pivot Algorithm\n\n\nBased on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.\n\n\nStep 1 \u2212 Choose the highest index value has pivot\nStep 2 \u2212 Take two variables to point left and right of the list excluding pivot\nStep 3 \u2212 left points to the low index\nStep 4 \u2212 right points to the high\nStep 5 \u2212 while value at left is less than pivot move right\nStep 6 \u2212 while value at right is greater than pivot move left\nStep 7 \u2212 if both step 5 and step 6 does not match swap left and right\nStep 8 \u2212 if left \u2265 right, the point where they met is new pivot\n\n\n\n\nQuick Sort Pivot Pseudocode\n\n\nThe pseudocode for the above algorithm can be derived as \u2212\n\n\nfunction partitionFunc(left, right, pivot)\n   leftPointer = left\n   rightPointer = right - 1\n\n   while True do\n      while A[++leftPointer] \n pivot do\n         //do-nothing            \n      end while\n\n      while rightPointer \n 0 \n A[--rightPointer] \n pivot do\n         //do-nothing         \n      end while\n\n      if leftPointer \n= rightPointer\n         break\n      else                \n         swap leftPointer,rightPointer\n      end if\n\n   end while \n\n   swap leftPointer,right\n   return leftPointer\n\nend function\n\n\n\n\nQuick Sort Algorithm\n\n\nUsing pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows\n\n\nStep 1 \u2212 Make the right-most index value pivot\nStep 2 \u2212 partition the array using pivot value\nStep 3 \u2212 quicksort left partition recursively\nStep 4 \u2212 quicksort right partition recursively\n\n\n\n\nQuick Sort Pseudocode\n\n\nTo get more into it, let see the pseudocode for quick sort algorithm\n\n\nprocedure quickSort(left, right)\n\n   if right-left \n= 0\n      return\n   else     \n      pivot = A[right]\n      partition = partitionFunc(left, right, pivot)\n      quickSort(left,partition-1)\n      quickSort(partition+1,right)    \n   end if       \n\nend procedure", 
            "title": "Quick Sort"
        }, 
        {
            "location": "/sort_quick/#quick-sort", 
            "text": "Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.  Quick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of \u039f(n2), where n is the number of items.", 
            "title": "Quick Sort"
        }, 
        {
            "location": "/sort_quick/#partition-in-quick-sort", 
            "text": "Following animated representation explains how to find the pivot value in an array.   The pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.", 
            "title": "Partition in Quick Sort"
        }, 
        {
            "location": "/sort_quick/#quick-sort-pivot-algorithm", 
            "text": "Based on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.  Step 1 \u2212 Choose the highest index value has pivot\nStep 2 \u2212 Take two variables to point left and right of the list excluding pivot\nStep 3 \u2212 left points to the low index\nStep 4 \u2212 right points to the high\nStep 5 \u2212 while value at left is less than pivot move right\nStep 6 \u2212 while value at right is greater than pivot move left\nStep 7 \u2212 if both step 5 and step 6 does not match swap left and right\nStep 8 \u2212 if left \u2265 right, the point where they met is new pivot", 
            "title": "Quick Sort Pivot Algorithm"
        }, 
        {
            "location": "/sort_quick/#quick-sort-pivot-pseudocode", 
            "text": "The pseudocode for the above algorithm can be derived as \u2212  function partitionFunc(left, right, pivot)\n   leftPointer = left\n   rightPointer = right - 1\n\n   while True do\n      while A[++leftPointer]   pivot do\n         //do-nothing            \n      end while\n\n      while rightPointer   0   A[--rightPointer]   pivot do\n         //do-nothing         \n      end while\n\n      if leftPointer  = rightPointer\n         break\n      else                \n         swap leftPointer,rightPointer\n      end if\n\n   end while \n\n   swap leftPointer,right\n   return leftPointer\n\nend function", 
            "title": "Quick Sort Pivot Pseudocode"
        }, 
        {
            "location": "/sort_quick/#quick-sort-algorithm", 
            "text": "Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows  Step 1 \u2212 Make the right-most index value pivot\nStep 2 \u2212 partition the array using pivot value\nStep 3 \u2212 quicksort left partition recursively\nStep 4 \u2212 quicksort right partition recursively", 
            "title": "Quick Sort Algorithm"
        }, 
        {
            "location": "/sort_quick/#quick-sort-pseudocode", 
            "text": "To get more into it, let see the pseudocode for quick sort algorithm  procedure quickSort(left, right)\n\n   if right-left  = 0\n      return\n   else     \n      pivot = A[right]\n      partition = partitionFunc(left, right, pivot)\n      quickSort(left,partition-1)\n      quickSort(partition+1,right)    \n   end if       \n\nend procedure", 
            "title": "Quick Sort Pseudocode"
        }, 
        {
            "location": "/search_linear/", 
            "text": "Linear Search\n\n\nLinear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.\n\n\n\n\nAlgorithm\n\n\nLinear Search ( Array A, Value x)\n\nStep 1: Set i to 1\nStep 2: if i \n n then go to step 7\nStep 3: if A[i] = x then go to step 6\nStep 4: Set i to i + 1\nStep 5: Go to Step 2\nStep 6: Print Element x Found at index i and go to step 8\nStep 7: Print element not found\nStep 8: Exit\n\n\n\n\nPseudocode\n\n\nprocedure linear_search (list, value)\n\n   for each item in the list\n\n      if match item == value\n\n         return the item's location\n\n      end if\n\n   end for\n\nend procedure", 
            "title": "Linear Search"
        }, 
        {
            "location": "/search_linear/#linear-search", 
            "text": "Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.", 
            "title": "Linear Search"
        }, 
        {
            "location": "/search_linear/#algorithm", 
            "text": "Linear Search ( Array A, Value x)\n\nStep 1: Set i to 1\nStep 2: if i   n then go to step 7\nStep 3: if A[i] = x then go to step 6\nStep 4: Set i to i + 1\nStep 5: Go to Step 2\nStep 6: Print Element x Found at index i and go to step 8\nStep 7: Print element not found\nStep 8: Exit", 
            "title": "Algorithm"
        }, 
        {
            "location": "/search_linear/#pseudocode", 
            "text": "procedure linear_search (list, value)\n\n   for each item in the list\n\n      if match item == value\n\n         return the item's location\n\n      end if\n\n   end for\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/search_binary/", 
            "text": "Binary Search\n\n\nBinary search is a fast search algorithm with run-time complexity of \u039f(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.\n\n\nBinary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.\n\n\nHow Binary Search Works?\n\n\nFor a binary search to work, it is mandatory for the target array to be sorted. We shall learn the process of binary search with a pictorial example. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.\n\n\n\n\nFirst, we shall determine half of the array by using this formula \u2212\n\n\nmid = low + (high - low) / 2\n\n\n\n\nHere it is, 0 + (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.\n\n\n\n\nNow we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.\n\n\n\n\nWe change our low to mid + 1 and find the new mid value again.\n\n\nlow = mid + 1\nmid = low + (high - low) / 2\n\n\n\n\nOur new mid is 7 now. We compare the value stored at location 7 with our target value 31.\n\n\n\n\nThe value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.\n\n\n\n\nHence, we calculate the mid again. This time it is 5.\n\n\n\n\nWe compare the value stored at location 5 with our target value. We find that it is a match.\n\n\n\n\nWe conclude that the target value 31 is stored at location 5.\n\n\nBinary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.\n\n\nPseudocode\n\n\nThe pseudocode of binary search algorithms should look like this \u2212\n\n\nProcedure binary_search\n   A \u2190 sorted array\n   n \u2190 size of array\n   x \u2190 value to be searched\n\n   Set lowerBound = 1\n   Set upperBound = n \n\n   while x not found\n      if upperBound \n lowerBound \n         EXIT: x does not exists.\n\n      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2\n\n      if A[midPoint] \n x\n         set lowerBound = midPoint + 1\n\n      if A[midPoint] \n x\n         set upperBound = midPoint - 1 \n\n      if A[midPoint] = x \n         EXIT: x found at location midPoint\n\n   end while\n\nend procedure", 
            "title": "Binary Search"
        }, 
        {
            "location": "/search_binary/#binary-search", 
            "text": "Binary search is a fast search algorithm with run-time complexity of \u039f(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.  Binary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.", 
            "title": "Binary Search"
        }, 
        {
            "location": "/search_binary/#how-binary-search-works", 
            "text": "For a binary search to work, it is mandatory for the target array to be sorted. We shall learn the process of binary search with a pictorial example. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.   First, we shall determine half of the array by using this formula \u2212  mid = low + (high - low) / 2  Here it is, 0 + (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.   Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.   We change our low to mid + 1 and find the new mid value again.  low = mid + 1\nmid = low + (high - low) / 2  Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.   The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.   Hence, we calculate the mid again. This time it is 5.   We compare the value stored at location 5 with our target value. We find that it is a match.   We conclude that the target value 31 is stored at location 5.  Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.", 
            "title": "How Binary Search Works?"
        }, 
        {
            "location": "/search_binary/#pseudocode", 
            "text": "The pseudocode of binary search algorithms should look like this \u2212  Procedure binary_search\n   A \u2190 sorted array\n   n \u2190 size of array\n   x \u2190 value to be searched\n\n   Set lowerBound = 1\n   Set upperBound = n \n\n   while x not found\n      if upperBound   lowerBound \n         EXIT: x does not exists.\n\n      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2\n\n      if A[midPoint]   x\n         set lowerBound = midPoint + 1\n\n      if A[midPoint]   x\n         set upperBound = midPoint - 1 \n\n      if A[midPoint] = x \n         EXIT: x found at location midPoint\n\n   end while\n\nend procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/search_interpolation/", 
            "text": "Interpolation Search\n\n\nInterpolation search is an improved variant of binary search. This search algorithm works on the probing position of the required value. For this algorithm to work properly, the data collection should be in a sorted form and equally distributed.\n\n\nBinary search has a huge advantage of time complexity over linear search. Linear search has worst-case complexity of \u039f(n) whereas binary search has \u039f(log n).\n\n\nThere are cases where the location of target data may be known in advance. For example, in case of a telephone directory, if we want to search the telephone number of Morphius. Here, linear search and even binary search will seem slow as we can directly jump to memory space where the names start from 'M' are stored.\n\n\nPositioning in Binary Search\n\n\nIn binary search, if the desired data is not found then the rest of the list is divided in two parts, lower and higher. The search is carried out in either of them.\n\n\n\n\n\n\n\n\n\n\nEven when the data is sorted, binary search does not take advantage to probe the position of the desired data.\n\n\nPosition Probing in Interpolation Search\n\n\nInterpolation search finds a particular item by computing the probe position. Initially, the probe position is the position of the middle most item of the collection.\n\n\n\n\n\n\nIf a match occurs, then the index of the item is returned. To split the list into two parts, we use the following method \u2212\n\n\nmid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])\n\n\n\n\nwhere\n\n\n\n\nA    = list\n\n\nLo   = Lowest index of the list\n\n\nHi   = Highest index of the list\n\n\nA[n] = Value stored at index n in the list\n\n\n\n\nIf the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.\n\n\nRuntime complexity of interpolation search algorithm is \n\u039f(log (log n))\n as compared to \n\u039f(log n)\n of BST in favorable situations.\n\n\nAlgorithm\n\n\nAs it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing \u2212\n\n\nStep 1 \u2212 Start searching data from middle of the list.\nStep 2 \u2212 If it is a match, return the index of the item, and exit.\nStep 3 \u2212 If it is not a match, probe position.\nStep 4 \u2212 Divide the list using probing formula and find the new midle.\nStep 5 \u2212 If data is greater than middle, search in higher sub-list.\nStep 6 \u2212 If data is smaller than middle, search in lower sub-list.\nStep 7 \u2212 Repeat until match.\n\n\n\n\nPseudocode\n\n\nA \u2192 Array list\nN \u2192 Size of A\nX \u2192 Target Value\n\nProcedure Interpolation_Search()\n\n   Set Lo  \u2192  0\n   Set Mid \u2192 -1\n   Set Hi  \u2192  N-1\n\n   While X does not match\n\n      if Lo equals to Hi OR A[Lo] equals to A[Hi]\n         EXIT: Failure, Target not found\n      end if\n\n      Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) \n\n      if A[Mid] = X\n         EXIT: Success, Target found at Mid\n      else \n         if A[Mid] \n X\n            Set Lo to Mid+1\n         else if A[Mid] \n X\n            Set Hi to Mid-1\n         end if\n      end if\n\n   End While\n\nEnd Procedure", 
            "title": "Interpolation Search"
        }, 
        {
            "location": "/search_interpolation/#interpolation-search", 
            "text": "Interpolation search is an improved variant of binary search. This search algorithm works on the probing position of the required value. For this algorithm to work properly, the data collection should be in a sorted form and equally distributed.  Binary search has a huge advantage of time complexity over linear search. Linear search has worst-case complexity of \u039f(n) whereas binary search has \u039f(log n).  There are cases where the location of target data may be known in advance. For example, in case of a telephone directory, if we want to search the telephone number of Morphius. Here, linear search and even binary search will seem slow as we can directly jump to memory space where the names start from 'M' are stored.", 
            "title": "Interpolation Search"
        }, 
        {
            "location": "/search_interpolation/#positioning-in-binary-search", 
            "text": "In binary search, if the desired data is not found then the rest of the list is divided in two parts, lower and higher. The search is carried out in either of them.      Even when the data is sorted, binary search does not take advantage to probe the position of the desired data.", 
            "title": "Positioning in Binary Search"
        }, 
        {
            "location": "/search_interpolation/#position-probing-in-interpolation-search", 
            "text": "Interpolation search finds a particular item by computing the probe position. Initially, the probe position is the position of the middle most item of the collection.    If a match occurs, then the index of the item is returned. To split the list into two parts, we use the following method \u2212  mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])  where   A    = list  Lo   = Lowest index of the list  Hi   = Highest index of the list  A[n] = Value stored at index n in the list   If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.  Runtime complexity of interpolation search algorithm is  \u039f(log (log n))  as compared to  \u039f(log n)  of BST in favorable situations.", 
            "title": "Position Probing in Interpolation Search"
        }, 
        {
            "location": "/search_interpolation/#algorithm", 
            "text": "As it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing \u2212  Step 1 \u2212 Start searching data from middle of the list.\nStep 2 \u2212 If it is a match, return the index of the item, and exit.\nStep 3 \u2212 If it is not a match, probe position.\nStep 4 \u2212 Divide the list using probing formula and find the new midle.\nStep 5 \u2212 If data is greater than middle, search in higher sub-list.\nStep 6 \u2212 If data is smaller than middle, search in lower sub-list.\nStep 7 \u2212 Repeat until match.", 
            "title": "Algorithm"
        }, 
        {
            "location": "/search_interpolation/#pseudocode", 
            "text": "A \u2192 Array list\nN \u2192 Size of A\nX \u2192 Target Value\n\nProcedure Interpolation_Search()\n\n   Set Lo  \u2192  0\n   Set Mid \u2192 -1\n   Set Hi  \u2192  N-1\n\n   While X does not match\n\n      if Lo equals to Hi OR A[Lo] equals to A[Hi]\n         EXIT: Failure, Target not found\n      end if\n\n      Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) \n\n      if A[Mid] = X\n         EXIT: Success, Target found at Mid\n      else \n         if A[Mid]   X\n            Set Lo to Mid+1\n         else if A[Mid]   X\n            Set Hi to Mid-1\n         end if\n      end if\n\n   End While\n\nEnd Procedure", 
            "title": "Pseudocode"
        }, 
        {
            "location": "/search_hash_table/", 
            "text": "Hash Table\n\n\nHash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.\n\n\nThus, it becomes a data structure in which insertion and search operations are very fast irrespective of the size of the data. Hash Table uses an array as a storage medium and uses hash technique to generate an index where an element is to be inserted or is to be located from.\n\n\nHashing\n\n\nHashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values. Consider an example of hash table of size 20, and the following items are to be stored. Item are in the (key,value) format.\n\n\n\n\n\n\n(1,20)\n\n\n(2,70)\n\n\n(42,80)\n\n\n(4,25)\n\n\n(12,44)\n\n\n(14,32)\n\n\n(17,11)\n\n\n(13,78)\n\n\n(37,98)\n\n\n\n\n\n\n\n\n\n\nSr. No.\n\n\nKey\n\n\nHash\n\n\nArray Index\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n1 % 20 = 1\n\n\n1\n\n\n\n\n\n\n2\n\n\n2\n\n\n2 % 20 = 2\n\n\n2\n\n\n\n\n\n\n3\n\n\n42\n\n\n42 % 20 = 2\n\n\n2\n\n\n\n\n\n\n4\n\n\n4\n\n\n4 % 20 = 4\n\n\n4\n\n\n\n\n\n\n5\n\n\n12\n\n\n12 % 20 = 12\n\n\n12\n\n\n\n\n\n\n6\n\n\n14\n\n\n4 % 20 = 14\n\n\n14\n\n\n\n\n\n\n7\n\n\n17\n\n\n7 % 20 = 17\n\n\n17\n\n\n\n\n\n\n8\n\n\n13\n\n\n3 % 20 = 13\n\n\n13\n\n\n\n\n\n\n9\n\n\n37\n\n\n7 % 20 = 17\n\n\n17\n\n\n\n\n\n\n\n\nLinear Probing\n\n\nAs we can see, it may happen that the hashing technique is used to create an already used index of the array. In such a case, we can search the next empty location in the array by looking into the next cell until we find an empty cell. This technique is called linear probing.\n\n\n\n\n\n\n\n\nSr. No.\n\n\nKey\n\n\nHash\n\n\nArray Index\n\n\nAfter Linear Probing, Array Index\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n1 % 20 = 1\n\n\n1\n\n\n1\n\n\n\n\n\n\n2\n\n\n2\n\n\n2 % 20 = 2\n\n\n2\n\n\n2\n\n\n\n\n\n\n3\n\n\n42\n\n\n42 % 20 = 2\n\n\n2\n\n\n3\n\n\n\n\n\n\n4\n\n\n4\n\n\n4 % 20 = 4\n\n\n4\n\n\n4\n\n\n\n\n\n\n5\n\n\n12\n\n\n12 % 20 = 12\n\n\n12\n\n\n12\n\n\n\n\n\n\n6\n\n\n14\n\n\n14 % 20 = 14\n\n\n14\n\n\n14\n\n\n\n\n\n\n7\n\n\n17\n\n\n17 % 20 = 17\n\n\n17\n\n\n17\n\n\n\n\n\n\n8\n\n\n13\n\n\n13 % 20 = 13\n\n\n13\n\n\n13\n\n\n\n\n\n\n9\n\n\n37\n\n\n37 % 20 = 17\n\n\n17\n\n\n18\n\n\n\n\n\n\n\n\nBasic Operations\n\n\nFollowing are the basic primary operations of a hash table.\n\n\n\n\nSearch\n \u2212 Searches an element in a hash table.\n\n\nInsert\n \u2212 inserts an element in a hash table.\n\n\ndelete\n \u2212 Deletes an element from a hash table.\n\n\n\n\nDataItem\n\n\nDefine a data item having some data and key, based on which the search is to be conducted in a hash table.\n\n\nstruct DataItem {\n   int data;   \n   int key;\n};\n\n\n\n\nHash Method\n\n\nDefine a hashing method to compute the hash code of the key of the data item.\n\n\nint hashCode(int key){\n   return key % SIZE;\n}\n\n\n\n\nSearch Operation\n\n\nWhenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.\n\n\nExample\n\n\nstruct DataItem *search(int key) {\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty \n   while(hashArray[hashIndex] != NULL) {\n\n      if(hashArray[hashIndex]-\nkey == key)\n         return hashArray[hashIndex];\n\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }\n\n   return NULL;        \n}\n\n\n\n\nInsert Operation\n\n\nWhenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.\n\n\nExample\n\n\nvoid insert(int key,int data) {\n   struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));\n   item-\ndata = data;  \n   item-\nkey = key;     \n\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty or deleted cell\n   while(hashArray[hashIndex] != NULL \n hashArray[hashIndex]-\nkey != -1) {\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }\n\n   hashArray[hashIndex] = item;        \n}\n\n\n\n\nDelete Operation\n\n\nWhenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.\n\n\nExample\n\n\nstruct DataItem* delete(struct DataItem* item) {\n   int key = item-\nkey;\n\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty \n   while(hashArray[hashIndex] !=NULL) {\n\n      if(hashArray[hashIndex]-\nkey == key) {\n         struct DataItem* temp = hashArray[hashIndex]; \n\n         //assign a dummy item at deleted position\n         hashArray[hashIndex] = dummyItem; \n         return temp;\n      } \n\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }  \n\n   return NULL;        \n}", 
            "title": "Hash Tables"
        }, 
        {
            "location": "/search_hash_table/#hash-table", 
            "text": "Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.  Thus, it becomes a data structure in which insertion and search operations are very fast irrespective of the size of the data. Hash Table uses an array as a storage medium and uses hash technique to generate an index where an element is to be inserted or is to be located from.", 
            "title": "Hash Table"
        }, 
        {
            "location": "/search_hash_table/#hashing", 
            "text": "Hashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values. Consider an example of hash table of size 20, and the following items are to be stored. Item are in the (key,value) format.    (1,20)  (2,70)  (42,80)  (4,25)  (12,44)  (14,32)  (17,11)  (13,78)  (37,98)      Sr. No.  Key  Hash  Array Index      1  1  1 % 20 = 1  1    2  2  2 % 20 = 2  2    3  42  42 % 20 = 2  2    4  4  4 % 20 = 4  4    5  12  12 % 20 = 12  12    6  14  4 % 20 = 14  14    7  17  7 % 20 = 17  17    8  13  3 % 20 = 13  13    9  37  7 % 20 = 17  17", 
            "title": "Hashing"
        }, 
        {
            "location": "/search_hash_table/#linear-probing", 
            "text": "As we can see, it may happen that the hashing technique is used to create an already used index of the array. In such a case, we can search the next empty location in the array by looking into the next cell until we find an empty cell. This technique is called linear probing.     Sr. No.  Key  Hash  Array Index  After Linear Probing, Array Index      1  1  1 % 20 = 1  1  1    2  2  2 % 20 = 2  2  2    3  42  42 % 20 = 2  2  3    4  4  4 % 20 = 4  4  4    5  12  12 % 20 = 12  12  12    6  14  14 % 20 = 14  14  14    7  17  17 % 20 = 17  17  17    8  13  13 % 20 = 13  13  13    9  37  37 % 20 = 17  17  18", 
            "title": "Linear Probing"
        }, 
        {
            "location": "/search_hash_table/#basic-operations", 
            "text": "Following are the basic primary operations of a hash table.   Search  \u2212 Searches an element in a hash table.  Insert  \u2212 inserts an element in a hash table.  delete  \u2212 Deletes an element from a hash table.", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/search_hash_table/#dataitem", 
            "text": "Define a data item having some data and key, based on which the search is to be conducted in a hash table.  struct DataItem {\n   int data;   \n   int key;\n};", 
            "title": "DataItem"
        }, 
        {
            "location": "/search_hash_table/#hash-method", 
            "text": "Define a hashing method to compute the hash code of the key of the data item.  int hashCode(int key){\n   return key % SIZE;\n}", 
            "title": "Hash Method"
        }, 
        {
            "location": "/search_hash_table/#search-operation", 
            "text": "Whenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.  Example  struct DataItem *search(int key) {\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty \n   while(hashArray[hashIndex] != NULL) {\n\n      if(hashArray[hashIndex]- key == key)\n         return hashArray[hashIndex];\n\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }\n\n   return NULL;        \n}", 
            "title": "Search Operation"
        }, 
        {
            "location": "/search_hash_table/#insert-operation", 
            "text": "Whenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.  Example  void insert(int key,int data) {\n   struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));\n   item- data = data;  \n   item- key = key;     \n\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty or deleted cell\n   while(hashArray[hashIndex] != NULL   hashArray[hashIndex]- key != -1) {\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }\n\n   hashArray[hashIndex] = item;        \n}", 
            "title": "Insert Operation"
        }, 
        {
            "location": "/search_hash_table/#delete-operation", 
            "text": "Whenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.  Example  struct DataItem* delete(struct DataItem* item) {\n   int key = item- key;\n\n   //get the hash \n   int hashIndex = hashCode(key);\n\n   //move in array until an empty \n   while(hashArray[hashIndex] !=NULL) {\n\n      if(hashArray[hashIndex]- key == key) {\n         struct DataItem* temp = hashArray[hashIndex]; \n\n         //assign a dummy item at deleted position\n         hashArray[hashIndex] = dummyItem; \n         return temp;\n      } \n\n      //go to next cell\n      ++hashIndex;\n\n      //wrap around the table\n      hashIndex %= SIZE;\n   }  \n\n   return NULL;        \n}", 
            "title": "Delete Operation"
        }, 
        {
            "location": "/graph_data_structure/", 
            "text": "Graph Data Structure\n\n\nA graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as vertices, and the links that connect the vertices are called edges.\n\n\nFormally, a graph is a pair of sets \n(V, E)\n, where \nV\n is the set of vertices and \nE\n is the set of edges, connecting the pairs of vertices. Take a look at the following graph\n\n\n\n\nIn the above graph,\n\n\n\n\n\n\n\n\nV = {a, b, c, d, e}\n\n\n\n\n\n\n\n\n\n\nE = {ab, ac, bd, cd, de}\n\n\n\n\n\n\n\n\nDefinitions\n\n\nMathematical graphs can be represented in data structure. We can represent a graph using an array of vertices and a two-dimensional array of edges. Before we proceed further, let's familiarize ourselves with some important terms\n\n\n\n\nVertex\n \u2212 Each node of the graph is represented as a vertex. In the following example, the labeled circle represents vertices. Thus, A to G are vertices. We can represent them using an array as shown in the following image. Here A can be identified by index 0. B can be identified using index 1 and so on.\n\n\nEdge\n \u2212 Edge represents a path between two vertices or a line between two vertices. In the following example, the lines from A to B, B to C, and so on represents edges. We can use a two-dimensional array to represent an array as shown in the following image. Here AB can be represented as 1 at row 0, column 1, BC as 1 at row 1, column 2 and so on, keeping other combinations as 0.\n\n\nAdjacency\n \u2212 Two node or vertices are adjacent if they are connected to each other through an edge. In the following example, B is adjacent to A, C is adjacent to B, and so on.\n\n\nPath\n \u2212 Path represents a sequence of edges between the two vertices. In the following example, ABCD represents a path from A to D.\n\n\n\n\n\n\nBasic Operations\n\n\nFollowing are basic primary operations of a Graph \u2212\n\n\n\n\nAdd Vertex\n \u2212 Adds a vertex to the graph.\n\n\nAdd Edge\n \u2212 Adds an edge between the two vertices of the graph.\n\n\nDisplay Vertex\n \u2212 Displays a vertex of the graph.", 
            "title": "Graph Data Structure"
        }, 
        {
            "location": "/graph_data_structure/#graph-data-structure", 
            "text": "A graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as vertices, and the links that connect the vertices are called edges.  Formally, a graph is a pair of sets  (V, E) , where  V  is the set of vertices and  E  is the set of edges, connecting the pairs of vertices. Take a look at the following graph   In the above graph,     V = {a, b, c, d, e}      E = {ab, ac, bd, cd, de}", 
            "title": "Graph Data Structure"
        }, 
        {
            "location": "/graph_data_structure/#definitions", 
            "text": "Mathematical graphs can be represented in data structure. We can represent a graph using an array of vertices and a two-dimensional array of edges. Before we proceed further, let's familiarize ourselves with some important terms   Vertex  \u2212 Each node of the graph is represented as a vertex. In the following example, the labeled circle represents vertices. Thus, A to G are vertices. We can represent them using an array as shown in the following image. Here A can be identified by index 0. B can be identified using index 1 and so on.  Edge  \u2212 Edge represents a path between two vertices or a line between two vertices. In the following example, the lines from A to B, B to C, and so on represents edges. We can use a two-dimensional array to represent an array as shown in the following image. Here AB can be represented as 1 at row 0, column 1, BC as 1 at row 1, column 2 and so on, keeping other combinations as 0.  Adjacency  \u2212 Two node or vertices are adjacent if they are connected to each other through an edge. In the following example, B is adjacent to A, C is adjacent to B, and so on.  Path  \u2212 Path represents a sequence of edges between the two vertices. In the following example, ABCD represents a path from A to D.", 
            "title": "Definitions"
        }, 
        {
            "location": "/graph_data_structure/#basic-operations", 
            "text": "Following are basic primary operations of a Graph \u2212   Add Vertex  \u2212 Adds a vertex to the graph.  Add Edge  \u2212 Adds an edge between the two vertices of the graph.  Display Vertex  \u2212 Displays a vertex of the graph.", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/graph_dfs/", 
            "text": "Depth First Traversal\n\n\nDepth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.\n\n\n\n\nAs in the example given above, DFS algorithm traverses from A to B to C to D first then to E, then to F and lastly to G. It employs the following rules.\n\n\n\n\nRule 1\n \u2212 Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.\n\n\nRule 2\n \u2212 If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)\n\n\nRule 3\n \u2212 Repeat Rule 1 and Rule 2 until the stack is empty.\n\n\n\n\nAlgorithms\n\n\n\n\n\n\n\n\nStep\n\n\nTraversal\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1.\n\n\n\n\nInitialize the stack.\n\n\n\n\n\n\n2.\n\n\n\n\nMark S as visited and put it onto the stack. Explore any unvisited adjacent node from S. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.\n\n\n\n\n\n\n3.\n\n\n\n\nMark A as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both Sand D are adjacent to A but we are concerned for unvisited nodes only.\n\n\n\n\n\n\n4.\n\n\n\n\nVisit D and mark it as visited and put onto the stack. Here, we have B and C nodes, which are adjacent to D and both are unvisited. However, we shall again choose in an alphabetical order.\n\n\n\n\n\n\n5.\n\n\n\n\nWe choose B, mark it as visited and put onto the stack. Here Bdoes not have any unvisited adjacent node. So, we pop Bfrom the stack.\n\n\n\n\n\n\n6.\n\n\n\n\nWe check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find D to be on the top of the stack.\n\n\n\n\n\n\n7.\n\n\n\n\nOnly unvisited adjacent node is from D is C now. So we visit C, mark it as visited and put it onto the stack.", 
            "title": "DFS: Depth First Traversal"
        }, 
        {
            "location": "/graph_dfs/#depth-first-traversal", 
            "text": "Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.   As in the example given above, DFS algorithm traverses from A to B to C to D first then to E, then to F and lastly to G. It employs the following rules.   Rule 1  \u2212 Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.  Rule 2  \u2212 If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)  Rule 3  \u2212 Repeat Rule 1 and Rule 2 until the stack is empty.", 
            "title": "Depth First Traversal"
        }, 
        {
            "location": "/graph_dfs/#algorithms", 
            "text": "Step  Traversal  Description      1.   Initialize the stack.    2.   Mark S as visited and put it onto the stack. Explore any unvisited adjacent node from S. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.    3.   Mark A as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both Sand D are adjacent to A but we are concerned for unvisited nodes only.    4.   Visit D and mark it as visited and put onto the stack. Here, we have B and C nodes, which are adjacent to D and both are unvisited. However, we shall again choose in an alphabetical order.    5.   We choose B, mark it as visited and put onto the stack. Here Bdoes not have any unvisited adjacent node. So, we pop Bfrom the stack.    6.   We check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find D to be on the top of the stack.    7.   Only unvisited adjacent node is from D is C now. So we visit C, mark it as visited and put it onto the stack.", 
            "title": "Algorithms"
        }, 
        {
            "location": "/graph_bfs/", 
            "text": "Breadth First Traversal\n\n\nBreadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.\n\n\n\n\nAs in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.\n\n\n\n\nRule 1\n \u2212 Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it * in a queue.\n\n\nRule 2\n \u2212 If no adjacent vertex is found, remove the first vertex from the queue.\n\n\nRule 3\n \u2212 Repeat Rule 1 and Rule 2 until the queue is empty.\n\n\n\n\nAlgorithms\n\n\n\n\n\n\n\n\nStep\n\n\nTraversal\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1.\n\n\n\n\nInitialize the stack.\n\n\n\n\n\n\n2.\n\n\n\n\nMark S as visited and put it onto the stack. Explore any unvisited adjacent node from S. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.\n\n\n\n\n\n\n3.\n\n\n\n\nMark A as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both Sand D are adjacent to A but we are concerned for unvisited nodes only.\n\n\n\n\n\n\n4.\n\n\n\n\nVisit D and mark it as visited and put onto the stack. Here, we have B and C nodes, which are adjacent to D and both are unvisited. However, we shall again choose in an alphabetical order.\n\n\n\n\n\n\n5.\n\n\n\n\nWe choose B, mark it as visited and put onto the stack. Here Bdoes not have any unvisited adjacent node. So, we pop Bfrom the stack.\n\n\n\n\n\n\n6.\n\n\n\n\nWe check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find D to be on the top of the stack.\n\n\n\n\n\n\n7.\n\n\n\n\nOnly unvisited adjacent node is from D is C now. So we visit C, mark it as visited and put it onto the stack.\n\n\n\n\n\n\n\n\nAt this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.", 
            "title": "BFS: Breadth First Traversal"
        }, 
        {
            "location": "/graph_bfs/#breadth-first-traversal", 
            "text": "Breadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.   As in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.   Rule 1  \u2212 Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it * in a queue.  Rule 2  \u2212 If no adjacent vertex is found, remove the first vertex from the queue.  Rule 3  \u2212 Repeat Rule 1 and Rule 2 until the queue is empty.", 
            "title": "Breadth First Traversal"
        }, 
        {
            "location": "/graph_bfs/#algorithms", 
            "text": "Step  Traversal  Description      1.   Initialize the stack.    2.   Mark S as visited and put it onto the stack. Explore any unvisited adjacent node from S. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.    3.   Mark A as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both Sand D are adjacent to A but we are concerned for unvisited nodes only.    4.   Visit D and mark it as visited and put onto the stack. Here, we have B and C nodes, which are adjacent to D and both are unvisited. However, we shall again choose in an alphabetical order.    5.   We choose B, mark it as visited and put onto the stack. Here Bdoes not have any unvisited adjacent node. So, we pop Bfrom the stack.    6.   We check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find D to be on the top of the stack.    7.   Only unvisited adjacent node is from D is C now. So we visit C, mark it as visited and put it onto the stack.     At this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.", 
            "title": "Algorithms"
        }, 
        {
            "location": "/string_string/", 
            "text": "String\n\n\nString manipulation is a basic operation of many algorithms and utilities such as data validation, text parsing, file conversions and others. The Java APIs contain three classes that are used to work with character data:\n\n\n\n\nCharacter\n -- A class whose instances can hold a single character value.\n\n\nString\n -- An immutable class for working with multiple characters.\n\n\nStringBuffer\n and \nStringBuilder\n -- Mutable classes for working with multiple characters.\n\n\n\n\nThe String and StringBuffer classes are two you will use the most in your programming assignments. You use the String class in situations when you want to prohibit data modification; otherwise you use the StringBuffer class.\n\n\nThe String class\n\n\nIn Java Strings can be created in two different ways. Either using a new operator\n\n\nString demo1 = new String(\nThis is a string\n);\n\nchar[] demo2 = {'s','t','r','i','n','g'};\nString str = new String(demo2);\n\n\n\n\nor using a string literal\n\n\nString demo3 = \nThis is a string\n;\n\n\n\n\nThe example below demonstrates differences between these initializations\n\n\nString s1 = new String(\nFester\n);\nString s2 = new String(\nFester\n);\nString s3 = \nFester\n;\nString s4 = \nFester\n;\n\n\n\n\nThen\n\n\ns1 == s2 returns false\ns1 == s3 returns false\ns3 == s4 returns true\n\n\n\n\nBecause of the importance strings in real life, Java stores (at compile time) all strings in a special internal table as long as you create your strings using a string literal String s3 = \"Fester\". This process is called canonicalization - it replaces multiple string objects with a single object. This is why in the above example s3 and s4 refer to the same object. Also note that creating strings like s3 and s4 is more efficient. Review the code example StringOptimization.java that demonstrates time comparisons between these two ways of string creation.\n\n\nHere are some important facts you must know about strings:\n\n\n1.\n A string is not an array of characters.\nTherefore, to access a particular character in a string, you have to use the charAt() method. In this code snippet we get the fourth character which is 't':\n\n\nString str = \non the  edge of history\n;\nchar ch = str.charAt(3);\n\n\n\n\n2.\n The toString() method is used when we need a string representation of an object.\n\n\nThe method is defined in the Object class. For most important classes that you create, you will want to override toString() and provide your own string representation.\n\n\n3.\n Comparing strings content using == is the most common mistake beginners do. You compare the content using either equals() or compareTo() methods.\n\n\nBasic String methods\n\n\nThe String class contains an enormous amount of useful methods for string manipulation. The following table presents the most common String methods:\n\n\n\n\nstr.charAt(k) returns a char at position k in str.\n\n\nstr.substring(k)  returns a substring from index k to the end of str\n\n\ns.substring(k, n) returns a substring from index k to index n-1 of str\n\n\nstr.indexOf(s)    returns an index of the first occurrence of String s in str\n\n\nstr.indexOf(s, k) returns an index of String s starting an index k in str\n\n\nstr.startsWith(s) returns true if str starts with s\n\n\nstr.startsWith(s, k)  returns true if str starts with s at index k\n\n\nstr.equals(s) returns true if the two strings have equal values\n\n\nstr.equalsIgnoreCase(s)   same as above ignoring case\n\n\nstr.compareTo(s)  compares two strings\n\n\ns.compareToIgnoreCase(t)  same as above ignoring case\n\n\n\n\nExamine the code in \nBasicStringDemo.java\n for further details.\n\n\nThe StringBuffer class\n\n\nIn many cases when you deal with strings you will use methods available in the companion StringBuffer class. This mutable class is used when you want to modify the contents of the string. It provides an efficient approach to dealing with strings, especially for large dynamic string data. StringBuffer is similar to ArrayList in a way that the memory allocated to an object is automatically expanded to take up additional data.\n\n\nHere is an example of reversing a string using string concatenation\n\n\npublic static String reverse1(String s)\n{\n   String str = \n;\n\n   for(int i = s.length() - 1; i\n=0; i--)\n      str += s.charAt(i);\n\n   return str;\n}\n\n\n\n\nand using a StringBuffer's append\n\n\npublic static String revers2(String s)\n{\n   StringBuffer sb = new StringBuffer();\n\n   for(int i = s.length() - 1; i\n=0; i--)\n      sb.append(s.charAt(i));\n\n   return sb.toString();\n}\n\n\n\n\nAnother way to reverse a string is to convert a String object into a StringBuffer object, use the reverse method, and then convert it back to a string:\n\n\npublic static String reverse3(String s)\n{\n   return new StringBuffer(s).reverse().toString();\n}\n\n\n\n\nThe performance difference between these two classes is that StringBuffer is faster than String when performing concatenations. Each time a concatenation occurs, a new string is created, causing excessive system resource consumption.\n\n\nReview the code example \nStringOverhead.java\n that demonstrates time comparisons of concatenation on Strings and StringBuffer.\n\n\nStringTokenizer\n\n\nThis class (from java.util package) allows you to break a string into tokens (substrings). Each token is a group of characters that are separated by delimiters, such as an empty space, a semicolon, and so on. So, a token is a maximal sequence of consecutive characters that are not delimiters. Here is an example of the use of the tokenizer (an empty space is a default delimiter):\n\n\nString s = \nNothing is as easy as it looks\n;\nStringTokenizer st = new StringTokenizer(s);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println( \nToken [\n + token + \n]\n );\n}\n\n\n\n\nHere, hasMoreTokens() method checks if there are more tokens available from the string, and nextToken() method returns the next token from the string tokenizer.\n\n\nThe set of delimiters (the characters that separate tokens) may be specified in the second argument of StringTokenizer. In the following example, StringTokenizer has a set of two delimiters: an empty space and an underscore:\n\n\nString s = \nEvery_solution_breeds new problems\n;\nStringTokenizer st = new StringTokenizer(s, \n _\n);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println( \nToken [\n + token + \n]\n );\n}\n\n\n\n\nRegular Expressions\n\n\nRegular expressions are the most common programming technique for scanning strings and extracting substrings based on common characteristics. They are an essential part of many programming languages. In the following table the left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.\n\n\nCharacter Classes\n\n\n[abc]           a, b, or c (simple class)\n[^abc]          Any character except a, b, or c (negation)\n[a-zA-Z]        a through z, or A through Z, inclusive (range)\n[a-d[m-p]]      a through d, or m through p: [a-dm-p] (union)\n[a-z\n[def]]    d, e, or f (intersection)\n[a-z\n[^bc]]    a through z, except for b and c: [ad-z] (subtraction)\n[a-z\n[^m-p]]   a through z, and not m through p: [a-lq-z] (subtraction)\n\\\\d             any digit from 0 to 9\n\\\\w             any word character (a-z,A-Z,0-9 and _)\n\\\\W             any non-word character\n\\\\s             any whitespace character\n?               appearing once or not at all\n*               appearing zero or more times\n+               appearing one or more times\n\n\n\n\nThe Java String class has several methods that allow you to perform an operation using a regular expression on that string in a minimal amount of code.\n\n\nThe matches() method\n\n\nThe matches(\"regex\") method returns true or false depending whether the string can be matched entirely by the regular expression \"regex\". For example,\n\n\nabc\n.matches(\nabc\n)\nreturns True,\n\n\n\n\nbut\n\n\nabc\n.matches(\nbc\n)\n\n\n\n\nreturns False. In the following code examples we match all strings that start with any number of dots (denoted by *), followed by \"abc\" and end with one or more underscores (denoted by +).\n\n\nString regex = \n.*\n+\nabc\n+\n_+\n;\n\n\n..abc___\n.matches(regex);\n\n\nabc___\n.matches(regex);\n\n\nabc_\n.matches(regex);\n\n\n\n\nThe replaceAll() method\n\n\nThe method replaceAll(\"regex\", \"replacement\") replaces each substring of the myString that matches the given regular expression \"regex\" with the given \"replacement\". As an example, let us remove all non-letters from a given string\n\n\nString str = \nNothing 2is as \n easy AS it +_=looks!\n;\nstr = str.replaceAll(\n[^a-zA-Z]\n, \n);\n\n\n\n\nThe pattern \"[a-zA-Z]\" describes all letters (in upper and lower cases). Next we negate this pattern, to get all non-letters \"[^a-zA-Z]\".\n\n\nIn the next example, we replace a sequence of characters by \"-\"\n\n\nString str = \naabfooaaaabfooabfoob\n;\nstr = str.replaceAll(\na*b\n, \n-\n);\n\n\n\n\nThe star \"\n\" in the pattern \"a\nb\" denotes that character \"a\" may be repeated zero or more times. The output: \"-foo-foo-foo-\";\n\n\nThe split() method\n\n\nThe split(\"regex\") splits the string at each \"regex\" match and returns an array of strings where each element is a part of the original string between two \"regex\" matches.\n\n\nIn the following example we break a sentence into words, using an empty space as a delimiter:\n\n\nString s = \nNothing is as easy as it looks\n;\nString[] st = s.split(\n \n);\n\n\n\n\nTokens are stored in in an array of strings and could be be easily accessible using array indexes. In the next code example, we choose two delimiters: either an empty space or an underscore:\n\n\nString s = \nEvery_solution_breeds new problems\n;\nString[]st = s.split(\n_| \n);\n\n\n\n\nWhat if a string contains several underscores? We use \"+\", that denotes a repetitive pattern\n\n\nString s = \nEvery_solution____breeds_new__problems\n;\nString[] st = s.split(\n_+\n);\n\n\n\n\nIt's important to observe that split() might returns empty tokens. In the example below\n\n\nString[] st = \nTomorrow\n.split(\nr\n);\n\n\n\n\nwe have three tokens, where the second token is empty string. That is so because split() returns tokens between two \"regex\" matches.\n\n\nOne of the widely use of split() is to break a given text file into words. This could be easily done by means of the metacharacter \"\\W\" (any non-word character), which allows you to perform a \"whole words only\" search using a regular expression. A \"word character\" is either an alphabet character (a-z and A-Z) or a digit (0-9) or a underscore.\n\n\nLet's go, Steelers!!!\n.split(\n\\\\W\n);\n\n\n\n\nreturns the following array of tokens\n\n\n[Let, s, go, Steelers]\n\n\n\n\nExamine the code in \nSplit.java\n for further details.\n\n\nPattern matching\n\n\nPattern matching in Java is based on use of two classes\n\n\n\n\nPattern\n  - compiled representation of a regular expression.\n\n\nMatcher\n - an engine that performs match operations.\n\n\n\n\nA typical invocation is the following, first we create a pattern\n\n\nString seq = \nCCCAA\n;\nPattern p = Pattern.compile(\nC*A*\n);\n\n\n\n\nIn this example we match all substrings that start with any number of Cs followed by any number of As. Then we create a Matcher object that can match any string against our pattern\n\n\nMatcher m = p.matcher(seq);\n\n\n\n\nFinally, we do actual matching\n\n\nboolean res = m.matches();\n\n\n\n\nThe Matcher class has another widely used method, called find(), that finds next substring that matches a given pattern. In the following example we cound the number of matches \"ACC\"\n\n\nString seq = \nCGTATCCCACAGCACCACACCCAACAACCCA\n;\nPattern p = Pattern.compile(\nA{1}C{2}\n);\nMatcher m = p.matcher(seq);\nint count = 0;\nwhile( m.find() ) count++;\nSystem.out.println(\nthere are \n + count + \n ACC\n);\n\n\n\n\nExamine the code example \nMatching.java\n for further details.\n\n\nPattern matching in Computational Biology\n\n\n\n\nThe DNA (the genetic blueprint) of any species is composed of about 4 billion ACGT nucleotides. DNA forms a double helix that has two strands of DNA binding and twisting together. In pattern matching problems we ignore the fact that DNA forms a double helix, and think of it only as a single strand. The other strand is complimentary. Knowing one strand allows uniquely determine the other one. Thus, DNA is essentially a linear molecule that looks like a string composed out of only four characters A, C, G, and T:\n\n\nCGTATCCCACAGCACCACACCCAACAACCC\n\n\n\n\nEach nucleotides (also called a base) strongly binds to no more than two other bases. These links provides a linear model of DNA strand. The particular order of ACGT nucleotides is extremely important. Different orders generate humans, animals, corn, and other organisms. The size of the genome (a genome is all the DNA in an organism) does not necessarily correlate with the complexity of the organism it belongs to. Humans have less than a third as many genes as were expected.\n\n\nPattern matching in computational biology arises from the need to know characteristics of DNA sequences, such as\n\n\n\n\nfind the best way to align two sequences.\n\n\nfind any common subsequences\n\n\ndetermine how well a sequence fits into a given model.\n\n\n\n\nComparing various DNA sequencesn provide many uses. Current scientific theories suggest that very similar DNA sequences have a common ancestor. The more similar two sequences are, the more recently they evolved from a single ansestor. With such knowledge, for example, we can reconstruct a phylogenetic tree (known as a \"tree of life\".) that shows how long ago various organisms diverged and which species are closely related.\n\n\nChallenges\n\n\n\n\nStrings: Making Anagrams\n\n\n\n\nReferences\n\n\n\n\n\"Strings\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Introduction to Strings"
        }, 
        {
            "location": "/string_string/#string", 
            "text": "String manipulation is a basic operation of many algorithms and utilities such as data validation, text parsing, file conversions and others. The Java APIs contain three classes that are used to work with character data:   Character  -- A class whose instances can hold a single character value.  String  -- An immutable class for working with multiple characters.  StringBuffer  and  StringBuilder  -- Mutable classes for working with multiple characters.   The String and StringBuffer classes are two you will use the most in your programming assignments. You use the String class in situations when you want to prohibit data modification; otherwise you use the StringBuffer class.", 
            "title": "String"
        }, 
        {
            "location": "/string_string/#the-string-class", 
            "text": "In Java Strings can be created in two different ways. Either using a new operator  String demo1 = new String( This is a string );\n\nchar[] demo2 = {'s','t','r','i','n','g'};\nString str = new String(demo2);  or using a string literal  String demo3 =  This is a string ;  The example below demonstrates differences between these initializations  String s1 = new String( Fester );\nString s2 = new String( Fester );\nString s3 =  Fester ;\nString s4 =  Fester ;  Then  s1 == s2 returns false\ns1 == s3 returns false\ns3 == s4 returns true  Because of the importance strings in real life, Java stores (at compile time) all strings in a special internal table as long as you create your strings using a string literal String s3 = \"Fester\". This process is called canonicalization - it replaces multiple string objects with a single object. This is why in the above example s3 and s4 refer to the same object. Also note that creating strings like s3 and s4 is more efficient. Review the code example StringOptimization.java that demonstrates time comparisons between these two ways of string creation.  Here are some important facts you must know about strings:  1.  A string is not an array of characters.\nTherefore, to access a particular character in a string, you have to use the charAt() method. In this code snippet we get the fourth character which is 't':  String str =  on the  edge of history ;\nchar ch = str.charAt(3);  2.  The toString() method is used when we need a string representation of an object.  The method is defined in the Object class. For most important classes that you create, you will want to override toString() and provide your own string representation.  3.  Comparing strings content using == is the most common mistake beginners do. You compare the content using either equals() or compareTo() methods.", 
            "title": "The String class"
        }, 
        {
            "location": "/string_string/#basic-string-methods", 
            "text": "The String class contains an enormous amount of useful methods for string manipulation. The following table presents the most common String methods:   str.charAt(k) returns a char at position k in str.  str.substring(k)  returns a substring from index k to the end of str  s.substring(k, n) returns a substring from index k to index n-1 of str  str.indexOf(s)    returns an index of the first occurrence of String s in str  str.indexOf(s, k) returns an index of String s starting an index k in str  str.startsWith(s) returns true if str starts with s  str.startsWith(s, k)  returns true if str starts with s at index k  str.equals(s) returns true if the two strings have equal values  str.equalsIgnoreCase(s)   same as above ignoring case  str.compareTo(s)  compares two strings  s.compareToIgnoreCase(t)  same as above ignoring case   Examine the code in  BasicStringDemo.java  for further details.", 
            "title": "Basic String methods"
        }, 
        {
            "location": "/string_string/#the-stringbuffer-class", 
            "text": "In many cases when you deal with strings you will use methods available in the companion StringBuffer class. This mutable class is used when you want to modify the contents of the string. It provides an efficient approach to dealing with strings, especially for large dynamic string data. StringBuffer is similar to ArrayList in a way that the memory allocated to an object is automatically expanded to take up additional data.  Here is an example of reversing a string using string concatenation  public static String reverse1(String s)\n{\n   String str =  ;\n\n   for(int i = s.length() - 1; i =0; i--)\n      str += s.charAt(i);\n\n   return str;\n}  and using a StringBuffer's append  public static String revers2(String s)\n{\n   StringBuffer sb = new StringBuffer();\n\n   for(int i = s.length() - 1; i =0; i--)\n      sb.append(s.charAt(i));\n\n   return sb.toString();\n}  Another way to reverse a string is to convert a String object into a StringBuffer object, use the reverse method, and then convert it back to a string:  public static String reverse3(String s)\n{\n   return new StringBuffer(s).reverse().toString();\n}  The performance difference between these two classes is that StringBuffer is faster than String when performing concatenations. Each time a concatenation occurs, a new string is created, causing excessive system resource consumption.  Review the code example  StringOverhead.java  that demonstrates time comparisons of concatenation on Strings and StringBuffer.", 
            "title": "The StringBuffer class"
        }, 
        {
            "location": "/string_string/#stringtokenizer", 
            "text": "This class (from java.util package) allows you to break a string into tokens (substrings). Each token is a group of characters that are separated by delimiters, such as an empty space, a semicolon, and so on. So, a token is a maximal sequence of consecutive characters that are not delimiters. Here is an example of the use of the tokenizer (an empty space is a default delimiter):  String s =  Nothing is as easy as it looks ;\nStringTokenizer st = new StringTokenizer(s);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println(  Token [  + token +  ]  );\n}  Here, hasMoreTokens() method checks if there are more tokens available from the string, and nextToken() method returns the next token from the string tokenizer.  The set of delimiters (the characters that separate tokens) may be specified in the second argument of StringTokenizer. In the following example, StringTokenizer has a set of two delimiters: an empty space and an underscore:  String s =  Every_solution_breeds new problems ;\nStringTokenizer st = new StringTokenizer(s,   _ );\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println(  Token [  + token +  ]  );\n}", 
            "title": "StringTokenizer"
        }, 
        {
            "location": "/string_string/#regular-expressions", 
            "text": "Regular expressions are the most common programming technique for scanning strings and extracting substrings based on common characteristics. They are an essential part of many programming languages. In the following table the left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.  Character Classes  [abc]           a, b, or c (simple class)\n[^abc]          Any character except a, b, or c (negation)\n[a-zA-Z]        a through z, or A through Z, inclusive (range)\n[a-d[m-p]]      a through d, or m through p: [a-dm-p] (union)\n[a-z [def]]    d, e, or f (intersection)\n[a-z [^bc]]    a through z, except for b and c: [ad-z] (subtraction)\n[a-z [^m-p]]   a through z, and not m through p: [a-lq-z] (subtraction)\n\\\\d             any digit from 0 to 9\n\\\\w             any word character (a-z,A-Z,0-9 and _)\n\\\\W             any non-word character\n\\\\s             any whitespace character\n?               appearing once or not at all\n*               appearing zero or more times\n+               appearing one or more times  The Java String class has several methods that allow you to perform an operation using a regular expression on that string in a minimal amount of code.", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/string_string/#the-matches-method", 
            "text": "The matches(\"regex\") method returns true or false depending whether the string can be matched entirely by the regular expression \"regex\". For example,  abc .matches( abc )\nreturns True,  but  abc .matches( bc )  returns False. In the following code examples we match all strings that start with any number of dots (denoted by *), followed by \"abc\" and end with one or more underscores (denoted by +).  String regex =  .* + abc + _+ ; ..abc___ .matches(regex); abc___ .matches(regex); abc_ .matches(regex);", 
            "title": "The matches() method"
        }, 
        {
            "location": "/string_string/#the-replaceall-method", 
            "text": "The method replaceAll(\"regex\", \"replacement\") replaces each substring of the myString that matches the given regular expression \"regex\" with the given \"replacement\". As an example, let us remove all non-letters from a given string  String str =  Nothing 2is as   easy AS it +_=looks! ;\nstr = str.replaceAll( [^a-zA-Z] ,  );  The pattern \"[a-zA-Z]\" describes all letters (in upper and lower cases). Next we negate this pattern, to get all non-letters \"[^a-zA-Z]\".  In the next example, we replace a sequence of characters by \"-\"  String str =  aabfooaaaabfooabfoob ;\nstr = str.replaceAll( a*b ,  - );  The star \" \" in the pattern \"a b\" denotes that character \"a\" may be repeated zero or more times. The output: \"-foo-foo-foo-\";", 
            "title": "The replaceAll() method"
        }, 
        {
            "location": "/string_string/#the-split-method", 
            "text": "The split(\"regex\") splits the string at each \"regex\" match and returns an array of strings where each element is a part of the original string between two \"regex\" matches.  In the following example we break a sentence into words, using an empty space as a delimiter:  String s =  Nothing is as easy as it looks ;\nString[] st = s.split(   );  Tokens are stored in in an array of strings and could be be easily accessible using array indexes. In the next code example, we choose two delimiters: either an empty space or an underscore:  String s =  Every_solution_breeds new problems ;\nString[]st = s.split( _|  );  What if a string contains several underscores? We use \"+\", that denotes a repetitive pattern  String s =  Every_solution____breeds_new__problems ;\nString[] st = s.split( _+ );  It's important to observe that split() might returns empty tokens. In the example below  String[] st =  Tomorrow .split( r );  we have three tokens, where the second token is empty string. That is so because split() returns tokens between two \"regex\" matches.  One of the widely use of split() is to break a given text file into words. This could be easily done by means of the metacharacter \"\\W\" (any non-word character), which allows you to perform a \"whole words only\" search using a regular expression. A \"word character\" is either an alphabet character (a-z and A-Z) or a digit (0-9) or a underscore.  Let's go, Steelers!!! .split( \\\\W );  returns the following array of tokens  [Let, s, go, Steelers]  Examine the code in  Split.java  for further details.", 
            "title": "The split() method"
        }, 
        {
            "location": "/string_string/#pattern-matching", 
            "text": "Pattern matching in Java is based on use of two classes   Pattern   - compiled representation of a regular expression.  Matcher  - an engine that performs match operations.   A typical invocation is the following, first we create a pattern  String seq =  CCCAA ;\nPattern p = Pattern.compile( C*A* );  In this example we match all substrings that start with any number of Cs followed by any number of As. Then we create a Matcher object that can match any string against our pattern  Matcher m = p.matcher(seq);  Finally, we do actual matching  boolean res = m.matches();  The Matcher class has another widely used method, called find(), that finds next substring that matches a given pattern. In the following example we cound the number of matches \"ACC\"  String seq =  CGTATCCCACAGCACCACACCCAACAACCCA ;\nPattern p = Pattern.compile( A{1}C{2} );\nMatcher m = p.matcher(seq);\nint count = 0;\nwhile( m.find() ) count++;\nSystem.out.println( there are   + count +   ACC );  Examine the code example  Matching.java  for further details.", 
            "title": "Pattern matching"
        }, 
        {
            "location": "/string_string/#pattern-matching-in-computational-biology", 
            "text": "The DNA (the genetic blueprint) of any species is composed of about 4 billion ACGT nucleotides. DNA forms a double helix that has two strands of DNA binding and twisting together. In pattern matching problems we ignore the fact that DNA forms a double helix, and think of it only as a single strand. The other strand is complimentary. Knowing one strand allows uniquely determine the other one. Thus, DNA is essentially a linear molecule that looks like a string composed out of only four characters A, C, G, and T:  CGTATCCCACAGCACCACACCCAACAACCC  Each nucleotides (also called a base) strongly binds to no more than two other bases. These links provides a linear model of DNA strand. The particular order of ACGT nucleotides is extremely important. Different orders generate humans, animals, corn, and other organisms. The size of the genome (a genome is all the DNA in an organism) does not necessarily correlate with the complexity of the organism it belongs to. Humans have less than a third as many genes as were expected.  Pattern matching in computational biology arises from the need to know characteristics of DNA sequences, such as   find the best way to align two sequences.  find any common subsequences  determine how well a sequence fits into a given model.   Comparing various DNA sequencesn provide many uses. Current scientific theories suggest that very similar DNA sequences have a common ancestor. The more similar two sequences are, the more recently they evolved from a single ansestor. With such knowledge, for example, we can reconstruct a phylogenetic tree (known as a \"tree of life\".) that shows how long ago various organisms diverged and which species are closely related.", 
            "title": "Pattern matching in Computational Biology"
        }, 
        {
            "location": "/string_string/#challenges", 
            "text": "Strings: Making Anagrams", 
            "title": "Challenges"
        }, 
        {
            "location": "/string_string/#references", 
            "text": "\"Strings\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/string_tries/", 
            "text": "Introduction\n\n\nThere are many algorithms and data structures to index and search strings inside a text, some of them are included in the standard libraries, but not all of them; the trie data structure is a good example of one that isn\u2019t.\n\n\nLet word be a single string and let dictionary be a large set of words. If we have a dictionary, and we need to know if a single word is inside of the dictionary the tries are a data structure that can help us. But you may be asking yourself, \u201cWhy use tries if set \n and hash tables can do the same?\u201d\n\n\nThere are two main reasons:\n\n\n\n\n\n\nThe tries can insert and find strings in \n O(L) \n time (where L represent the length of a single word). This is much faster than set , but is it a bit faster than a hash table.\nThe set \n and the hash tables can only find in a dictionary words that match exactly with the single word that we are finding; the trie allow us to find words that have a single character different, a prefix in common, a character missing, etc.\n\n\n\n\n\n\nThe tries can be useful in TopCoder problems, but also have a great amount of applications in software engineering. For example, consider a web browser. Do you know how the web browser can auto complete your text or show you many possibilities of the text that you could be writing? Yes, with the trie you can do it very fast. Do you know how an orthographic corrector can check that every word that you type is in a dictionary? Again a trie. You can also use a trie for suggested corrections of the words that are present in the text but not in the dictionary.\n\n\n\n\n\n\nWhat is a Tree?\n\n\nYou may read about how wonderful the tries are, but maybe you don\u2019t know yet what the tries are and why the tries have this name. The word trie is an infix of the word \u201cretrieval\u201d because the trie can find a single word in a dictionary with only a prefix of the word. The main idea of the trie data structure consists of the following parts:\n\n\n\n\nThe trie is a tree where each vertex represents a single word or a prefix.\n\n\nThe root represents an empty string (\u201c\u201d), the vertexes that are direct sons of the root represent prefixes of length 1, the vertexes that are 2 edges of distance from the root represent prefixes of length 2, the vertexes that are 3 edges of distance from the root represent prefixes of length 3 and so on. In other words, a vertex that are k edges of distance of the root have an associated prefix of length k.\n\n\nLet v and w be two vertexes of the trie, and assume that v is a direct father of w, then v must have an associated prefix of w.\n\n\n\n\nThe next figure shows a trie with the words \u201ctree\u201d, \u201ctrie\u201d, \u201calgo\u201d, \u201cassoc\u201d, \u201call\u201d, and \u201calso.\u201d\n\n\n\n\n\n\n\n\n\nNote that every vertex of the tree does not store entire prefixes or entire words. The idea is that the program should remember the word that represents each vertex while lower in the tree.\n\n\nCoding a Trie\n\n\nThe tries can be implemented in many ways, some of them can be used to find a set of words in the dictionary where every word can be a little different than the target word, and other implementations of the tries can provide us with only words that match exactly with the target word. The implementation of the trie that will be exposed here will consist only of finding words that match exactly and counting the words that have some prefix. This implementation will be pseudo code because different coders can use different programming languages.\n\n\nWe will code these 4 functions:\n\n\n\n\naddWord\n. This function will add a single string word to the dictionary.\n\n\ncountPreffixes\n. This function will count the number of words in the dictionary that have a string prefix as prefix.\n\n\ncountWords\n. This function will count the number of words in the dictionary that match exactly with a given string word.\n\n\nOur trie will only support letters of the English alphabet.\n\n\n\n\nWe need to also code a structure with some fields that indicate the values stored in each vertex. As we want to know the number of words that match with a given string, every vertex should have a field to indicate that this vertex represents a complete word or only a prefix (for simplicity, a complete word is considered also a prefix) and how many words in the dictionary are represented by that prefix (there can be repeated words in the dictionary). This task can be done with only one integer field words.\n\n\nBecause we want to know the number of words that have like prefix a given string, we need another integer field prefixes that indicates how many words have the prefix of the vertex. Also, each vertex must have references to all his possible sons (26 references). Knowing all these details, our structure should have the following members:\n\n\nstructure Trie\n    integer words;\n    integer prefixes;\n    reference edges[26];\n\n\n\n\nAnd we also need the following functions:\n\n\ninitialize(vertex)\naddWord(vertex, word);\ninteger countPrefixes(vertex, prefix);\ninteger countWords(vertex, word);\n\n\n\n\nFirst of all, we have to initialize the vertexes with the following function:\n\n\ninitialize(vertex)\n    vertex.words=0\n    vertex.prefixes=0\n    for i=0 to 26\n        edges[i]=NoEdge\n\n\n\n\nThe addWord function consists of two parameters, the vertex of the insertion and the word that will be added. The idea is that when a string word is added to a vertex vertex, we will add word to the corresponding branch of vertex cutting the leftmost character of word. If the needed branch does not exist, we will have to create it. All the TopCoder languages can simulate the process of cutting a character in constant time instead of creating a copy of the original string or moving the other characters.\n\n\naddWord(vertex, word)\n    if isEmpty(word)\n        vertex.words=vertex.words+1\n    else\n        vertex.prefixes=vertex.prefixes+1\n        k=firstCharacter(word)\n        if(notExists(edges[k]))\n            edges[k]=createEdge()\n            initialize(edges[k])\n        cutLeftmostCharacter(word)\n        addWord(edges[k], word)\n\n\n\n\nThe functions countWords and countPrefixes are very similar. If we are finding an empty string we only have to return the number of words/prefixes associated with the vertex. If we are finding a non-empty string, we should to find in the corresponding branch of the tree, but if the branch does not exist, we have to return 0.\n\n\ncountWords(vertex, word)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.words\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(word)\n        return countWords(edges[k], word);\n\ncountPrefixes(vertex, prefix)\n    k=firstCharacter(prefix)\n    if isEmpty(word)\n        return vertex.prefixes\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(prefix)\n        return countWords(edges[k], prefix)\n\n\n\n\nComplexity Analysis\n\n\nIn the introduction you may read that the complexity of finding and inserting a trie is linear, but we have not done the analysis yet. In the insertion and finding notice that lowering a single level in the tree is done in constant time, and every time that the program lowers a single level in the tree, a single character is cut from the string; we can conclude that every function lowers L levels on the tree and every time that the function lowers a level on the tree, it is done in constant time, then the insertion and finding of a word in a trie can be done in O(L) time. The memory used in the tries depends on the methods to store the edges and how many words have prefixes in common.\n\n\nOther Kinds of Tries\n\n\nWe used the tries to store words with lowercase letters, but the tries can be used to store many other things. We can use bits or bytes instead of lowercase letters and every data type can be stored in the tree, not only strings. Let flow your imagination using tries! For example, suppose that you want to find a word in a dictionary but a single letter was deleted from the word. You can modify the countWords function:\n\n\ncountWords(vertex, word, missingLetters)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.word\n    else if notExists(edges[k]) and missingLetters=0\n        return 0\n    else if notExists(edges[k])\n        cutLeftmostCharacter(word)\n        return countWords(vertex, word, missingLetters-1)\n        Here we cut a character but we don't go lower in the tree\n    else\n        We are adding the two possibilities: the first\n        character has been deleted plus the first character is present\n        r=countWords(vertex, word, missingLetters-1)\n        cutLeftmostCharacter(word)\n        r=r+countWords(edges[k], word, missingLetters)\n        return r\n\n\n\n\nThe complexity of this function may be larger than the original, but it is faster than checking all the subsets of characters of a word.\n\n\nChallenges\n\n\n\n\n\"Tries: Contacts\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Using Tries \u2013 Topcoder\".\u00a0\nTopcoder.com\n. N.p., 2016. Web. 11 Oct. 2016.", 
            "title": "Tries"
        }, 
        {
            "location": "/string_tries/#introduction", 
            "text": "There are many algorithms and data structures to index and search strings inside a text, some of them are included in the standard libraries, but not all of them; the trie data structure is a good example of one that isn\u2019t.  Let word be a single string and let dictionary be a large set of words. If we have a dictionary, and we need to know if a single word is inside of the dictionary the tries are a data structure that can help us. But you may be asking yourself, \u201cWhy use tries if set   and hash tables can do the same?\u201d  There are two main reasons:    The tries can insert and find strings in   O(L)   time (where L represent the length of a single word). This is much faster than set , but is it a bit faster than a hash table.\nThe set   and the hash tables can only find in a dictionary words that match exactly with the single word that we are finding; the trie allow us to find words that have a single character different, a prefix in common, a character missing, etc.    The tries can be useful in TopCoder problems, but also have a great amount of applications in software engineering. For example, consider a web browser. Do you know how the web browser can auto complete your text or show you many possibilities of the text that you could be writing? Yes, with the trie you can do it very fast. Do you know how an orthographic corrector can check that every word that you type is in a dictionary? Again a trie. You can also use a trie for suggested corrections of the words that are present in the text but not in the dictionary.", 
            "title": "Introduction"
        }, 
        {
            "location": "/string_tries/#what-is-a-tree", 
            "text": "You may read about how wonderful the tries are, but maybe you don\u2019t know yet what the tries are and why the tries have this name. The word trie is an infix of the word \u201cretrieval\u201d because the trie can find a single word in a dictionary with only a prefix of the word. The main idea of the trie data structure consists of the following parts:   The trie is a tree where each vertex represents a single word or a prefix.  The root represents an empty string (\u201c\u201d), the vertexes that are direct sons of the root represent prefixes of length 1, the vertexes that are 2 edges of distance from the root represent prefixes of length 2, the vertexes that are 3 edges of distance from the root represent prefixes of length 3 and so on. In other words, a vertex that are k edges of distance of the root have an associated prefix of length k.  Let v and w be two vertexes of the trie, and assume that v is a direct father of w, then v must have an associated prefix of w.   The next figure shows a trie with the words \u201ctree\u201d, \u201ctrie\u201d, \u201calgo\u201d, \u201cassoc\u201d, \u201call\u201d, and \u201calso.\u201d     Note that every vertex of the tree does not store entire prefixes or entire words. The idea is that the program should remember the word that represents each vertex while lower in the tree.", 
            "title": "What is a Tree?"
        }, 
        {
            "location": "/string_tries/#coding-a-trie", 
            "text": "The tries can be implemented in many ways, some of them can be used to find a set of words in the dictionary where every word can be a little different than the target word, and other implementations of the tries can provide us with only words that match exactly with the target word. The implementation of the trie that will be exposed here will consist only of finding words that match exactly and counting the words that have some prefix. This implementation will be pseudo code because different coders can use different programming languages.  We will code these 4 functions:   addWord . This function will add a single string word to the dictionary.  countPreffixes . This function will count the number of words in the dictionary that have a string prefix as prefix.  countWords . This function will count the number of words in the dictionary that match exactly with a given string word.  Our trie will only support letters of the English alphabet.   We need to also code a structure with some fields that indicate the values stored in each vertex. As we want to know the number of words that match with a given string, every vertex should have a field to indicate that this vertex represents a complete word or only a prefix (for simplicity, a complete word is considered also a prefix) and how many words in the dictionary are represented by that prefix (there can be repeated words in the dictionary). This task can be done with only one integer field words.  Because we want to know the number of words that have like prefix a given string, we need another integer field prefixes that indicates how many words have the prefix of the vertex. Also, each vertex must have references to all his possible sons (26 references). Knowing all these details, our structure should have the following members:  structure Trie\n    integer words;\n    integer prefixes;\n    reference edges[26];  And we also need the following functions:  initialize(vertex)\naddWord(vertex, word);\ninteger countPrefixes(vertex, prefix);\ninteger countWords(vertex, word);  First of all, we have to initialize the vertexes with the following function:  initialize(vertex)\n    vertex.words=0\n    vertex.prefixes=0\n    for i=0 to 26\n        edges[i]=NoEdge  The addWord function consists of two parameters, the vertex of the insertion and the word that will be added. The idea is that when a string word is added to a vertex vertex, we will add word to the corresponding branch of vertex cutting the leftmost character of word. If the needed branch does not exist, we will have to create it. All the TopCoder languages can simulate the process of cutting a character in constant time instead of creating a copy of the original string or moving the other characters.  addWord(vertex, word)\n    if isEmpty(word)\n        vertex.words=vertex.words+1\n    else\n        vertex.prefixes=vertex.prefixes+1\n        k=firstCharacter(word)\n        if(notExists(edges[k]))\n            edges[k]=createEdge()\n            initialize(edges[k])\n        cutLeftmostCharacter(word)\n        addWord(edges[k], word)  The functions countWords and countPrefixes are very similar. If we are finding an empty string we only have to return the number of words/prefixes associated with the vertex. If we are finding a non-empty string, we should to find in the corresponding branch of the tree, but if the branch does not exist, we have to return 0.  countWords(vertex, word)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.words\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(word)\n        return countWords(edges[k], word);\n\ncountPrefixes(vertex, prefix)\n    k=firstCharacter(prefix)\n    if isEmpty(word)\n        return vertex.prefixes\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(prefix)\n        return countWords(edges[k], prefix)", 
            "title": "Coding a Trie"
        }, 
        {
            "location": "/string_tries/#complexity-analysis", 
            "text": "In the introduction you may read that the complexity of finding and inserting a trie is linear, but we have not done the analysis yet. In the insertion and finding notice that lowering a single level in the tree is done in constant time, and every time that the program lowers a single level in the tree, a single character is cut from the string; we can conclude that every function lowers L levels on the tree and every time that the function lowers a level on the tree, it is done in constant time, then the insertion and finding of a word in a trie can be done in O(L) time. The memory used in the tries depends on the methods to store the edges and how many words have prefixes in common.", 
            "title": "Complexity Analysis"
        }, 
        {
            "location": "/string_tries/#other-kinds-of-tries", 
            "text": "We used the tries to store words with lowercase letters, but the tries can be used to store many other things. We can use bits or bytes instead of lowercase letters and every data type can be stored in the tree, not only strings. Let flow your imagination using tries! For example, suppose that you want to find a word in a dictionary but a single letter was deleted from the word. You can modify the countWords function:  countWords(vertex, word, missingLetters)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.word\n    else if notExists(edges[k]) and missingLetters=0\n        return 0\n    else if notExists(edges[k])\n        cutLeftmostCharacter(word)\n        return countWords(vertex, word, missingLetters-1)\n        Here we cut a character but we don't go lower in the tree\n    else\n        We are adding the two possibilities: the first\n        character has been deleted plus the first character is present\n        r=countWords(vertex, word, missingLetters-1)\n        cutLeftmostCharacter(word)\n        r=r+countWords(edges[k], word, missingLetters)\n        return r  The complexity of this function may be larger than the original, but it is faster than checking all the subsets of characters of a word.", 
            "title": "Other Kinds of Tries"
        }, 
        {
            "location": "/string_tries/#challenges", 
            "text": "\"Tries: Contacts\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/string_tries/#references", 
            "text": "\"Using Tries \u2013 Topcoder\".\u00a0 Topcoder.com . N.p., 2016. Web. 11 Oct. 2016.", 
            "title": "References"
        }, 
        {
            "location": "/string_suffix_arrays_suffix_trees/", 
            "text": "Suffix tree\n\n\nA suffix tree \nT\n is a natural improvement over trie used in pattern matching problem, the one defined over a set of substrings of a string s. The idea is very simple here. Such a trie can have a long paths without branches. If we only can reduce these long paths into one jump, we will reduce the size of the trie significantly, so this is a great first step in improving the complexity of operations on such a tree. This reduced trie defined over a subset of suffixes of a string s is called a suffix tree of \ns\n\n\nFor better understanding, let's consider the suffix tree T for a string \ns = abakan\n. A word abakan has 6 suffixes \n{abakan , bakan, akan, kan, an, n}\n and its suffix tree looks like this:\n\n\n\n\nThere is a \nfamous algorithm by Ukkonen\n for building suffix tree for s in linear time in terms of the length of s. However, because it may look quite complicated at first sight, many people are discouraged to learn how it works. Fortunately, there is a great, I mean an excellent, \ndescription of Ukkonen's algorithm given on StackOverflow\n. Please refer to it for better understanding what a suffix tree is and how to build it in linear time.\n\n\nSuffix trees can solve many complicated problems, because it contain so many information about the string itself. Fo example, in order to know how many times a pattern \nP\n occurs in \ns\n, it is sufficient to find \nP\n in \nT\n and return the size of a subtree corresponding to its node. Another well known application is finding the number of distinct substrings of s, and it can be solved easily with suffix tree, while the problem looks very complicated at first sight.\n\n\nThe post I linked from StackOverflow is so great, that you simple must read it. After that, you will be able to identify problems solvable with suffix trees easily.\n\n\nIf you want to know more about when to use a suffix tree, you should read this paper about the \napplications of suffix trees\n.\n\n\nSuffix Array\n\n\nSuffix array is a very nice array based structure. Basically, it is a lexicographically sorted array of suffixes of a string s. For example, let's consider a string \ns = abakan\n. A word abakan has 6 suffixes \n{abakan , bakan, akan, kan, an, n}\n and its suffix tree looks like this:\n\n\n\n\nOf course, in order to reduce space, we do not store the exact suffixes. It is sufficient to store their indices.\n\n\nSuffix arrays, especially combined with \nLCP table\n (which stands for Longest Common Prefix of neighboring suffixes table), are very very useful for solving many problems. I recommend reading this nice \nprogramming oriented paper about suffix arrays, their applications and related problems\n by Stanford University.\n\n\nSuffix arrays can be build easily in \nO(n * log^2 n)\n time, where n is the length of s, using the algorithm proposed in the paper from the previous paragraph. This time can be improved to \nO(n * log n)\n using linear time sorting algorithm.\n\n\nHowever, there is so extraordinary, cool and simple linear time algorithm for building suffix arrays by K\u00e4rkk\u00e4inen and Sanders, that reading it is a pure pleasure and you cannot miss it.\n\n\nCorrespondence between suffix tree and suffix array\n\n\nIt is also worth to mention, that a suffix array can be constructed directly from a suffix tree in linear time using DFS traversal. Suffix tree can be also constructed from the suffix array and LCP table as described here.", 
            "title": "Suffix Arrays and Suffix Trees"
        }, 
        {
            "location": "/string_suffix_arrays_suffix_trees/#suffix-tree", 
            "text": "A suffix tree  T  is a natural improvement over trie used in pattern matching problem, the one defined over a set of substrings of a string s. The idea is very simple here. Such a trie can have a long paths without branches. If we only can reduce these long paths into one jump, we will reduce the size of the trie significantly, so this is a great first step in improving the complexity of operations on such a tree. This reduced trie defined over a subset of suffixes of a string s is called a suffix tree of  s  For better understanding, let's consider the suffix tree T for a string  s = abakan . A word abakan has 6 suffixes  {abakan , bakan, akan, kan, an, n}  and its suffix tree looks like this:   There is a  famous algorithm by Ukkonen  for building suffix tree for s in linear time in terms of the length of s. However, because it may look quite complicated at first sight, many people are discouraged to learn how it works. Fortunately, there is a great, I mean an excellent,  description of Ukkonen's algorithm given on StackOverflow . Please refer to it for better understanding what a suffix tree is and how to build it in linear time.  Suffix trees can solve many complicated problems, because it contain so many information about the string itself. Fo example, in order to know how many times a pattern  P  occurs in  s , it is sufficient to find  P  in  T  and return the size of a subtree corresponding to its node. Another well known application is finding the number of distinct substrings of s, and it can be solved easily with suffix tree, while the problem looks very complicated at first sight.  The post I linked from StackOverflow is so great, that you simple must read it. After that, you will be able to identify problems solvable with suffix trees easily.  If you want to know more about when to use a suffix tree, you should read this paper about the  applications of suffix trees .", 
            "title": "Suffix tree"
        }, 
        {
            "location": "/string_suffix_arrays_suffix_trees/#suffix-array", 
            "text": "Suffix array is a very nice array based structure. Basically, it is a lexicographically sorted array of suffixes of a string s. For example, let's consider a string  s = abakan . A word abakan has 6 suffixes  {abakan , bakan, akan, kan, an, n}  and its suffix tree looks like this:   Of course, in order to reduce space, we do not store the exact suffixes. It is sufficient to store their indices.  Suffix arrays, especially combined with  LCP table  (which stands for Longest Common Prefix of neighboring suffixes table), are very very useful for solving many problems. I recommend reading this nice  programming oriented paper about suffix arrays, their applications and related problems  by Stanford University.  Suffix arrays can be build easily in  O(n * log^2 n)  time, where n is the length of s, using the algorithm proposed in the paper from the previous paragraph. This time can be improved to  O(n * log n)  using linear time sorting algorithm.  However, there is so extraordinary, cool and simple linear time algorithm for building suffix arrays by K\u00e4rkk\u00e4inen and Sanders, that reading it is a pure pleasure and you cannot miss it.  Correspondence between suffix tree and suffix array  It is also worth to mention, that a suffix array can be constructed directly from a suffix tree in linear time using DFS traversal. Suffix tree can be also constructed from the suffix array and LCP table as described here.", 
            "title": "Suffix Array"
        }, 
        {
            "location": "/string_kmp/", 
            "text": "Knuth-Morris-Pratt Algorithm\n\n\nThe problem:\n\n\n\n\ngiven a (short) pattern and a (long) text, both strings, determine whether the pattern appears somewhere in the text.\n\n\n\n\nWe'll go through the Knuth-Morris-Pratt (KMP) algorithm, which can be thought of as an efficient way to build these automata. I also have some working \nC++ source code\n which might help you understand the algorithm better.\n\n\nFirst let's look at a naive solution.\n\n\n\n\nsuppose the text is in an array: char \nT[n]\n\n\n\n\nand the pattern is in another array: char \nP[m]\n.\n\n\n\n\nOne simple method is just to try each possible position the pattern could appear in the text.\n\n\nNaive string matching:\n\n\nfor (i=0; T[i] != '\\0'; i++)\n{\n    for (j=0; T[i+j] != '\\0' \n P[j] != '\\0' \n T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match\n}\n\n\n\n\nThere are two nested loops; the inner one takes O(m) iterations and the outer one takes O(n) iterations so the total time is the product, O(mn). This is slow; we'd like to speed it up.\n\n\nIn practice this works pretty well -- not usually as bad as this O(mn) worst case analysis. This is because the inner loop usually finds a mismatch quickly and move on to the next position without going through all m steps. But this method still can take O(mn) for some inputs. In one bad example, all characters in T[] are \"a\"s, and P[] is all \"a\"'s except for one \"b\" at the end. Then it takes m comparisons each time to discover that you don't have a match, so mn overall.\n\n\nHere's a more typical example. Each row represents an iteration of the outer loop, with each character in the row representing the result of a comparison (X if the comparison was unequal). Suppose we're looking for pattern \"nano\" in text \"banananobano\".\n\n\n 0  1  2  3  4  5  6  7  8  9 10 11\n  T: b  a  n  a  n  a  n  o  b  a  n  o\n\ni=0: X\ni=1:    X\ni=2:       n  a  n  X\ni=3:          X\ni=4:             n  a  n  o\ni=5:                X\ni=6:                   n  X\ni=7:                         X\ni=8:                            X\ni=9:                               n  X\ni=10:                                 X\n\n\n\n\n\nSome of these comparisons are wasted work! For instance, after iteration i=2, we know from the comparisons we've done that T[3]=\"a\", so there is no point comparing it to \"n\" in iteration i=3. And we also know that T[4]=\"n\", so there is no point making the same comparison in iteration i=4.\n\n\nSkipping outer iterations\n\n\nThe Knuth-Morris-Pratt idea is, in this sort of situation, after you've invested a lot of work making comparisons in the inner loop of the code, you know a lot about what's in the text. Specifically, if you've found a partial match of j characters starting at position i, you know what's in positions T[i]...T[i+j-1].\nYou can use this knowledge to save work in two ways. First, you can skip some iterations for which no match is possible. Try overlapping the partial match you've found with the new match you want to find:\n\n\n    i=2: n  a  n\n    i=3:    n  a  n  o\n\n\n\n\nHere the two placements of the pattern conflict with each other -- we know from the i=2 iteration that T[3] and T[4] are \"a\" and \"n\", so they can't be the \"n\" and \"a\" that the i=3 iteration is looking for. We can keep skipping positions until we find one that doesn't conflict:\n\n\n    i=2: n  a  n\n    i=4:       n  a  n  o\n\n\n\n\nHere the two \"n\"'s coincide. Define the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. Here the overlap of \"nan\" and \"nano\" is just \"n\". (We don't allow the overlap to be all of x or y, so it's not \"nan\"). In general the value of i we want to skip to is the one corresponding to the largest overlap with the current partial match:\n\n\nString matching with skipped iterations:\n\n\n    i=0;\n    while (i\nn)\n    {\n    for (j=0; T[i+j] != '\\0' \n P[j] != '\\0' \n T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match;\n    i = i + max(1, j-overlap(P[0..j-1],P[0..m]));\n    }\n\n\n\n\nSkipping inner iterations\n\n\nThe other optimization that can be done is to skip some iterations in the inner loop. Let's look at the same example, in which we skipped from i=2 to i=4:\n\n\n    i=2: n  a  n\n    i=4:       n  a  n  o\n\n\n\n\nIn this example, the \"n\" that overlaps has already been tested by the i=2 iteration. There's no need to test it again in the i=4 iteration. In general, if we have a nontrivial overlap with the last partial match, we can avoid testing a number of characters equal to the length of the overlap.\nThis change produces (a version of) the KMP algorithm:\n\n\nKMP, version 1:\n\n\n    i=0;\n    o=0;\n    while (i\nn)\n    {\n    for (j=o; T[i+j] != '\\0' \n P[j] != '\\0' \n T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match;\n    o = overlap(P[0..j-1],P[0..m]);\n    i = i + max(1, j-o);\n    }\n\n\n\n\nThe only remaining detail is how to compute the overlap function. This is a function only of j, and not of the characters in T[], so we can compute it once in a preprocessing stage before we get to this part of the algorithm. First let's see how fast this algorithm is.\n\n\nKMP time analysis\n\n\nWe still have an outer loop and an inner loop, so it looks like the time might still be O(mn). But we can count it a different way to see that it's actually always less than that. The idea is that every time through the inner loop, we do one comparison T[i+j]==P[j]. We can count the total time of the algorithm by counting how many comparisons we perform.\nWe split the comparisons into two groups: those that return true, and those that return false. If a comparison returns true, we've determined the value of T[i+j]. Then in future iterations, as long as there is a nontrivial overlap involving T[i+j], we'll skip past that overlap and not make a comparison with that position again. So each position of T[] is only involved in one true comparison, and there can be n such comparisons total. On the other hand, there is at most one false comparison per iteration of the outer loop, so there can also only be n of those. As a result we see that this part of the KMP algorithm makes at most 2n comparisons and takes time O(n).\n\n\nKMP and finite automata\n\n\nIf we look just at what happens to j during the algorithm above, it's sort of like a finite automaton. At each step j is set either to j+1 (in the inner loop, after a match) or to the overlap o (after a mismatch). At each step the value of o is just a function of j and doesn't depend on other information like the characters in T[]. So we can draw something like an automaton, with arrows connecting values of j and labeled with matches and mismatches.\n\n\n\n\nThe difference between this and the automata we are used to is that it has only two arrows out of each circle, instead of one per character. But we can still simulate it just like any other automaton, by placing a marker on the start state (j=0) and moving it around the arrows. Whenever we get a matching character in T[] we move on to the next character of the text. But whenever we get a mismatch we look at the same character in the next step, except for the case of a mismatch in the state j=0.\n\n\nSo in this example (the same as the one above) the automaton goes through the sequence of states:\n\n\n    j=0\n            mismatch T[0] != \nn\n\n    j=0\n            mismatch T[1] != \nn\n\n    j=0\n            match T[2] == \nn\n\n    j=1\n            match T[3] == \na\n\n    j=2\n            match T[4] == \nn\n\n    j=3\n            mismatch T[5] != \no\n\n    j=1\n            match T[5] == \na\n\n    j=2\n            match T[6] == \nn\n\n    j=3\n            match T[7] == \no\n\n    j=4\n            found match\n    j=0\n            mismatch T[8] != \nn\n\n    j=0\n            mismatch T[9] != \nn\n\n    j=0\n            match T[10] == \nn\n\n    j=1\n            mismatch T[11] != \na\n\n    j=0\n            mismatch T[11] != \nn\n\n\n\n\n\nThis is essentially the same sequence of comparisons done by the KMP pseudocode above. So this automaton provides an equivalent definition of the KMP algorithm.\nAs one student pointed out in lecture, the one transition in this automaton that may not be clear is the one from j=4 to j=0. In general, there should be a transition from j=m to some smaller value of j, which should happen on any character (there are no more matches to test before making this transition). If we want to find all occurrences of the pattern, we should be able to find an occurrence even if it overlaps another one. So for instance if the pattern were \"nana\", we should find both occurrences of it in the text \"nanana\". So the transition from j=m should go to the next longest position that can match, which is simply j=overlap(pattern,pattern). In this case overlap(\"nano\",\"nano\") is empty (all suffixes of \"nano\" use the letter \"o\", and no prefix does) so we go to j=0.\n\n\nAlternate version of KMP\n\n\nThe automaton above can be translated back into pseudo-code, looking a little different from the pseudo-code we saw before but performing the same comparisons.\n\n\nKMP, version 2:\n\n\n    j = 0;\n    for (i = 0; i \n n; i++)\n    for (;;) {      // loop until break\n        if (T[i] == P[j]) { // matches?\n        j++;        // yes, move on to next state\n        if (j == m) {   // maybe that was the last state\n            found a match;\n            j = overlap[j];\n        }\n        break;\n        } else if (j == 0) break;   // no match in state j=0, give up\n        else j = overlap[j];    // try shorter partial match\n    }\n\n\n\n\nThe code inside each iteration of the outer loop is essentially the same as the function match from the C++ implementation I've made available. One advantage of this version of the code is that it tests characters one by one, rather than performing random access in the T[] array, so (as in the implementation) it can be made to work for stream-based input rather than having to read the whole text into memory first.\nThe overlap[j] array stores the values of overlap(pattern[0..j-1],pattern), which we still need to show how to compute.\n\n\nSince this algorithm performs the same comparisons as the other version of KMP, it takes the same amount of time, O(n). One way of proving this bound directly is to note, first, that there is one true comparison (in which T[i]==P[j]) per iteration of the outer loop, since we break out of the inner loop when this happens. So there are n of these total. Each of these comparisons results in increasing j by one. Each iteration of the inner loop in which we don't break out of the loop results in executing the statement j=overlap[j], which decreases j. Since j can only decrease as many times as it's increased, the total number of times this happens is also O(n).\n\n\nComputing the overlap function\n\n\nRecall that we defined the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. The missing component of the KMP algorithm is a computation of this overlap function: we need to know overlap(P[0..j-1],P) for each value of j\n0. Once we've computed these values we can store them in an array and look them up when we need them.\nTo compute these overlap functions, we need to know for strings x and y not just the longest word that's a suffix of x and a prefix of y, but all such words. The key fact to notice here is that if w is a suffix of x and a prefix of y, and it's not the longest such word, then it's also a suffix of overlap(x,y). (This follows simply from the fact that it's a suffix of x that is shorter than overlap(x,y) itself.) So we can list all words that are suffixes of x and prefixes of y by the following loop:\n\n\n    while (x != empty) {\n    x = overlap(x,y);\n    output x;\n    }\n\n\n\n\nNow let's make another definition: say that shorten(x) is the prefix of x with one fewer character. The next simple observation to make is that shorten(overlap(x,y)) is still a prefix of y, but is also a suffix of shorten(x).\nSo we can find overlap(x,y) by adding one more character to some word that's a suffix of shorten(x) and a prefix of y. We can just find all such words using the loop above, and return the first one for which adding one more character produces a valid overlap:\n\n\nOverlap computation:\n\n\n    z = overlap(shorten(x),y)\n    while (last char of x != y[length(z)])\n    {\n    if (z = empty) return overlap(x,y) = empty\n    else z = overlap(z,y)\n    }\n    return overlap(x,y) = z\n\n\n\n\nSo this gives us a recursive algorithm for computing the overlap function in general. If we apply this algorithm for x=some prefix of the pattern, and y=the pattern itself, we see that all recursive calls have similar arguments. So if we store each value as we compute it, we can look it up instead of computing it again. (This simple idea of storing results instead of recomputing them is known as dynamic programming; we discussed it somewhat in the first lecture and will see it in more detail next time.)\nSo replacing x by P[0..j-1] and y by P[0..m-1] in the pseudocode above and replacing recursive calls by lookups of previously computed values gives us a routine for the problem we're trying to solve, of computing these particular overlap values. The following pseudocode is taken (with some names changed) from the initialization code of the C++ implementation I've made available. The value in overlap[0] is just a flag to make the rest of the loop simpler. The code inside the for loop is the part that computes each overlap value.\n\n\nKMP overlap computation:\n\n\n    overlap[0] = -1;\n    for (int i = 0; pattern[i] != '\\0'; i++) {\n    overlap[i + 1] = overlap[i] + 1;\n    while (overlap[i + 1] \n 0 \n\n           pattern[i] != pattern[overlap[i + 1] - 1])\n        overlap[i + 1] = overlap[overlap[i + 1] - 1] + 1;\n    }\n    return overlap;\n\n\n\n\nLet's finish by analyzing the time taken by this part of the KMP algorithm. The outer loop executes m times. Each iteration of the inner loop decreases the value of the formula overlap[i+1], and this formula's value only increases by one when we move from one iteration of the outer loop to the next. Since the number of decreases is at most the number of increases, the inner loop also has at most m iterations, and the total time for the algorithm is O(m).\nThe entire KMP algorithm consists of this overlap computation followed by the main part of the algorithm in which we scan the text (using the overlap values to speed up the scan). The first part takes O(m) and the second part takes O(n) time, so the total time is O(m+n).", 
            "title": "Knuth\u2013Morris\u2013Pratt Algorithm"
        }, 
        {
            "location": "/string_kmp/#knuth-morris-pratt-algorithm", 
            "text": "The problem:   given a (short) pattern and a (long) text, both strings, determine whether the pattern appears somewhere in the text.   We'll go through the Knuth-Morris-Pratt (KMP) algorithm, which can be thought of as an efficient way to build these automata. I also have some working  C++ source code  which might help you understand the algorithm better.  First let's look at a naive solution.   suppose the text is in an array: char  T[n]   and the pattern is in another array: char  P[m] .   One simple method is just to try each possible position the pattern could appear in the text.  Naive string matching:  for (i=0; T[i] != '\\0'; i++)\n{\n    for (j=0; T[i+j] != '\\0'   P[j] != '\\0'   T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match\n}  There are two nested loops; the inner one takes O(m) iterations and the outer one takes O(n) iterations so the total time is the product, O(mn). This is slow; we'd like to speed it up.  In practice this works pretty well -- not usually as bad as this O(mn) worst case analysis. This is because the inner loop usually finds a mismatch quickly and move on to the next position without going through all m steps. But this method still can take O(mn) for some inputs. In one bad example, all characters in T[] are \"a\"s, and P[] is all \"a\"'s except for one \"b\" at the end. Then it takes m comparisons each time to discover that you don't have a match, so mn overall.  Here's a more typical example. Each row represents an iteration of the outer loop, with each character in the row representing the result of a comparison (X if the comparison was unequal). Suppose we're looking for pattern \"nano\" in text \"banananobano\".   0  1  2  3  4  5  6  7  8  9 10 11\n  T: b  a  n  a  n  a  n  o  b  a  n  o\n\ni=0: X\ni=1:    X\ni=2:       n  a  n  X\ni=3:          X\ni=4:             n  a  n  o\ni=5:                X\ni=6:                   n  X\ni=7:                         X\ni=8:                            X\ni=9:                               n  X\ni=10:                                 X  Some of these comparisons are wasted work! For instance, after iteration i=2, we know from the comparisons we've done that T[3]=\"a\", so there is no point comparing it to \"n\" in iteration i=3. And we also know that T[4]=\"n\", so there is no point making the same comparison in iteration i=4.", 
            "title": "Knuth-Morris-Pratt Algorithm"
        }, 
        {
            "location": "/string_kmp/#skipping-outer-iterations", 
            "text": "The Knuth-Morris-Pratt idea is, in this sort of situation, after you've invested a lot of work making comparisons in the inner loop of the code, you know a lot about what's in the text. Specifically, if you've found a partial match of j characters starting at position i, you know what's in positions T[i]...T[i+j-1].\nYou can use this knowledge to save work in two ways. First, you can skip some iterations for which no match is possible. Try overlapping the partial match you've found with the new match you want to find:      i=2: n  a  n\n    i=3:    n  a  n  o  Here the two placements of the pattern conflict with each other -- we know from the i=2 iteration that T[3] and T[4] are \"a\" and \"n\", so they can't be the \"n\" and \"a\" that the i=3 iteration is looking for. We can keep skipping positions until we find one that doesn't conflict:      i=2: n  a  n\n    i=4:       n  a  n  o  Here the two \"n\"'s coincide. Define the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. Here the overlap of \"nan\" and \"nano\" is just \"n\". (We don't allow the overlap to be all of x or y, so it's not \"nan\"). In general the value of i we want to skip to is the one corresponding to the largest overlap with the current partial match:  String matching with skipped iterations:      i=0;\n    while (i n)\n    {\n    for (j=0; T[i+j] != '\\0'   P[j] != '\\0'   T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match;\n    i = i + max(1, j-overlap(P[0..j-1],P[0..m]));\n    }", 
            "title": "Skipping outer iterations"
        }, 
        {
            "location": "/string_kmp/#skipping-inner-iterations", 
            "text": "The other optimization that can be done is to skip some iterations in the inner loop. Let's look at the same example, in which we skipped from i=2 to i=4:      i=2: n  a  n\n    i=4:       n  a  n  o  In this example, the \"n\" that overlaps has already been tested by the i=2 iteration. There's no need to test it again in the i=4 iteration. In general, if we have a nontrivial overlap with the last partial match, we can avoid testing a number of characters equal to the length of the overlap.\nThis change produces (a version of) the KMP algorithm:  KMP, version 1:      i=0;\n    o=0;\n    while (i n)\n    {\n    for (j=o; T[i+j] != '\\0'   P[j] != '\\0'   T[i+j]==P[j]; j++) ;\n    if (P[j] == '\\0') found a match;\n    o = overlap(P[0..j-1],P[0..m]);\n    i = i + max(1, j-o);\n    }  The only remaining detail is how to compute the overlap function. This is a function only of j, and not of the characters in T[], so we can compute it once in a preprocessing stage before we get to this part of the algorithm. First let's see how fast this algorithm is.", 
            "title": "Skipping inner iterations"
        }, 
        {
            "location": "/string_kmp/#kmp-time-analysis", 
            "text": "We still have an outer loop and an inner loop, so it looks like the time might still be O(mn). But we can count it a different way to see that it's actually always less than that. The idea is that every time through the inner loop, we do one comparison T[i+j]==P[j]. We can count the total time of the algorithm by counting how many comparisons we perform.\nWe split the comparisons into two groups: those that return true, and those that return false. If a comparison returns true, we've determined the value of T[i+j]. Then in future iterations, as long as there is a nontrivial overlap involving T[i+j], we'll skip past that overlap and not make a comparison with that position again. So each position of T[] is only involved in one true comparison, and there can be n such comparisons total. On the other hand, there is at most one false comparison per iteration of the outer loop, so there can also only be n of those. As a result we see that this part of the KMP algorithm makes at most 2n comparisons and takes time O(n).", 
            "title": "KMP time analysis"
        }, 
        {
            "location": "/string_kmp/#kmp-and-finite-automata", 
            "text": "If we look just at what happens to j during the algorithm above, it's sort of like a finite automaton. At each step j is set either to j+1 (in the inner loop, after a match) or to the overlap o (after a mismatch). At each step the value of o is just a function of j and doesn't depend on other information like the characters in T[]. So we can draw something like an automaton, with arrows connecting values of j and labeled with matches and mismatches.   The difference between this and the automata we are used to is that it has only two arrows out of each circle, instead of one per character. But we can still simulate it just like any other automaton, by placing a marker on the start state (j=0) and moving it around the arrows. Whenever we get a matching character in T[] we move on to the next character of the text. But whenever we get a mismatch we look at the same character in the next step, except for the case of a mismatch in the state j=0.  So in this example (the same as the one above) the automaton goes through the sequence of states:      j=0\n            mismatch T[0] !=  n \n    j=0\n            mismatch T[1] !=  n \n    j=0\n            match T[2] ==  n \n    j=1\n            match T[3] ==  a \n    j=2\n            match T[4] ==  n \n    j=3\n            mismatch T[5] !=  o \n    j=1\n            match T[5] ==  a \n    j=2\n            match T[6] ==  n \n    j=3\n            match T[7] ==  o \n    j=4\n            found match\n    j=0\n            mismatch T[8] !=  n \n    j=0\n            mismatch T[9] !=  n \n    j=0\n            match T[10] ==  n \n    j=1\n            mismatch T[11] !=  a \n    j=0\n            mismatch T[11] !=  n   This is essentially the same sequence of comparisons done by the KMP pseudocode above. So this automaton provides an equivalent definition of the KMP algorithm.\nAs one student pointed out in lecture, the one transition in this automaton that may not be clear is the one from j=4 to j=0. In general, there should be a transition from j=m to some smaller value of j, which should happen on any character (there are no more matches to test before making this transition). If we want to find all occurrences of the pattern, we should be able to find an occurrence even if it overlaps another one. So for instance if the pattern were \"nana\", we should find both occurrences of it in the text \"nanana\". So the transition from j=m should go to the next longest position that can match, which is simply j=overlap(pattern,pattern). In this case overlap(\"nano\",\"nano\") is empty (all suffixes of \"nano\" use the letter \"o\", and no prefix does) so we go to j=0.", 
            "title": "KMP and finite automata"
        }, 
        {
            "location": "/string_kmp/#alternate-version-of-kmp", 
            "text": "The automaton above can be translated back into pseudo-code, looking a little different from the pseudo-code we saw before but performing the same comparisons.  KMP, version 2:      j = 0;\n    for (i = 0; i   n; i++)\n    for (;;) {      // loop until break\n        if (T[i] == P[j]) { // matches?\n        j++;        // yes, move on to next state\n        if (j == m) {   // maybe that was the last state\n            found a match;\n            j = overlap[j];\n        }\n        break;\n        } else if (j == 0) break;   // no match in state j=0, give up\n        else j = overlap[j];    // try shorter partial match\n    }  The code inside each iteration of the outer loop is essentially the same as the function match from the C++ implementation I've made available. One advantage of this version of the code is that it tests characters one by one, rather than performing random access in the T[] array, so (as in the implementation) it can be made to work for stream-based input rather than having to read the whole text into memory first.\nThe overlap[j] array stores the values of overlap(pattern[0..j-1],pattern), which we still need to show how to compute.  Since this algorithm performs the same comparisons as the other version of KMP, it takes the same amount of time, O(n). One way of proving this bound directly is to note, first, that there is one true comparison (in which T[i]==P[j]) per iteration of the outer loop, since we break out of the inner loop when this happens. So there are n of these total. Each of these comparisons results in increasing j by one. Each iteration of the inner loop in which we don't break out of the loop results in executing the statement j=overlap[j], which decreases j. Since j can only decrease as many times as it's increased, the total number of times this happens is also O(n).", 
            "title": "Alternate version of KMP"
        }, 
        {
            "location": "/string_kmp/#computing-the-overlap-function", 
            "text": "Recall that we defined the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. The missing component of the KMP algorithm is a computation of this overlap function: we need to know overlap(P[0..j-1],P) for each value of j 0. Once we've computed these values we can store them in an array and look them up when we need them.\nTo compute these overlap functions, we need to know for strings x and y not just the longest word that's a suffix of x and a prefix of y, but all such words. The key fact to notice here is that if w is a suffix of x and a prefix of y, and it's not the longest such word, then it's also a suffix of overlap(x,y). (This follows simply from the fact that it's a suffix of x that is shorter than overlap(x,y) itself.) So we can list all words that are suffixes of x and prefixes of y by the following loop:      while (x != empty) {\n    x = overlap(x,y);\n    output x;\n    }  Now let's make another definition: say that shorten(x) is the prefix of x with one fewer character. The next simple observation to make is that shorten(overlap(x,y)) is still a prefix of y, but is also a suffix of shorten(x).\nSo we can find overlap(x,y) by adding one more character to some word that's a suffix of shorten(x) and a prefix of y. We can just find all such words using the loop above, and return the first one for which adding one more character produces a valid overlap:  Overlap computation:      z = overlap(shorten(x),y)\n    while (last char of x != y[length(z)])\n    {\n    if (z = empty) return overlap(x,y) = empty\n    else z = overlap(z,y)\n    }\n    return overlap(x,y) = z  So this gives us a recursive algorithm for computing the overlap function in general. If we apply this algorithm for x=some prefix of the pattern, and y=the pattern itself, we see that all recursive calls have similar arguments. So if we store each value as we compute it, we can look it up instead of computing it again. (This simple idea of storing results instead of recomputing them is known as dynamic programming; we discussed it somewhat in the first lecture and will see it in more detail next time.)\nSo replacing x by P[0..j-1] and y by P[0..m-1] in the pseudocode above and replacing recursive calls by lookups of previously computed values gives us a routine for the problem we're trying to solve, of computing these particular overlap values. The following pseudocode is taken (with some names changed) from the initialization code of the C++ implementation I've made available. The value in overlap[0] is just a flag to make the rest of the loop simpler. The code inside the for loop is the part that computes each overlap value.  KMP overlap computation:      overlap[0] = -1;\n    for (int i = 0; pattern[i] != '\\0'; i++) {\n    overlap[i + 1] = overlap[i] + 1;\n    while (overlap[i + 1]   0  \n           pattern[i] != pattern[overlap[i + 1] - 1])\n        overlap[i + 1] = overlap[overlap[i + 1] - 1] + 1;\n    }\n    return overlap;  Let's finish by analyzing the time taken by this part of the KMP algorithm. The outer loop executes m times. Each iteration of the inner loop decreases the value of the formula overlap[i+1], and this formula's value only increases by one when we move from one iteration of the outer loop to the next. Since the number of decreases is at most the number of increases, the inner loop also has at most m iterations, and the total time for the algorithm is O(m).\nThe entire KMP algorithm consists of this overlap computation followed by the main part of the algorithm in which we scan the text (using the overlap values to speed up the scan). The first part takes O(m) and the second part takes O(n) time, so the total time is O(m+n).", 
            "title": "Computing the overlap function"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Complete coloring"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Clique cover problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Knapsack problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Bin packing problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Closest string"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Longest common subsequence problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Flows in Networks"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nArrays\n\n\nLinked List\n\n\nStacks \n Queues\n\n\nTrees\n\n\nBinary Search Trees\n\n\nHeaps\n\n\n\n\nSort\n\n\n\n\nSorting Algorithms\n\n\nBubble Sort\n\n\nInsertion Sort\n\n\nSelection Sorts\n\n\nMerge Sort\n\n\nShell Sort\n\n\nQuick Sort\n\n\n\n\nSearch\n\n\n\n\nLinear Search\n\n\nBinary Search\n\n\nInterpolation Search\n\n\nHash Tables\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nGraph Data Structure\n\n\nDFS: Depth First Traversal\n\n\nBFS: Breadth First Traversal\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nIntroduction to Strings\n\n\nTries\n\n\nSuffix Arrays and Suffix Trees\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Linear Programming"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Arrays  Linked List  Stacks   Queues  Trees  Binary Search Trees  Heaps", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#sort", 
            "text": "Sorting Algorithms  Bubble Sort  Insertion Sort  Selection Sorts  Merge Sort  Shell Sort  Quick Sort", 
            "title": "Sort"
        }, 
        {
            "location": "/#search", 
            "text": "Linear Search  Binary Search  Interpolation Search  Hash Tables", 
            "title": "Search"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Graph Data Structure  DFS: Depth First Traversal  BFS: Breadth First Traversal", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Introduction to Strings  Tries  Suffix Arrays and Suffix Trees  Knuth\u2013Morris\u2013Pratt Algorithm", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }
    ]
}