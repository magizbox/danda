{
    "docs": [
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Home"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Introduction"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Greedy Algorithms"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Divide-and-Conquer"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Dynamic Programming"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/7_steps/", 
            "text": "7 Steps to Solve Algorithm Problems\n\n\nToday, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of \nCracking the Coding Interview\n book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.\n\n\nStep 1: Listen carefully\n\n\nThe first step you will take is listen (read) your problem carefully.\n\n\nStep 2: Example\n\n\nExample (make example big, no special cases)\n\n\nStep 3: Brute force\n\n\n(better to have a brute force than nothing at all.\n\n\nBecause\n\n\n\n\ncheck that you understand the problem, shows you're at least good enough to get that\n\n\nit's good place to optimize from\n\n\n\n\nStep 4: Optimize\n\n\nStep 5: Walk through your algorithms\n\n\nknow exactly what you're going to do before coding\n\n\n\n\nwhat variables \n data structures?\n\n\nhow, why, why do they change?\n\n\nwhat is the structure of your code\n\n\n\n\nStep 6: Code\n\n\nWhiteboard: write straight, use space wisely\n\n\nWhiteboard or computer\n\n\n\n\n\n\ncoding style matters (consistent braces, consistent variable naming, consistence spaces, descriptive variables)\n\n\n\n\n\n\nmodularize (before. not after)\n\n\n\n\n\n\nStep 7: Test\n\n\nAnalyse: think about each line, double check things that look weired/risky (for-loop that decrement, math) - Use test cases (smalle test-cases first (faster to run, you will problably be more thoroguht, edge cases, big tes cases)\n\n\nREMEMBER:\n\n think as you test (don't be a bot)\n\n test your code, not your algorithm\n* think before you fix bugs. Don't panic! (wrong fixes are worse than no fix)\n\n\nSuggested Reading\n\n\n\n\nhttps://www.youtube.com/watch?v=GKgAVjJxh9w\nlist=PLM0_NsFSjrgC72cExkBI4Iz99SBTzYG-u\nindex=4", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#7-steps-to-solve-algorithm-problems", 
            "text": "Today, I viewed the video \"7 Steps to Solve Algorithm Problems\" by Gayle Laakmann McDowell - the author of  Cracking the Coding Interview  book. In this video, Gayle describe her method for solve algorithms problems which consists 7 steps: listen carefully, example, brute force, optimize, walk through your algorithms, code and test. In this article, I will summary these steps base on what I learned from this video.", 
            "title": "7 Steps to Solve Algorithm Problems"
        }, 
        {
            "location": "/7_steps/#step-1-listen-carefully", 
            "text": "The first step you will take is listen (read) your problem carefully.", 
            "title": "Step 1: Listen carefully"
        }, 
        {
            "location": "/7_steps/#step-2-example", 
            "text": "Example (make example big, no special cases)", 
            "title": "Step 2: Example"
        }, 
        {
            "location": "/7_steps/#step-3-brute-force", 
            "text": "(better to have a brute force than nothing at all.  Because   check that you understand the problem, shows you're at least good enough to get that  it's good place to optimize from", 
            "title": "Step 3: Brute force"
        }, 
        {
            "location": "/7_steps/#step-4-optimize", 
            "text": "", 
            "title": "Step 4: Optimize"
        }, 
        {
            "location": "/7_steps/#step-5-walk-through-your-algorithms", 
            "text": "know exactly what you're going to do before coding   what variables   data structures?  how, why, why do they change?  what is the structure of your code", 
            "title": "Step 5: Walk through your algorithms"
        }, 
        {
            "location": "/7_steps/#step-6-code", 
            "text": "Whiteboard: write straight, use space wisely  Whiteboard or computer    coding style matters (consistent braces, consistent variable naming, consistence spaces, descriptive variables)    modularize (before. not after)", 
            "title": "Step 6: Code"
        }, 
        {
            "location": "/7_steps/#step-7-test", 
            "text": "Analyse: think about each line, double check things that look weired/risky (for-loop that decrement, math) - Use test cases (smalle test-cases first (faster to run, you will problably be more thoroguht, edge cases, big tes cases)  REMEMBER:  think as you test (don't be a bot)  test your code, not your algorithm\n* think before you fix bugs. Don't panic! (wrong fixes are worse than no fix)", 
            "title": "Step 7: Test"
        }, 
        {
            "location": "/7_steps/#suggested-reading", 
            "text": "https://www.youtube.com/watch?v=GKgAVjJxh9w list=PLM0_NsFSjrgC72cExkBI4Iz99SBTzYG-u index=4", 
            "title": "Suggested Reading"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Basic Data Structures"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Dynamic Arrays and Amortized Analysis"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Priority Queues and Disjoint Sets"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Hash Tables"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Binary Search Trees"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_array/", 
            "text": "Arrays\n\n\nAn array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.\n\n\nHere is the list of most important array features you must know (i.e. be able to program)\n\n\n\n\ncopying and cloning\n\n\ninsertion and deletion\n\n\nsearching and sorting\n\n\n\n\nYou already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:\n\n\nint[] a = {9, 5, 4};\nint[] b = a;\n\n\n\n\nThe assignment operator creates an alias to the object, like in the picture below\n\n\n\n\nSince these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,\n\n\nint [] a = {1,2,3};\nint [] b = {1,2,3};\n\n\n\n\na and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.\n\n\nThe Arrays class\n\n\nThe java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:\n\n\nint[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println(\narrays with identical contents\n);\n\n\n\n\nAnother commonly used method is toString() which takes care of of printing\n\n\nint[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nHere is the example of sorting\n\n\nint[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));\n\n\n\n\nIn addition to that, the class has other utility methods for supporting operations over multidimensional arrays.\n\n\nCopying arrays\n\n\nThere are four ways to copy arrays\n\n\nusing a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i \n a.length; i++) b[i] = a[i];\n\n\n\n\nThe next choice is to use Arrays.copyOf()\n\n\nint[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);\n\n\n\n\nThe second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.\n\n\nThe most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature\n\n\npublic static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)\n\n\n\n\nThe method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows\n\n\nint[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)\n\n\n\n\nAnd the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment\n\n\nint[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();\n\n\n\n\nNote, that casting (int[]) is the must.\n\n\nExamine the code in ArrayCopyPrimitives.java for further details.\n\n\nInsertion and Deletion\n\n\nArrays in Java have no methods and only one \nimmutable\n field \nlength\n. Once an array is created, its length is fixed and cannot be changed. What do you do to resize the array? You allocate the array with a different size and copy the contents of the old array to the new array. This code example demonstrates deletion from an array of primitives\n\n\npublic char[] delete(char[] data, int pos)\n{\n    if(pos \n= 0 \n pos \n data.length)\n    {\n        char[] tmp = new char[data.length-1];\n        System.arraycopy(data, 0, tmp, 0, pos);\n        System.arraycopy(data, pos+1, tmp, pos, data.length-pos-1);\n        return tmp;\n    }\n    else\n        return data;\n}\n\n\n\n\nThe first arraycopy copies the elements from index 0 to index pos-1, the second arraycopy copies the elements from index pos+1 to data.length.\n\n\nExamine the code in ArrayDemo.java for further details.\n\n\nThe ArrayList class\n\n\nThe java.util.ArrayList class supports an idea of a dynamic array - an array that grows and shrinks on demand to accomodate the number of elements in the array. Below is a list of commonly used methods\n\n\n\n\nadd(object)\n - adds to the end\n\n\nadd(index, object)\n - inserts at the index\n\n\nset(index, object)\n - replaces at the index\n\n\nget(index)\n - returns the element at that index\n\n\nremove(index)\n - deletes the element at that index\n\n\nsize()\n - returns the number of elements\n\n\n\n\nThe following code example will give you a heads up into how some of them are used.\n\n\n/* ADD */\n      ArrayList\nInteger\n num = new ArrayList\nInteger\n();\n      for(int i = 0; i \n 10; i++) num.add(i);\n      System.out.println(num);\n\n\n/* REMOVE even integers */\n      for(int i = 0; i \n num.size(); i++)\n        if(num.get(i)%2 == 0) num.remove(i);\n      System.out.println(num);\n\n\n\n\nCopying arrays of objects\n\n\nThis topic is more complex for understanding.. Let us start with a simple loop structure\n\n\nObject[] obj1 = {new Integer(10),\n                new StringBuffer(\nfoobar\n),\n                new Double(12.95)};\nObject[] obj2 = new Object[obj1.length];\nfor(int i = 0; i \u2039 obj1.length; i++)\n    obj2[i] = obj1[i];\n\n\n\n\nAt the first glance we might think that all data is copied. In reality, the internal data is shared between two arrays. The figure below illustrates the inner structure\n\n\n\n\nThe assignment operator \nobj2[i] = obj1[i]\n is a crucial part of understanding the concept. You cannot copy references by assigning one to another. The assignment creates an alias rather than a copy. Let us trace down changes in the above picture after execution the following statements\n\n\nobj1[0] = new Integer(5);\n\n\n\n\n\n\nand \n((StringBuffer) obj1[1]).append('s');\n\n\n\n\nAs you see, \nobj1[0]\n and \nobj2[0]\n now refer to different objects. However, \nobj1[1]\n and \nobj2[1]\n refer to the same object (which is \"foobars\"). Since both arrays shares the data, you must be quite careful when you modify your data, because it might lead to unexpected effects.\n\n\nThe same behavior will take place again, if we use Arrays.copuyOf(), System.arraycopy() and clone(). Examine the code example ArrayCopyReferences.java for further details.\n\n\nMulti-dimensional arrays\n\n\nIn many practical application there is a need to use two- or multi-dimensional arrays. A two-dimensional array can be thought of as a table of rows and columns. This creates a table of 2 rows and 4 columns:\n\n\nint[][] ar1 = new int[2][4];\n\n\n\n\nYou can create and initialize an array by using nested curcly braces. For example, this creates a table of 3 rows and 2 columns:\n\n\nint[][] ar2 = {{1,2},{3,4},{5,6}};\n\n\n\n\nGenerally speaking, a two-dimensional array is not exactly a table - each row in such array can have a different length. Consider this code fragment\n\n\nObject[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10), \nbozo\n, new Double(1.95)}};\n\n\n\n\nThe accompanying picture sheds a bit of light on internal representation\n\n\n\n\nFrom the picture you clearly see that a two-dimensional array in Java is an array of arrays. The array obj has two elements obj[0] and obj[1] that are arrays of length 2 and 3 respectively.\n\n\nCloning 2D arrays\n\n\nThe procedure is even more confusing and less expected. Consider the following code segment\n\n\nObject[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10), \nbozo\n, new Double(1.95)}};\n\nObject[][] twin = (Object[][]) obj.clone();\n\n\n\n\nThe procedure of clonig 2d arrays is virtually the same as cloning an array of references. Unfortunately, built-in clone() method does not actualy clone each row, but rather creates references to them Here is a graphical interpretation of the above code\n\n\n\n\nLet us change the value of \nobj[1][1]\n\n\nobj[1][1] = \nxyz\n;\n\n\n\n\nThis assignment effects the value of \ntwin[1][1]\n as well\n\n\n\n\nSuch a copy is called a \"shallow\" copy. The default behavior of clone() is to return a shallow copy of the object. If we want a \"deep\" copy instead, we must provide our own implementation by overriding Object's clone() method.\n\n\nThe idea of a \"deep\" copy is simple - it makes a distinct copy of each of the object's fields, recursing through the entire object. A deep copy is thus a completely separate object from the original; changes to it don't affect the original, and vise versa. In relevance to the above code, here is a deep clone graphically\n\n\n\n\nFurther, making a complete deep copy is not always needed. Consider an array of immutable objects. As we know, immutable objects cannot be modified, allowing clients to share the same instance without interfering with each other. In this case there is no need to clone them, which leads to the following picture\n\n\n\n\nAlways in this course we will create data structures of immutable objets, therefore implementing the clone method will require copying a structure (a shape) and sharing its internal data. We will discuss these issues later on in the course.\n\n\nChallenges\n\n\n\n\n\"Arrays: Left Rotation\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Array Data Structure\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Arrays"
        }, 
        {
            "location": "/d_array/#arrays", 
            "text": "An array is an aggregate data structure that is designed to store a group of objects of the same or different types. Arrays can hold primitives as well as references. The array is the most efficient data structure for storing and accessing a sequence of objects.  Here is the list of most important array features you must know (i.e. be able to program)   copying and cloning  insertion and deletion  searching and sorting   You already know that the Java language has only two data types, primitives and references. Which one is an array? Is it primitive? An array is not a primitive data type - it has a field (and only one), called length. Formally speaking, an array is a reference type, though you cannot find such a class in the Java APIs. Therefore, you deal with arrays as you deal with references. One of the major diffeences between refeences and primituives is that you cannot copy arrays by assigning one to another:  int[] a = {9, 5, 4};\nint[] b = a;  The assignment operator creates an alias to the object, like in the picture below   Since these two references a and b refer to the same object, comparing them with the double equal sign \"==\" will always return true. In the next code example,  int [] a = {1,2,3};\nint [] b = {1,2,3};  a and b refer to two different objects (though with identical contents). Comparing them with the double equal sign will return false. How would you compare two objects with identical contents? In short, using the equals method. For array comparison, the Java APIs provides the Arrays class.", 
            "title": "Arrays"
        }, 
        {
            "location": "/d_array/#the-arrays-class", 
            "text": "The java.util.Arrays class is a convenience class for various array manipulations, like comparison, searching, printing, sorting and others. Basically, this class is a set of static methods that are all useful for working with arrays. The code below demonstrates a proper invocation of equals:  int[] a = {1,2,3};\nint[] b = {1,2,3};\nif( Arrays.equals(a, b) )\n   System.out.println( arrays with identical contents );  Another commonly used method is toString() which takes care of of printing  int[] a = {1,2,3};\nSystem.out.println(Arrays.toString(a));  Here is the example of sorting  int[] a = {3,2,1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a));  In addition to that, the class has other utility methods for supporting operations over multidimensional arrays.", 
            "title": "The Arrays class"
        }, 
        {
            "location": "/d_array/#copying-arrays", 
            "text": "There are four ways to copy arrays  using a loop structure\nusing Arrays.copyOf()\nusing System.arraycopy()\nusing clone()\nThe first way is very well known to you  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor(int i= 0; i   a.length; i++) b[i] = a[i];  The next choice is to use Arrays.copyOf()  int[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, a.length);  The second parameter specifies the length of the new array, which could either less or equal or bigger than the original length.  The most efficient copying data between arrays is provided by System.arraycopy() method. The method requires five arguments. Here is its signature  public static void arraycopy(Object source,\n                             int srcIndex,\n                             Object destination,\n                             int destIndex,\n                             int length)  The method copies length elements from a source array starting with the index srcIndex to a new array destination at the index destIndex.The above code example can be rewritten as it follows  int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nSystem.arraycopy(a, 0, b, 0, 3)  And the last copying choice is the use of cloning. Cloning involves creating a new array of the same size and type and copying all the old elements into the new array. The clone() method is defined in the Object class and its invocation is demonstrated by this code segment  int[] a = {1, 2, 3};\nint[] b = (int[]) a.clone();  Note, that casting (int[]) is the must.  Examine the code in ArrayCopyPrimitives.java for further details.", 
            "title": "Copying arrays"
        }, 
        {
            "location": "/d_array/#insertion-and-deletion", 
            "text": "Arrays in Java have no methods and only one  immutable  field  length . Once an array is created, its length is fixed and cannot be changed. What do you do to resize the array? You allocate the array with a different size and copy the contents of the old array to the new array. This code example demonstrates deletion from an array of primitives  public char[] delete(char[] data, int pos)\n{\n    if(pos  = 0   pos   data.length)\n    {\n        char[] tmp = new char[data.length-1];\n        System.arraycopy(data, 0, tmp, 0, pos);\n        System.arraycopy(data, pos+1, tmp, pos, data.length-pos-1);\n        return tmp;\n    }\n    else\n        return data;\n}  The first arraycopy copies the elements from index 0 to index pos-1, the second arraycopy copies the elements from index pos+1 to data.length.  Examine the code in ArrayDemo.java for further details.", 
            "title": "Insertion and Deletion"
        }, 
        {
            "location": "/d_array/#the-arraylist-class", 
            "text": "The java.util.ArrayList class supports an idea of a dynamic array - an array that grows and shrinks on demand to accomodate the number of elements in the array. Below is a list of commonly used methods   add(object)  - adds to the end  add(index, object)  - inserts at the index  set(index, object)  - replaces at the index  get(index)  - returns the element at that index  remove(index)  - deletes the element at that index  size()  - returns the number of elements   The following code example will give you a heads up into how some of them are used.  /* ADD */\n      ArrayList Integer  num = new ArrayList Integer ();\n      for(int i = 0; i   10; i++) num.add(i);\n      System.out.println(num);\n\n\n/* REMOVE even integers */\n      for(int i = 0; i   num.size(); i++)\n        if(num.get(i)%2 == 0) num.remove(i);\n      System.out.println(num);", 
            "title": "The ArrayList class"
        }, 
        {
            "location": "/d_array/#copying-arrays-of-objects", 
            "text": "This topic is more complex for understanding.. Let us start with a simple loop structure  Object[] obj1 = {new Integer(10),\n                new StringBuffer( foobar ),\n                new Double(12.95)};\nObject[] obj2 = new Object[obj1.length];\nfor(int i = 0; i \u2039 obj1.length; i++)\n    obj2[i] = obj1[i];  At the first glance we might think that all data is copied. In reality, the internal data is shared between two arrays. The figure below illustrates the inner structure   The assignment operator  obj2[i] = obj1[i]  is a crucial part of understanding the concept. You cannot copy references by assigning one to another. The assignment creates an alias rather than a copy. Let us trace down changes in the above picture after execution the following statements  obj1[0] = new Integer(5);   and  ((StringBuffer) obj1[1]).append('s');   As you see,  obj1[0]  and  obj2[0]  now refer to different objects. However,  obj1[1]  and  obj2[1]  refer to the same object (which is \"foobars\"). Since both arrays shares the data, you must be quite careful when you modify your data, because it might lead to unexpected effects.  The same behavior will take place again, if we use Arrays.copuyOf(), System.arraycopy() and clone(). Examine the code example ArrayCopyReferences.java for further details.", 
            "title": "Copying arrays of objects"
        }, 
        {
            "location": "/d_array/#multi-dimensional-arrays", 
            "text": "In many practical application there is a need to use two- or multi-dimensional arrays. A two-dimensional array can be thought of as a table of rows and columns. This creates a table of 2 rows and 4 columns:  int[][] ar1 = new int[2][4];  You can create and initialize an array by using nested curcly braces. For example, this creates a table of 3 rows and 2 columns:  int[][] ar2 = {{1,2},{3,4},{5,6}};  Generally speaking, a two-dimensional array is not exactly a table - each row in such array can have a different length. Consider this code fragment  Object[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10),  bozo , new Double(1.95)}};  The accompanying picture sheds a bit of light on internal representation   From the picture you clearly see that a two-dimensional array in Java is an array of arrays. The array obj has two elements obj[0] and obj[1] that are arrays of length 2 and 3 respectively.", 
            "title": "Multi-dimensional arrays"
        }, 
        {
            "location": "/d_array/#cloning-2d-arrays", 
            "text": "The procedure is even more confusing and less expected. Consider the following code segment  Object[][] obj = {{new Integer(1),new Integer(2)},\n                  {new Integer(10),  bozo , new Double(1.95)}};\n\nObject[][] twin = (Object[][]) obj.clone();  The procedure of clonig 2d arrays is virtually the same as cloning an array of references. Unfortunately, built-in clone() method does not actualy clone each row, but rather creates references to them Here is a graphical interpretation of the above code   Let us change the value of  obj[1][1]  obj[1][1] =  xyz ;  This assignment effects the value of  twin[1][1]  as well   Such a copy is called a \"shallow\" copy. The default behavior of clone() is to return a shallow copy of the object. If we want a \"deep\" copy instead, we must provide our own implementation by overriding Object's clone() method.  The idea of a \"deep\" copy is simple - it makes a distinct copy of each of the object's fields, recursing through the entire object. A deep copy is thus a completely separate object from the original; changes to it don't affect the original, and vise versa. In relevance to the above code, here is a deep clone graphically   Further, making a complete deep copy is not always needed. Consider an array of immutable objects. As we know, immutable objects cannot be modified, allowing clients to share the same instance without interfering with each other. In this case there is no need to clone them, which leads to the following picture   Always in this course we will create data structures of immutable objets, therefore implementing the clone method will require copying a structure (a shape) and sharing its internal data. We will discuss these issues later on in the course.", 
            "title": "Cloning 2D arrays"
        }, 
        {
            "location": "/d_array/#challenges", 
            "text": "\"Arrays: Left Rotation\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_array/#references", 
            "text": "\"Array Data Structure\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/d_string/", 
            "text": "String\n\n\nString manipulation is a basic operation of many algorithms and utilities such as data validation, text parsing, file conversions and others. The Java APIs contain three classes that are used to work with character data:\n\n\n\n\nCharacter\n -- A class whose instances can hold a single character value.\n\n\nString\n -- An immutable class for working with multiple characters.\n\n\nStringBuffer\n and \nStringBuilder\n -- Mutable classes for working with multiple characters.\n\n\n\n\nThe String and StringBuffer classes are two you will use the most in your programming assignments. You use the String class in situations when you want to prohibit data modification; otherwise you use the StringBuffer class.\n\n\nThe String class\n\n\nIn Java Strings can be created in two different ways. Either using a new operator\n\n\nString demo1 = new String(\nThis is a string\n);\n\nchar[] demo2 = {'s','t','r','i','n','g'};\nString str = new String(demo2);\n\n\n\n\nor using a string literal\n\n\nString demo3 = \nThis is a string\n;\n\n\n\n\nThe example below demonstrates differences between these initializations\n\n\nString s1 = new String(\nFester\n);\nString s2 = new String(\nFester\n);\nString s3 = \nFester\n;\nString s4 = \nFester\n;\n\n\n\n\nThen\n\n\ns1 == s2 returns false\ns1 == s3 returns false\ns3 == s4 returns true\n\n\n\n\nBecause of the importance strings in real life, Java stores (at compile time) all strings in a special internal table as long as you create your strings using a string literal String s3 = \"Fester\". This process is called canonicalization - it replaces multiple string objects with a single object. This is why in the above example s3 and s4 refer to the same object. Also note that creating strings like s3 and s4 is more efficient. Review the code example StringOptimization.java that demonstrates time comparisons between these two ways of string creation.\n\n\nHere are some important facts you must know about strings:\n\n\n1.\n A string is not an array of characters.\nTherefore, to access a particular character in a string, you have to use the charAt() method. In this code snippet we get the fourth character which is 't':\n\n\nString str = \non the  edge of history\n;\nchar ch = str.charAt(3);\n\n\n\n\n2.\n The toString() method is used when we need a string representation of an object.\n\n\nThe method is defined in the Object class. For most important classes that you create, you will want to override toString() and provide your own string representation.\n\n\n3.\n Comparing strings content using == is the most common mistake beginners do. You compare the content using either equals() or compareTo() methods.\n\n\nBasic String methods\n\n\nThe String class contains an enormous amount of useful methods for string manipulation. The following table presents the most common String methods:\n\n\n\n\nstr.charAt(k) returns a char at position k in str.\n\n\nstr.substring(k)  returns a substring from index k to the end of str\n\n\ns.substring(k, n) returns a substring from index k to index n-1 of str\n\n\nstr.indexOf(s)    returns an index of the first occurrence of String s in str\n\n\nstr.indexOf(s, k) returns an index of String s starting an index k in str\n\n\nstr.startsWith(s) returns true if str starts with s\n\n\nstr.startsWith(s, k)  returns true if str starts with s at index k\n\n\nstr.equals(s) returns true if the two strings have equal values\n\n\nstr.equalsIgnoreCase(s)   same as above ignoring case\n\n\nstr.compareTo(s)  compares two strings\n\n\ns.compareToIgnoreCase(t)  same as above ignoring case\n\n\n\n\nExamine the code in \nBasicStringDemo.java\n for further details.\n\n\nThe StringBuffer class\n\n\nIn many cases when you deal with strings you will use methods available in the companion StringBuffer class. This mutable class is used when you want to modify the contents of the string. It provides an efficient approach to dealing with strings, especially for large dynamic string data. StringBuffer is similar to ArrayList in a way that the memory allocated to an object is automatically expanded to take up additional data.\n\n\nHere is an example of reversing a string using string concatenation\n\n\npublic static String reverse1(String s)\n{\n   String str = \n;\n\n   for(int i = s.length() - 1; i\n=0; i--)\n      str += s.charAt(i);\n\n   return str;\n}\n\n\n\n\nand using a StringBuffer's append\n\n\npublic static String revers2(String s)\n{\n   StringBuffer sb = new StringBuffer();\n\n   for(int i = s.length() - 1; i\n=0; i--)\n      sb.append(s.charAt(i));\n\n   return sb.toString();\n}\n\n\n\n\nAnother way to reverse a string is to convert a String object into a StringBuffer object, use the reverse method, and then convert it back to a string:\n\n\npublic static String reverse3(String s)\n{\n   return new StringBuffer(s).reverse().toString();\n}\n\n\n\n\nThe performance difference between these two classes is that StringBuffer is faster than String when performing concatenations. Each time a concatenation occurs, a new string is created, causing excessive system resource consumption.\n\n\nReview the code example \nStringOverhead.java\n that demonstrates time comparisons of concatenation on Strings and StringBuffer.\n\n\nStringTokenizer\n\n\nThis class (from java.util package) allows you to break a string into tokens (substrings). Each token is a group of characters that are separated by delimiters, such as an empty space, a semicolon, and so on. So, a token is a maximal sequence of consecutive characters that are not delimiters. Here is an example of the use of the tokenizer (an empty space is a default delimiter):\n\n\nString s = \nNothing is as easy as it looks\n;\nStringTokenizer st = new StringTokenizer(s);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println( \nToken [\n + token + \n]\n );\n}\n\n\n\n\nHere, hasMoreTokens() method checks if there are more tokens available from the string, and nextToken() method returns the next token from the string tokenizer.\n\n\nThe set of delimiters (the characters that separate tokens) may be specified in the second argument of StringTokenizer. In the following example, StringTokenizer has a set of two delimiters: an empty space and an underscore:\n\n\nString s = \nEvery_solution_breeds new problems\n;\nStringTokenizer st = new StringTokenizer(s, \n _\n);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println( \nToken [\n + token + \n]\n );\n}\n\n\n\n\nRegular Expressions\n\n\nRegular expressions are the most common programming technique for scanning strings and extracting substrings based on common characteristics. They are an essential part of many programming languages. In the following table the left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.\n\n\nCharacter Classes\n\n\n[abc]           a, b, or c (simple class)\n[^abc]          Any character except a, b, or c (negation)\n[a-zA-Z]        a through z, or A through Z, inclusive (range)\n[a-d[m-p]]      a through d, or m through p: [a-dm-p] (union)\n[a-z\n[def]]    d, e, or f (intersection)\n[a-z\n[^bc]]    a through z, except for b and c: [ad-z] (subtraction)\n[a-z\n[^m-p]]   a through z, and not m through p: [a-lq-z] (subtraction)\n\\\\d             any digit from 0 to 9\n\\\\w             any word character (a-z,A-Z,0-9 and _)\n\\\\W             any non-word character\n\\\\s             any whitespace character\n?               appearing once or not at all\n*               appearing zero or more times\n+               appearing one or more times\n\n\n\n\nThe Java String class has several methods that allow you to perform an operation using a regular expression on that string in a minimal amount of code.\n\n\nThe matches() method\n\n\nThe matches(\"regex\") method returns true or false depending whether the string can be matched entirely by the regular expression \"regex\". For example,\n\n\nabc\n.matches(\nabc\n)\nreturns True,\n\n\n\n\nbut\n\n\nabc\n.matches(\nbc\n)\n\n\n\n\nreturns False. In the following code examples we match all strings that start with any number of dots (denoted by *), followed by \"abc\" and end with one or more underscores (denoted by +).\n\n\nString regex = \n.*\n+\nabc\n+\n_+\n;\n\n\n..abc___\n.matches(regex);\n\n\nabc___\n.matches(regex);\n\n\nabc_\n.matches(regex);\n\n\n\n\nThe replaceAll() method\n\n\nThe method replaceAll(\"regex\", \"replacement\") replaces each substring of the myString that matches the given regular expression \"regex\" with the given \"replacement\". As an example, let us remove all non-letters from a given string\n\n\nString str = \nNothing 2is as \n easy AS it +_=looks!\n;\nstr = str.replaceAll(\n[^a-zA-Z]\n, \n);\n\n\n\n\nThe pattern \"[a-zA-Z]\" describes all letters (in upper and lower cases). Next we negate this pattern, to get all non-letters \"[^a-zA-Z]\".\n\n\nIn the next example, we replace a sequence of characters by \"-\"\n\n\nString str = \naabfooaaaabfooabfoob\n;\nstr = str.replaceAll(\na*b\n, \n-\n);\n\n\n\n\nThe star \"\n\" in the pattern \"a\nb\" denotes that character \"a\" may be repeated zero or more times. The output: \"-foo-foo-foo-\";\n\n\nThe split() method\n\n\nThe split(\"regex\") splits the string at each \"regex\" match and returns an array of strings where each element is a part of the original string between two \"regex\" matches.\n\n\nIn the following example we break a sentence into words, using an empty space as a delimiter:\n\n\nString s = \nNothing is as easy as it looks\n;\nString[] st = s.split(\n \n);\n\n\n\n\nTokens are stored in in an array of strings and could be be easily accessible using array indexes. In the next code example, we choose two delimiters: either an empty space or an underscore:\n\n\nString s = \nEvery_solution_breeds new problems\n;\nString[]st = s.split(\n_| \n);\n\n\n\n\nWhat if a string contains several underscores? We use \"+\", that denotes a repetitive pattern\n\n\nString s = \nEvery_solution____breeds_new__problems\n;\nString[] st = s.split(\n_+\n);\n\n\n\n\nIt's important to observe that split() might returns empty tokens. In the example below\n\n\nString[] st = \nTomorrow\n.split(\nr\n);\n\n\n\n\nwe have three tokens, where the second token is empty string. That is so because split() returns tokens between two \"regex\" matches.\n\n\nOne of the widely use of split() is to break a given text file into words. This could be easily done by means of the metacharacter \"\\W\" (any non-word character), which allows you to perform a \"whole words only\" search using a regular expression. A \"word character\" is either an alphabet character (a-z and A-Z) or a digit (0-9) or a underscore.\n\n\nLet's go, Steelers!!!\n.split(\n\\\\W\n);\n\n\n\n\nreturns the following array of tokens\n\n\n[Let, s, go, Steelers]\n\n\n\n\nExamine the code in \nSplit.java\n for further details.\n\n\nPattern matching\n\n\nPattern matching in Java is based on use of two classes\n\n\n\n\nPattern\n  - compiled representation of a regular expression.\n\n\nMatcher\n - an engine that performs match operations.\n\n\n\n\nA typical invocation is the following, first we create a pattern\n\n\nString seq = \nCCCAA\n;\nPattern p = Pattern.compile(\nC*A*\n);\n\n\n\n\nIn this example we match all substrings that start with any number of Cs followed by any number of As. Then we create a Matcher object that can match any string against our pattern\n\n\nMatcher m = p.matcher(seq);\n\n\n\n\nFinally, we do actual matching\n\n\nboolean res = m.matches();\n\n\n\n\nThe Matcher class has another widely used method, called find(), that finds next substring that matches a given pattern. In the following example we cound the number of matches \"ACC\"\n\n\nString seq = \nCGTATCCCACAGCACCACACCCAACAACCCA\n;\nPattern p = Pattern.compile(\nA{1}C{2}\n);\nMatcher m = p.matcher(seq);\nint count = 0;\nwhile( m.find() ) count++;\nSystem.out.println(\nthere are \n + count + \n ACC\n);\n\n\n\n\nExamine the code example \nMatching.java\n for further details.\n\n\nPattern matching in Computational Biology\n\n\n\n\nThe DNA (the genetic blueprint) of any species is composed of about 4 billion ACGT nucleotides. DNA forms a double helix that has two strands of DNA binding and twisting together. In pattern matching problems we ignore the fact that DNA forms a double helix, and think of it only as a single strand. The other strand is complimentary. Knowing one strand allows uniquely determine the other one. Thus, DNA is essentially a linear molecule that looks like a string composed out of only four characters A, C, G, and T:\n\n\nCGTATCCCACAGCACCACACCCAACAACCC\n\n\n\n\nEach nucleotides (also called a base) strongly binds to no more than two other bases. These links provides a linear model of DNA strand. The particular order of ACGT nucleotides is extremely important. Different orders generate humans, animals, corn, and other organisms. The size of the genome (a genome is all the DNA in an organism) does not necessarily correlate with the complexity of the organism it belongs to. Humans have less than a third as many genes as were expected.\n\n\nPattern matching in computational biology arises from the need to know characteristics of DNA sequences, such as\n\n\n\n\nfind the best way to align two sequences.\n\n\nfind any common subsequences\n\n\ndetermine how well a sequence fits into a given model.\n\n\n\n\nComparing various DNA sequencesn provide many uses. Current scientific theories suggest that very similar DNA sequences have a common ancestor. The more similar two sequences are, the more recently they evolved from a single ansestor. With such knowledge, for example, we can reconstruct a phylogenetic tree (known as a \"tree of life\".) that shows how long ago various organisms diverged and which species are closely related.\n\n\nChallenges\n\n\n\n\nStrings: Making Anagrams\n\n\n\n\nReferences\n\n\n\n\n\"Strings\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Overview"
        }, 
        {
            "location": "/d_string/#string", 
            "text": "String manipulation is a basic operation of many algorithms and utilities such as data validation, text parsing, file conversions and others. The Java APIs contain three classes that are used to work with character data:   Character  -- A class whose instances can hold a single character value.  String  -- An immutable class for working with multiple characters.  StringBuffer  and  StringBuilder  -- Mutable classes for working with multiple characters.   The String and StringBuffer classes are two you will use the most in your programming assignments. You use the String class in situations when you want to prohibit data modification; otherwise you use the StringBuffer class.", 
            "title": "String"
        }, 
        {
            "location": "/d_string/#the-string-class", 
            "text": "In Java Strings can be created in two different ways. Either using a new operator  String demo1 = new String( This is a string );\n\nchar[] demo2 = {'s','t','r','i','n','g'};\nString str = new String(demo2);  or using a string literal  String demo3 =  This is a string ;  The example below demonstrates differences between these initializations  String s1 = new String( Fester );\nString s2 = new String( Fester );\nString s3 =  Fester ;\nString s4 =  Fester ;  Then  s1 == s2 returns false\ns1 == s3 returns false\ns3 == s4 returns true  Because of the importance strings in real life, Java stores (at compile time) all strings in a special internal table as long as you create your strings using a string literal String s3 = \"Fester\". This process is called canonicalization - it replaces multiple string objects with a single object. This is why in the above example s3 and s4 refer to the same object. Also note that creating strings like s3 and s4 is more efficient. Review the code example StringOptimization.java that demonstrates time comparisons between these two ways of string creation.  Here are some important facts you must know about strings:  1.  A string is not an array of characters.\nTherefore, to access a particular character in a string, you have to use the charAt() method. In this code snippet we get the fourth character which is 't':  String str =  on the  edge of history ;\nchar ch = str.charAt(3);  2.  The toString() method is used when we need a string representation of an object.  The method is defined in the Object class. For most important classes that you create, you will want to override toString() and provide your own string representation.  3.  Comparing strings content using == is the most common mistake beginners do. You compare the content using either equals() or compareTo() methods.", 
            "title": "The String class"
        }, 
        {
            "location": "/d_string/#basic-string-methods", 
            "text": "The String class contains an enormous amount of useful methods for string manipulation. The following table presents the most common String methods:   str.charAt(k) returns a char at position k in str.  str.substring(k)  returns a substring from index k to the end of str  s.substring(k, n) returns a substring from index k to index n-1 of str  str.indexOf(s)    returns an index of the first occurrence of String s in str  str.indexOf(s, k) returns an index of String s starting an index k in str  str.startsWith(s) returns true if str starts with s  str.startsWith(s, k)  returns true if str starts with s at index k  str.equals(s) returns true if the two strings have equal values  str.equalsIgnoreCase(s)   same as above ignoring case  str.compareTo(s)  compares two strings  s.compareToIgnoreCase(t)  same as above ignoring case   Examine the code in  BasicStringDemo.java  for further details.", 
            "title": "Basic String methods"
        }, 
        {
            "location": "/d_string/#the-stringbuffer-class", 
            "text": "In many cases when you deal with strings you will use methods available in the companion StringBuffer class. This mutable class is used when you want to modify the contents of the string. It provides an efficient approach to dealing with strings, especially for large dynamic string data. StringBuffer is similar to ArrayList in a way that the memory allocated to an object is automatically expanded to take up additional data.  Here is an example of reversing a string using string concatenation  public static String reverse1(String s)\n{\n   String str =  ;\n\n   for(int i = s.length() - 1; i =0; i--)\n      str += s.charAt(i);\n\n   return str;\n}  and using a StringBuffer's append  public static String revers2(String s)\n{\n   StringBuffer sb = new StringBuffer();\n\n   for(int i = s.length() - 1; i =0; i--)\n      sb.append(s.charAt(i));\n\n   return sb.toString();\n}  Another way to reverse a string is to convert a String object into a StringBuffer object, use the reverse method, and then convert it back to a string:  public static String reverse3(String s)\n{\n   return new StringBuffer(s).reverse().toString();\n}  The performance difference between these two classes is that StringBuffer is faster than String when performing concatenations. Each time a concatenation occurs, a new string is created, causing excessive system resource consumption.  Review the code example  StringOverhead.java  that demonstrates time comparisons of concatenation on Strings and StringBuffer.", 
            "title": "The StringBuffer class"
        }, 
        {
            "location": "/d_string/#stringtokenizer", 
            "text": "This class (from java.util package) allows you to break a string into tokens (substrings). Each token is a group of characters that are separated by delimiters, such as an empty space, a semicolon, and so on. So, a token is a maximal sequence of consecutive characters that are not delimiters. Here is an example of the use of the tokenizer (an empty space is a default delimiter):  String s =  Nothing is as easy as it looks ;\nStringTokenizer st = new StringTokenizer(s);\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println(  Token [  + token +  ]  );\n}  Here, hasMoreTokens() method checks if there are more tokens available from the string, and nextToken() method returns the next token from the string tokenizer.  The set of delimiters (the characters that separate tokens) may be specified in the second argument of StringTokenizer. In the following example, StringTokenizer has a set of two delimiters: an empty space and an underscore:  String s =  Every_solution_breeds new problems ;\nStringTokenizer st = new StringTokenizer(s,   _ );\nwhile (st.hasMoreTokens())\n{\n    String token = st.nextToken();\n    System.out.println(  Token [  + token +  ]  );\n}", 
            "title": "StringTokenizer"
        }, 
        {
            "location": "/d_string/#regular-expressions", 
            "text": "Regular expressions are the most common programming technique for scanning strings and extracting substrings based on common characteristics. They are an essential part of many programming languages. In the following table the left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.  Character Classes  [abc]           a, b, or c (simple class)\n[^abc]          Any character except a, b, or c (negation)\n[a-zA-Z]        a through z, or A through Z, inclusive (range)\n[a-d[m-p]]      a through d, or m through p: [a-dm-p] (union)\n[a-z [def]]    d, e, or f (intersection)\n[a-z [^bc]]    a through z, except for b and c: [ad-z] (subtraction)\n[a-z [^m-p]]   a through z, and not m through p: [a-lq-z] (subtraction)\n\\\\d             any digit from 0 to 9\n\\\\w             any word character (a-z,A-Z,0-9 and _)\n\\\\W             any non-word character\n\\\\s             any whitespace character\n?               appearing once or not at all\n*               appearing zero or more times\n+               appearing one or more times  The Java String class has several methods that allow you to perform an operation using a regular expression on that string in a minimal amount of code.", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/d_string/#the-matches-method", 
            "text": "The matches(\"regex\") method returns true or false depending whether the string can be matched entirely by the regular expression \"regex\". For example,  abc .matches( abc )\nreturns True,  but  abc .matches( bc )  returns False. In the following code examples we match all strings that start with any number of dots (denoted by *), followed by \"abc\" and end with one or more underscores (denoted by +).  String regex =  .* + abc + _+ ; ..abc___ .matches(regex); abc___ .matches(regex); abc_ .matches(regex);", 
            "title": "The matches() method"
        }, 
        {
            "location": "/d_string/#the-replaceall-method", 
            "text": "The method replaceAll(\"regex\", \"replacement\") replaces each substring of the myString that matches the given regular expression \"regex\" with the given \"replacement\". As an example, let us remove all non-letters from a given string  String str =  Nothing 2is as   easy AS it +_=looks! ;\nstr = str.replaceAll( [^a-zA-Z] ,  );  The pattern \"[a-zA-Z]\" describes all letters (in upper and lower cases). Next we negate this pattern, to get all non-letters \"[^a-zA-Z]\".  In the next example, we replace a sequence of characters by \"-\"  String str =  aabfooaaaabfooabfoob ;\nstr = str.replaceAll( a*b ,  - );  The star \" \" in the pattern \"a b\" denotes that character \"a\" may be repeated zero or more times. The output: \"-foo-foo-foo-\";", 
            "title": "The replaceAll() method"
        }, 
        {
            "location": "/d_string/#the-split-method", 
            "text": "The split(\"regex\") splits the string at each \"regex\" match and returns an array of strings where each element is a part of the original string between two \"regex\" matches.  In the following example we break a sentence into words, using an empty space as a delimiter:  String s =  Nothing is as easy as it looks ;\nString[] st = s.split(   );  Tokens are stored in in an array of strings and could be be easily accessible using array indexes. In the next code example, we choose two delimiters: either an empty space or an underscore:  String s =  Every_solution_breeds new problems ;\nString[]st = s.split( _|  );  What if a string contains several underscores? We use \"+\", that denotes a repetitive pattern  String s =  Every_solution____breeds_new__problems ;\nString[] st = s.split( _+ );  It's important to observe that split() might returns empty tokens. In the example below  String[] st =  Tomorrow .split( r );  we have three tokens, where the second token is empty string. That is so because split() returns tokens between two \"regex\" matches.  One of the widely use of split() is to break a given text file into words. This could be easily done by means of the metacharacter \"\\W\" (any non-word character), which allows you to perform a \"whole words only\" search using a regular expression. A \"word character\" is either an alphabet character (a-z and A-Z) or a digit (0-9) or a underscore.  Let's go, Steelers!!! .split( \\\\W );  returns the following array of tokens  [Let, s, go, Steelers]  Examine the code in  Split.java  for further details.", 
            "title": "The split() method"
        }, 
        {
            "location": "/d_string/#pattern-matching", 
            "text": "Pattern matching in Java is based on use of two classes   Pattern   - compiled representation of a regular expression.  Matcher  - an engine that performs match operations.   A typical invocation is the following, first we create a pattern  String seq =  CCCAA ;\nPattern p = Pattern.compile( C*A* );  In this example we match all substrings that start with any number of Cs followed by any number of As. Then we create a Matcher object that can match any string against our pattern  Matcher m = p.matcher(seq);  Finally, we do actual matching  boolean res = m.matches();  The Matcher class has another widely used method, called find(), that finds next substring that matches a given pattern. In the following example we cound the number of matches \"ACC\"  String seq =  CGTATCCCACAGCACCACACCCAACAACCCA ;\nPattern p = Pattern.compile( A{1}C{2} );\nMatcher m = p.matcher(seq);\nint count = 0;\nwhile( m.find() ) count++;\nSystem.out.println( there are   + count +   ACC );  Examine the code example  Matching.java  for further details.", 
            "title": "Pattern matching"
        }, 
        {
            "location": "/d_string/#pattern-matching-in-computational-biology", 
            "text": "The DNA (the genetic blueprint) of any species is composed of about 4 billion ACGT nucleotides. DNA forms a double helix that has two strands of DNA binding and twisting together. In pattern matching problems we ignore the fact that DNA forms a double helix, and think of it only as a single strand. The other strand is complimentary. Knowing one strand allows uniquely determine the other one. Thus, DNA is essentially a linear molecule that looks like a string composed out of only four characters A, C, G, and T:  CGTATCCCACAGCACCACACCCAACAACCC  Each nucleotides (also called a base) strongly binds to no more than two other bases. These links provides a linear model of DNA strand. The particular order of ACGT nucleotides is extremely important. Different orders generate humans, animals, corn, and other organisms. The size of the genome (a genome is all the DNA in an organism) does not necessarily correlate with the complexity of the organism it belongs to. Humans have less than a third as many genes as were expected.  Pattern matching in computational biology arises from the need to know characteristics of DNA sequences, such as   find the best way to align two sequences.  find any common subsequences  determine how well a sequence fits into a given model.   Comparing various DNA sequencesn provide many uses. Current scientific theories suggest that very similar DNA sequences have a common ancestor. The more similar two sequences are, the more recently they evolved from a single ansestor. With such knowledge, for example, we can reconstruct a phylogenetic tree (known as a \"tree of life\".) that shows how long ago various organisms diverged and which species are closely related.", 
            "title": "Pattern matching in Computational Biology"
        }, 
        {
            "location": "/d_string/#challenges", 
            "text": "Strings: Making Anagrams", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_string/#references", 
            "text": "\"Strings\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/d_string_substring_search/", 
            "text": "Substring Search\n\n\nA FUNDAMENTAL OPERATION on string is \nsubstring search\n: given a \ntext\n string of length N and a \npattern\n string of length M, find an occurrence of the pattern within the text. Most algorithms for this problem can easily be extended to find all occurrences of the pattern in the text, to count the number of occurrences of the pattern in the text, or to provide context (substrings of the text surrounding each occurrence of the pattern).", 
            "title": "Substring Search"
        }, 
        {
            "location": "/d_string_substring_search/#substring-search", 
            "text": "A FUNDAMENTAL OPERATION on string is  substring search : given a  text  string of length N and a  pattern  string of length M, find an occurrence of the pattern within the text. Most algorithms for this problem can easily be extended to find all occurrences of the pattern in the text, to count the number of occurrences of the pattern in the text, or to provide context (substrings of the text surrounding each occurrence of the pattern).", 
            "title": "Substring Search"
        }, 
        {
            "location": "/d_stack_queue/", 
            "text": "Stacks and Queues\n\n\nAn array is a random access data structure, where each element can be accessed directly and in constant time. A typical illustration of random access is a book - each page of the book can be open independently of others. Random access is critical to many algorithms, for example binary search.\n\n\nA linked list is a sequential access data structure, where each element can be accesed only in particular order. A typical illustration of sequential access is a roll of paper or tape - all prior material must be unrolled in order to get to data you want.\n\n\nIn this note we consider a subcase of sequential data structures, so-called limited access data sturctures.\n\n\nStacks\n\n\nA stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO) principle. In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item out of the stack. A stack is a limited access data structure - elements can be added and removed from the stack only at the top. push adds an item to the top of the stack, pop removes the item from the top. A helpful analogy is to think of a stack of books; you can remove only the top book, also you can add a new book on the top.\nA stack is a recursive data structure. Here is a structural definition of a Stack:\n\n\n\n\na stack is either empty or\n\n\nit consistes of a top and the rest which is a stack;\n\n\n\n\n\n\nApplications\n\n\n\n\nThe simplest application of a stack is to reverse a word. You push a given word to stack - letter by letter - and then pop letters from the stack.\n\n\nAnother application is an \"undo\" mechanism in text editors; this operation is accomplished by keeping all text changes in a stack.\n\n\nBacktracking\n. This is a process when you need to access the most recent data element in a series of elements. Think of a labyrinth or maze - how do you find a way from an entrance to an exit?\nOnce you reach a dead end, you must backtrack. But backtrack to where? to the previous choice point. Therefore, at each choice point you store on a stack all possible choices. Then backtracking simply means popping a next choice from the stack.\n\n\n\n\n\n\n\n\nLanguage processing:\n\n\nspace for parameters and local variables is created internally using a stack.\n\n\ncompiler's syntax check for matching braces is implemented by using stack.\n\n\nsupport for recursion\n\n\n\n\n\n\n\n\nImplementation\n\n\nIn the standard library of classes, the data type stack is an adapter class, meaning that a stack is built on top of other data structures. The underlying structure for a stack could be an array, a vector, an ArrayList, a linked list, or any other collection. Regardless of the type of the underlying data structure, a Stack must implement the same functionality. This is achieved by providing a unique interface:\n\n\npublic interface StackInterface\nAnyType\n\n{\n   public void push(AnyType e);\n\n   public AnyType pop();\n\n   public AnyType peek();\n\n   public boolean isEmpty();\n}\n\n\n\n\nThe following picture demonstrates the idea of implementation by composition.\n\n\n\n\nAnother implementation requirement (in addition to the above interface) is that all stack operations must run in constant time O(1). Constant time means that there is some constant k such that an operation takes k nanoseconds of computational time regardless of the stack size.\n\n\nArray-based implementation\n\n\n\n\nIn an array-based implementation we maintain the following fields: an array A of a default size (\u2265 1), the variable top that refers to the top element in the stack and the capacity that refers to the array size. The variable top changes from -1 to capacity - 1. We say that a stack is empty when top = -1, and the stack is full when top = capacity-1.\nIn a fixed-size stack abstraction, the capacity stays unchanged, therefore when top reaches capacity, the stack object throws an exception. See ArrayStack.java for a complete implementation of the stack class.\n\n\nIn a dynamic stack abstraction when top reaches capacity, we double up the stack siz\n\n\nLinked List-based implementation\n\n\n\n\nLinked List-based implementation provides the best (from the efficiency point of view) dynamic stack implementation.\nSee ListStack.java for a complete implementation of the stack class.\n\n\nQueues\n\n\nA queue is a container of objects (a linear collection) that are inserted and removed according to the first-in first-out (FIFO) principle. An excellent example of a queue is a line of students in the food court of the UC. New additions to a line made to the back of the queue, while removal (or serving) happens in the front. In the queue only two operations are allowed enqueue and dequeue. Enqueue means to insert an item into the back of the queue, dequeue means removing the front item. The picture demonstrates the FIFO access.\nThe difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.\n\n\n\n\nImplementation\n\n\nIn the standard library of classes, the data type queue is an adapter class, meaning that a queue is built on top of other data structures. The underlying structure for a queue could be an array, a Vector, an ArrayList, a LinkedList, or any other collection. Regardless of the type of the underlying data structure, a queue must implement the same functionality. This is achieved by providing a unique interface.\n\n\ninterface QueueInterface\u2039AnyType\n\n{\n   public boolean isEmpty();\n\n   public AnyType getFront();\n\n   public AnyType dequeue();\n\n   public void enqueue(AnyType e);\n\n   public void clear();\n}\n\n\n\n\nEach of the above basic operations must run at constant time O(1). The following picture demonstrates the idea of implementation by composition.\n\n\n\n\nCircular Queue\n\n\nGiven an array A of a default size (\u2265 1) with two references back and front, originally set to -1 and 0 respectively. Each time we insert (enqueue) a new item, we increase the back index; when we remove (dequeue) an item - we increase the front index. Here is a picture that illustrates the model after a few steps:\n\n\n\n\nAs you see from the picture, the queue logically moves in the array from left to right. After several moves back reaches the end, leaving no space for adding new elements\n\n\n\n\nHowever, there is a free space before the front index. We shall use that space for enqueueing new items, i.e. the next entry will be stored at index 0, then 1, until front. Such a model is called a wrap around queue or a circular queue\n\n\n\n\nFinally, when back reaches front, the queue is full. There are two choices to handle a full queue:a) throw an exception; b) double the array size.\n\n\nThe circular queue implementation is done by using the modulo operator (denoted %), which is computed by taking the remainder of division (for example, 8%5 is 3). By using the modulo operator, we can view the queue as a circular array, where the \"wrapped around\" can be simulated as \"back % array_size\". In addition to the back and front indexes, we maintain another index: cur - for counting the number of elements in a queue. Having this index simplifies a logic of implementation.\n\n\nSee ArrayQueue.java for a complete implementation of a circular queue.\n\n\nApplications\n\n\nThe simplest two search techniques are known as Depth-First Search(DFS) and Breadth-First Search (BFS). These two searches are described by looking at how the search tree (representing all the possible paths from the start) will be traversed.\n\n\nDeapth-First Search with a Stack\n\n\nIn depth-first search we go down a path until we get to a dead end; then we backtrack or back up (by popping a stack) to get an alternative path.\n\n\nCreate a stack\nCreate a new choice point\nPush the choice point onto the stack\nwhile (not found and stack is not empty)\n    Pop the stack\n    Find all possible choices after the last one tried\n    Push these choices onto the stack\nReturn\n\n\n\n\nBreadth-First Search with a Queue\n\n\nIn breadth-first search we explore all the nearest possibilities by finding all possible successors and enqueue them to a queue.\n\n\nCreate a queue\nCreate a new choice point\nEnqueue the choice point onto the queue\nwhile (not found and queue is not empty)\n    Dequeue the queue\n    Find all possible choices after the last one tried\n    Enqueue these choices onto the queue\nReturn\n\n\n\n\nWe will see more on search techniques later in the course.\n\n\nArithmetic Expression Evaluation\n\n\nAn important application of stacks is in parsing. For example, a compiler must parse arithmetic expressions written using infix notation:\n\n\n1 + ((2 + 3) * 4 + 5)*6\n\n\n\n\nWe break the problem of parsing infix expressions into two stages. First, we convert from infix to a different representation called postfix. Then we parse the postfix expression, which is a somewhat easier problem than directly parsing infix.\n\n\nConverting from Infix to Postfix.\n Typically, we deal with expressions in infix notation\n\n\n2 + 5\n\n\n\n\nwhere the operators (e.g. +, *) are written between the operands (e.q, 2 and 5). Writing the operators after the operands gives a postfix expression 2 and 5 are called operands, and the '+' is operator. The above arithmetic expression is called infix, since the operator is in between operands. The expression\n\n\n2 5 +\n\n\n\n\nWriting the operators before the operands gives a prefix expression\n\n\n+2 5\n\n\n\n\nSuppose you want to compute the cost of your shopping trip. To do so, you add a list of numbers and multiply them by the local sales tax (7.25%):\n\n\n70 + 150 * 1.0725\n\n\n\n\nDepending on the calculator, the answer would be either 235.95 or 230.875. To avoid this confusion we shall use a postfix notation\n\n\n70  150 + 1.0725 *\n\n\n\n\nPostfix has the nice property that parentheses are unnecessary.\n\n\nNow, we describe how to convert from infix to postfix.\n\n\n\n\nRead in the tokens one at a time\n\n\nIf a token is an integer, write it into the output\n\n\nIf a token is an operator, push it to the stack, if the stack is empty. If the stack is not empty, you pop entries with higher or equal priority and only then you push that 1. token to the stack.\n\n\nIf a token is a left parentheses '(', push it to the stack\n\n\nIf a token is a right parentheses ')', you pop entries until you meet '('.\n\n\nWhen you finish reading the string, you pop up all tokens which are left there.\n\n\nArithmetic precedence is in increasing order: '+', '-', '*', '/';\n\n\n\n\nExample. Suppose we have an infix expression:2+(4+3*2+1)/3. We read the string by characters.\n\n\n'2' - send to the output.\n'+' - push on the stack.\n'(' - push on the stack.\n'4' - send to the output.\n'+' - push on the stack.\n'3' - send to the output.\n'*' - push on the stack.\n'2' - send to the output.\n\n\n\n\nEvaluating a Postfix Expression\n. We describe how to parse and evaluate a postfix expression.\n\n\n\n\nWe read the tokens in one at a time.\n\n\nIf it is an integer, push it on the stack\n\n\nIf it is a binary operator, pop the top two elements from the stack, apply the operator, and push the result back on the stack.\n\n\n\n\nConsider the following postfix expression\n\n\n5 9 3 + 4 2 * * 7 + *\n\n\n\n\nHere is a chain of operations\n\n\nStack Operations              Output\n--------------------------------------\npush(5);                        5\npush(9);                        5 9\npush(3);                        5 9 3\npush(pop() + pop())             5 12\npush(4);                        5 12 4\npush(2);                        5 12 4 2\npush(pop() * pop())             5 12 8\npush(pop() * pop())             5 96\npush(7)                         5 96 7\npush(pop() + pop())             5 103\npush(pop() * pop())             515\n\n\n\n\nNote, that division is not a commutative operation, so 2/3 is not the same as 3/2.\n\n\nChallenges\n\n\n\n\nStacks: Balanced Brackets\n\n\nQueues: A Tale of Two Stacks\n\n\n\n\nReferences\n\n\n\n\n\"Stacks and Queues\". \nVictor S.Adamchik, CMU\n. 2009", 
            "title": "Stacks & Queues"
        }, 
        {
            "location": "/d_stack_queue/#stacks-and-queues", 
            "text": "An array is a random access data structure, where each element can be accessed directly and in constant time. A typical illustration of random access is a book - each page of the book can be open independently of others. Random access is critical to many algorithms, for example binary search.  A linked list is a sequential access data structure, where each element can be accesed only in particular order. A typical illustration of sequential access is a roll of paper or tape - all prior material must be unrolled in order to get to data you want.  In this note we consider a subcase of sequential data structures, so-called limited access data sturctures.", 
            "title": "Stacks and Queues"
        }, 
        {
            "location": "/d_stack_queue/#stacks", 
            "text": "A stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO) principle. In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item out of the stack. A stack is a limited access data structure - elements can be added and removed from the stack only at the top. push adds an item to the top of the stack, pop removes the item from the top. A helpful analogy is to think of a stack of books; you can remove only the top book, also you can add a new book on the top.\nA stack is a recursive data structure. Here is a structural definition of a Stack:   a stack is either empty or  it consistes of a top and the rest which is a stack;", 
            "title": "Stacks"
        }, 
        {
            "location": "/d_stack_queue/#applications", 
            "text": "The simplest application of a stack is to reverse a word. You push a given word to stack - letter by letter - and then pop letters from the stack.  Another application is an \"undo\" mechanism in text editors; this operation is accomplished by keeping all text changes in a stack.  Backtracking . This is a process when you need to access the most recent data element in a series of elements. Think of a labyrinth or maze - how do you find a way from an entrance to an exit?\nOnce you reach a dead end, you must backtrack. But backtrack to where? to the previous choice point. Therefore, at each choice point you store on a stack all possible choices. Then backtracking simply means popping a next choice from the stack.     Language processing:  space for parameters and local variables is created internally using a stack.  compiler's syntax check for matching braces is implemented by using stack.  support for recursion", 
            "title": "Applications"
        }, 
        {
            "location": "/d_stack_queue/#implementation", 
            "text": "In the standard library of classes, the data type stack is an adapter class, meaning that a stack is built on top of other data structures. The underlying structure for a stack could be an array, a vector, an ArrayList, a linked list, or any other collection. Regardless of the type of the underlying data structure, a Stack must implement the same functionality. This is achieved by providing a unique interface:  public interface StackInterface AnyType \n{\n   public void push(AnyType e);\n\n   public AnyType pop();\n\n   public AnyType peek();\n\n   public boolean isEmpty();\n}  The following picture demonstrates the idea of implementation by composition.   Another implementation requirement (in addition to the above interface) is that all stack operations must run in constant time O(1). Constant time means that there is some constant k such that an operation takes k nanoseconds of computational time regardless of the stack size.", 
            "title": "Implementation"
        }, 
        {
            "location": "/d_stack_queue/#array-based-implementation", 
            "text": "In an array-based implementation we maintain the following fields: an array A of a default size (\u2265 1), the variable top that refers to the top element in the stack and the capacity that refers to the array size. The variable top changes from -1 to capacity - 1. We say that a stack is empty when top = -1, and the stack is full when top = capacity-1.\nIn a fixed-size stack abstraction, the capacity stays unchanged, therefore when top reaches capacity, the stack object throws an exception. See ArrayStack.java for a complete implementation of the stack class.  In a dynamic stack abstraction when top reaches capacity, we double up the stack siz", 
            "title": "Array-based implementation"
        }, 
        {
            "location": "/d_stack_queue/#linked-list-based-implementation", 
            "text": "Linked List-based implementation provides the best (from the efficiency point of view) dynamic stack implementation.\nSee ListStack.java for a complete implementation of the stack class.", 
            "title": "Linked List-based implementation"
        }, 
        {
            "location": "/d_stack_queue/#queues", 
            "text": "A queue is a container of objects (a linear collection) that are inserted and removed according to the first-in first-out (FIFO) principle. An excellent example of a queue is a line of students in the food court of the UC. New additions to a line made to the back of the queue, while removal (or serving) happens in the front. In the queue only two operations are allowed enqueue and dequeue. Enqueue means to insert an item into the back of the queue, dequeue means removing the front item. The picture demonstrates the FIFO access.\nThe difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.", 
            "title": "Queues"
        }, 
        {
            "location": "/d_stack_queue/#implementation_1", 
            "text": "In the standard library of classes, the data type queue is an adapter class, meaning that a queue is built on top of other data structures. The underlying structure for a queue could be an array, a Vector, an ArrayList, a LinkedList, or any other collection. Regardless of the type of the underlying data structure, a queue must implement the same functionality. This is achieved by providing a unique interface.  interface QueueInterface\u2039AnyType \n{\n   public boolean isEmpty();\n\n   public AnyType getFront();\n\n   public AnyType dequeue();\n\n   public void enqueue(AnyType e);\n\n   public void clear();\n}  Each of the above basic operations must run at constant time O(1). The following picture demonstrates the idea of implementation by composition.", 
            "title": "Implementation"
        }, 
        {
            "location": "/d_stack_queue/#circular-queue", 
            "text": "Given an array A of a default size (\u2265 1) with two references back and front, originally set to -1 and 0 respectively. Each time we insert (enqueue) a new item, we increase the back index; when we remove (dequeue) an item - we increase the front index. Here is a picture that illustrates the model after a few steps:   As you see from the picture, the queue logically moves in the array from left to right. After several moves back reaches the end, leaving no space for adding new elements   However, there is a free space before the front index. We shall use that space for enqueueing new items, i.e. the next entry will be stored at index 0, then 1, until front. Such a model is called a wrap around queue or a circular queue   Finally, when back reaches front, the queue is full. There are two choices to handle a full queue:a) throw an exception; b) double the array size.  The circular queue implementation is done by using the modulo operator (denoted %), which is computed by taking the remainder of division (for example, 8%5 is 3). By using the modulo operator, we can view the queue as a circular array, where the \"wrapped around\" can be simulated as \"back % array_size\". In addition to the back and front indexes, we maintain another index: cur - for counting the number of elements in a queue. Having this index simplifies a logic of implementation.  See ArrayQueue.java for a complete implementation of a circular queue.", 
            "title": "Circular Queue"
        }, 
        {
            "location": "/d_stack_queue/#applications_1", 
            "text": "The simplest two search techniques are known as Depth-First Search(DFS) and Breadth-First Search (BFS). These two searches are described by looking at how the search tree (representing all the possible paths from the start) will be traversed.", 
            "title": "Applications"
        }, 
        {
            "location": "/d_stack_queue/#deapth-first-search-with-a-stack", 
            "text": "In depth-first search we go down a path until we get to a dead end; then we backtrack or back up (by popping a stack) to get an alternative path.  Create a stack\nCreate a new choice point\nPush the choice point onto the stack\nwhile (not found and stack is not empty)\n    Pop the stack\n    Find all possible choices after the last one tried\n    Push these choices onto the stack\nReturn", 
            "title": "Deapth-First Search with a Stack"
        }, 
        {
            "location": "/d_stack_queue/#breadth-first-search-with-a-queue", 
            "text": "In breadth-first search we explore all the nearest possibilities by finding all possible successors and enqueue them to a queue.  Create a queue\nCreate a new choice point\nEnqueue the choice point onto the queue\nwhile (not found and queue is not empty)\n    Dequeue the queue\n    Find all possible choices after the last one tried\n    Enqueue these choices onto the queue\nReturn  We will see more on search techniques later in the course.", 
            "title": "Breadth-First Search with a Queue"
        }, 
        {
            "location": "/d_stack_queue/#arithmetic-expression-evaluation", 
            "text": "An important application of stacks is in parsing. For example, a compiler must parse arithmetic expressions written using infix notation:  1 + ((2 + 3) * 4 + 5)*6  We break the problem of parsing infix expressions into two stages. First, we convert from infix to a different representation called postfix. Then we parse the postfix expression, which is a somewhat easier problem than directly parsing infix.  Converting from Infix to Postfix.  Typically, we deal with expressions in infix notation  2 + 5  where the operators (e.g. +, *) are written between the operands (e.q, 2 and 5). Writing the operators after the operands gives a postfix expression 2 and 5 are called operands, and the '+' is operator. The above arithmetic expression is called infix, since the operator is in between operands. The expression  2 5 +  Writing the operators before the operands gives a prefix expression  +2 5  Suppose you want to compute the cost of your shopping trip. To do so, you add a list of numbers and multiply them by the local sales tax (7.25%):  70 + 150 * 1.0725  Depending on the calculator, the answer would be either 235.95 or 230.875. To avoid this confusion we shall use a postfix notation  70  150 + 1.0725 *  Postfix has the nice property that parentheses are unnecessary.  Now, we describe how to convert from infix to postfix.   Read in the tokens one at a time  If a token is an integer, write it into the output  If a token is an operator, push it to the stack, if the stack is empty. If the stack is not empty, you pop entries with higher or equal priority and only then you push that 1. token to the stack.  If a token is a left parentheses '(', push it to the stack  If a token is a right parentheses ')', you pop entries until you meet '('.  When you finish reading the string, you pop up all tokens which are left there.  Arithmetic precedence is in increasing order: '+', '-', '*', '/';   Example. Suppose we have an infix expression:2+(4+3*2+1)/3. We read the string by characters.  '2' - send to the output.\n'+' - push on the stack.\n'(' - push on the stack.\n'4' - send to the output.\n'+' - push on the stack.\n'3' - send to the output.\n'*' - push on the stack.\n'2' - send to the output.  Evaluating a Postfix Expression . We describe how to parse and evaluate a postfix expression.   We read the tokens in one at a time.  If it is an integer, push it on the stack  If it is a binary operator, pop the top two elements from the stack, apply the operator, and push the result back on the stack.   Consider the following postfix expression  5 9 3 + 4 2 * * 7 + *  Here is a chain of operations  Stack Operations              Output\n--------------------------------------\npush(5);                        5\npush(9);                        5 9\npush(3);                        5 9 3\npush(pop() + pop())             5 12\npush(4);                        5 12 4\npush(2);                        5 12 4 2\npush(pop() * pop())             5 12 8\npush(pop() * pop())             5 96\npush(7)                         5 96 7\npush(pop() + pop())             5 103\npush(pop() * pop())             515  Note, that division is not a commutative operation, so 2/3 is not the same as 3/2.", 
            "title": "Arithmetic Expression Evaluation"
        }, 
        {
            "location": "/d_stack_queue/#challenges", 
            "text": "Stacks: Balanced Brackets  Queues: A Tale of Two Stacks", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_stack_queue/#references", 
            "text": "\"Stacks and Queues\".  Victor S.Adamchik, CMU . 2009", 
            "title": "References"
        }, 
        {
            "location": "/d_tree/", 
            "text": "Tree\n\n\nBinary Tree\n\n\nFundamentally, a binary tree is composed of nodes connected by edges (with further restrictions discussed below). Some binary tree, \nt\n, is either empty or consists of a single root element with two distinct binary tree child elements known as the \nleft subtree\n and the \nright subtree\n of \nt\n. As the name \nbinary\n suggests, a node in a binary tree has a \nmaximum\n of \n2\n children.\n\n\nThe following diagrams depict two different binary trees: \n\n\n \n\n\nHere are the basic facts and terms to know about binary trees:\n\n\n\n\nThe convention for binary tree diagrams is that the \nroot\n is at the top, and the subtrees branch down from it.\n\n\nA node's \nleft\n and \nright\n subtrees are referred to as \nchildren\n, and that node can be referred to as the \nparent\n of those subtrees.\n\n\nA non-root node with no children is called a \nleaf\n.\n\n\nSome node \na\n is an ancestor of some node \nb\n if \nb\n is located in a left or right subtree whose root node is \na\n. This means that the root node of binary tree \nt\n is the ancestor of all other nodes in the tree.\n\n\nIf some node \na\n is an ancestor of some node \nb\n, then the path from \na\n to \nb\n is the sequence of nodes starting with \na\n, moving down the ancestral chain of children, and ending with bb.\n\n\nThe depth (or level) of some node \na\n is its distance (i.e., number of edges) from the tree's root node.\n\n\nSimply put, the height of a tree is the number of edges between the root node and its furthest leaf.\n\n\nMore technically put, it's \n1+max(height(leftSubtree), height(rightSubtree))\n ) (i.e., one more than the maximum of the heights of its left and right subtrees).\n\n\nAny node has a height of \n1\n, and the height of an empty subtree is \n - 1 \n.\n\n\nBecause the height of each node is \n1 + \n the maximum height of its subtrees and an empty subtree's height is \n - 1 \n, the height of a single-element tree or leaf node is \n0\n.\n\n\n\n\n\n\n\n\nLet's apply some of the terms we learned above to the binary tree on the right:\n\n\n\n\n\n\nThe root node is \nA\n.\n\n\n\n\n\n\nThe respective left and right children of \nA\n are \nB\n and \nE\n. The left child of \nB\n is \nC\n. The respective left and right children of \nE\n are \nF\n and \nD\n.\n\n\n\n\n\n\nNodes \nC\n, \nF\n, and \nD\n are leaves (i.e., each node is a leaf).\n\n\n\n\n\n\nThe root is the ancestor of all other nodes, \nB\n is an ancestor of \nC\n, and \nE\n is an ancestor of \nF\n and \nD\n.\n\n\n\n\n\n\nThe path between \nA\n and \nC\n is \n A \\rightarrow B \\rightarrow C \n. The path between \nA\n and \nF\n is \n A \\rightarrow E \\rightarrow F \n. The path between \nA\n and \nD\n is A \n \\rightarrow E \\rightarrow D \n.\n\n\n\n\n\n\nThe depth of root node \nA\n is \n0\n. The depth of nodes \nB\n and \nE\n is \n1\n. The depth of nodes \nC\n, \nF\n, and \nD\n, is \n2\n.\n\n\n\n\n\n\nThe height of the tree, \n height(t) \n, is \n2\n. We calculate this recursively as \n height(t)=1+(max(height(root.leftChild),height(root.rightChild))) \n.\n\n\n\n\n\n\nBecause this is long and complicated when expanded, we'll break it down using an image of a slightly simpler version of \nt\n whose height is still \n2\n: \n\n\n \n\n\nBinary Search Tree\n\n\nA Binary Search Tree (BST), \nt\n, is a binary tree that is either empty or satisfies the following three conditions:\n\n\n\n\n\n\nEach element in the left subtree of \nt\n is less than or equal to the root element of \nt\n (i.e., \n max(leftTree(t).value) \\leq t.valuemax(leftTree(t).value) \\leq t.value \n).\n\n\n\n\n\n\nEach element in the right subtree of \nt\n is greater than the root element of \nt\n (i.e., \n max(rightTree(t).value) \\ge t.valuemax(rightTree(t).value) \\ge t.value\n).\n\n\n\n\n\n\nBoth \n leftTree(t) \n and \n rightTree(t) \n are BSTs.\n\n\n\n\n\n\nYou can essentially think of it as a regular binary tree where for each node parent having a \n leftChild \n and \n rightChild \n, \n leftChild.value \\leq parent.value \\le rightChild.value \n. In the first diagram at the top of this article, the binary tree of integers on the left side is a binary search tree.\n\n\nAdvantages and Drawbacks\n\n\n\n\nSearching for elements is very fast.\n\n\n\n\nWe know that each node has a maximum of two children and we know that the \n \\leq \n items are always in the left subtree and the \n > \n items are always in the right subtree. To search for an element, we simply need to compare the value we want against the value stored in the root node of the current subtree and work our way down the appropriate child subtrees until we either find the value we're looking for or we hit \nnull\n (i.e., an empty subtree) which indicates the item is not in the BST. Inserting or searching for a node in a balanced tree is \n O(\\log n) \n because you're discarding half of the possible values each time you go left or right.\n\n\n\n\nIt can easily become unbalanced.\n\n\n\n\nDepending on the insertion order, the tree can very easily become unbalanced (which makes for longer search times). For example, if we create a new tree where the sequence of inserted nodes is \n 2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \n, we end up with the following unbalanced tree: \n\n\n\n\nObserve that the root's left subtree only has one node, whereas the root's right subtree has four nodes. For this reason, inserting or searching for a node in an unbalanced tree is \n O(n) \n.\n\n\nChallenges\n\n\n\n\n\"Trees: Is This a Binary Search Tree?\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Binary Trees and Binary Search Trees\". \nAllisonP, hackerrank\n. 2016", 
            "title": "Trees"
        }, 
        {
            "location": "/d_tree/#tree", 
            "text": "", 
            "title": "Tree"
        }, 
        {
            "location": "/d_tree/#binary-tree", 
            "text": "Fundamentally, a binary tree is composed of nodes connected by edges (with further restrictions discussed below). Some binary tree,  t , is either empty or consists of a single root element with two distinct binary tree child elements known as the  left subtree  and the  right subtree  of  t . As the name  binary  suggests, a node in a binary tree has a  maximum  of  2  children.  The following diagrams depict two different binary trees:      Here are the basic facts and terms to know about binary trees:   The convention for binary tree diagrams is that the  root  is at the top, and the subtrees branch down from it.  A node's  left  and  right  subtrees are referred to as  children , and that node can be referred to as the  parent  of those subtrees.  A non-root node with no children is called a  leaf .  Some node  a  is an ancestor of some node  b  if  b  is located in a left or right subtree whose root node is  a . This means that the root node of binary tree  t  is the ancestor of all other nodes in the tree.  If some node  a  is an ancestor of some node  b , then the path from  a  to  b  is the sequence of nodes starting with  a , moving down the ancestral chain of children, and ending with bb.  The depth (or level) of some node  a  is its distance (i.e., number of edges) from the tree's root node.  Simply put, the height of a tree is the number of edges between the root node and its furthest leaf.  More technically put, it's  1+max(height(leftSubtree), height(rightSubtree))  ) (i.e., one more than the maximum of the heights of its left and right subtrees).  Any node has a height of  1 , and the height of an empty subtree is   - 1  .  Because the height of each node is  1 +   the maximum height of its subtrees and an empty subtree's height is   - 1  , the height of a single-element tree or leaf node is  0 .     Let's apply some of the terms we learned above to the binary tree on the right:    The root node is  A .    The respective left and right children of  A  are  B  and  E . The left child of  B  is  C . The respective left and right children of  E  are  F  and  D .    Nodes  C ,  F , and  D  are leaves (i.e., each node is a leaf).    The root is the ancestor of all other nodes,  B  is an ancestor of  C , and  E  is an ancestor of  F  and  D .    The path between  A  and  C  is   A \\rightarrow B \\rightarrow C  . The path between  A  and  F  is   A \\rightarrow E \\rightarrow F  . The path between  A  and  D  is A   \\rightarrow E \\rightarrow D  .    The depth of root node  A  is  0 . The depth of nodes  B  and  E  is  1 . The depth of nodes  C ,  F , and  D , is  2 .    The height of the tree,   height(t)  , is  2 . We calculate this recursively as   height(t)=1+(max(height(root.leftChild),height(root.rightChild)))  .    Because this is long and complicated when expanded, we'll break it down using an image of a slightly simpler version of  t  whose height is still  2 :", 
            "title": "Binary Tree"
        }, 
        {
            "location": "/d_tree/#binary-search-tree", 
            "text": "A Binary Search Tree (BST),  t , is a binary tree that is either empty or satisfies the following three conditions:    Each element in the left subtree of  t  is less than or equal to the root element of  t  (i.e.,   max(leftTree(t).value) \\leq t.valuemax(leftTree(t).value) \\leq t.value  ).    Each element in the right subtree of  t  is greater than the root element of  t  (i.e.,   max(rightTree(t).value) \\ge t.valuemax(rightTree(t).value) \\ge t.value ).    Both   leftTree(t)   and   rightTree(t)   are BSTs.    You can essentially think of it as a regular binary tree where for each node parent having a   leftChild   and   rightChild  ,   leftChild.value \\leq parent.value \\le rightChild.value  . In the first diagram at the top of this article, the binary tree of integers on the left side is a binary search tree.", 
            "title": "Binary Search Tree"
        }, 
        {
            "location": "/d_tree/#advantages-and-drawbacks", 
            "text": "Searching for elements is very fast.   We know that each node has a maximum of two children and we know that the   \\leq   items are always in the left subtree and the   >   items are always in the right subtree. To search for an element, we simply need to compare the value we want against the value stored in the root node of the current subtree and work our way down the appropriate child subtrees until we either find the value we're looking for or we hit  null  (i.e., an empty subtree) which indicates the item is not in the BST. Inserting or searching for a node in a balanced tree is   O(\\log n)   because you're discarding half of the possible values each time you go left or right.   It can easily become unbalanced.   Depending on the insertion order, the tree can very easily become unbalanced (which makes for longer search times). For example, if we create a new tree where the sequence of inserted nodes is   2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6  , we end up with the following unbalanced tree:    Observe that the root's left subtree only has one node, whereas the root's right subtree has four nodes. For this reason, inserting or searching for a node in an unbalanced tree is   O(n)  .", 
            "title": "Advantages and Drawbacks"
        }, 
        {
            "location": "/d_tree/#challenges", 
            "text": "\"Trees: Is This a Binary Search Tree?\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_tree/#references", 
            "text": "\"Binary Trees and Binary Search Trees\".  AllisonP, hackerrank . 2016", 
            "title": "References"
        }, 
        {
            "location": "/d_heap/", 
            "text": "Heaps\n\n\nA heap is just what it sounds like \u2014  a pile of values organized into a binary tree-like structure adhering to some ordering property. When we add elements to a heap, we fill this tree-like structure from left to right, level by level. This makes heaps really easy to implement in an array, where the value for some index ii's left child is located at index \n 2i+1 \n and the value for its right child is at index \n 2i+2 \n (using zero-indexing). Here are the two most fundamental heap operations:\n\n\n\n\nadd\n: Insert an element into the heap. You may also see this referred to as push.\n\n\npoll\n: Retrieve and remove the root element of the heap. You may also see this referred to as pop.\n\n\n\n\nMax Heap\n\n\nThis type heap orders the maximum value at the root.\n\n\nWhen we \nadd\n the values \n 1\u21922\u21923\u21924 \n to a Max heap, it looks like this:\n\n\n\n\nWhen we \npoll\n the same Max heap until it's empty, it looks like this:\n\n\n\n\nMin Heap\n\n\nThis type of heap orders the minimum value at the root.\n\n\nWhen we \nadd\n the values \n 1\u21922\u21923\u21924 \n to a Min heap, it looks like this:\n\n\n \n\n\nWhen we \npoll\n the same Min heap until it's empty, it looks like this:\n\n\n \n\n\nApplications\n\n\nThe heap data structure has many applications.\n\n\n\n\nHeapsort\n: One of the best sorting methods being in-place and with no quadratic worst-case scenarios.\n\n\nSelection algorithms\n: A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.\n\n\nGraph algorithms\n: By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are Prim's minimal-spanning-tree algorithm and Dijkstra's shortest-path algorithm.\n\n\nPriority Queue\n: A priority queue is an abstract concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods.\n\n\nOrder statistics\n: The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array.\n\n\n\n\nChallenges\n\n\n\n\n\"Heaps: Find the Running Median\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Heaps\". \nAllisonP, hackerrank\n. 2016\n\n\n\"Heap (data structure)\". \nwikipedia\n. 2016", 
            "title": "Heaps"
        }, 
        {
            "location": "/d_heap/#heaps", 
            "text": "A heap is just what it sounds like \u2014  a pile of values organized into a binary tree-like structure adhering to some ordering property. When we add elements to a heap, we fill this tree-like structure from left to right, level by level. This makes heaps really easy to implement in an array, where the value for some index ii's left child is located at index   2i+1   and the value for its right child is at index   2i+2   (using zero-indexing). Here are the two most fundamental heap operations:   add : Insert an element into the heap. You may also see this referred to as push.  poll : Retrieve and remove the root element of the heap. You may also see this referred to as pop.", 
            "title": "Heaps"
        }, 
        {
            "location": "/d_heap/#max-heap", 
            "text": "This type heap orders the maximum value at the root.  When we  add  the values   1\u21922\u21923\u21924   to a Max heap, it looks like this:   When we  poll  the same Max heap until it's empty, it looks like this:", 
            "title": "Max Heap"
        }, 
        {
            "location": "/d_heap/#min-heap", 
            "text": "This type of heap orders the minimum value at the root.  When we  add  the values   1\u21922\u21923\u21924   to a Min heap, it looks like this:     When we  poll  the same Min heap until it's empty, it looks like this:", 
            "title": "Min Heap"
        }, 
        {
            "location": "/d_heap/#applications", 
            "text": "The heap data structure has many applications.   Heapsort : One of the best sorting methods being in-place and with no quadratic worst-case scenarios.  Selection algorithms : A heap allows access to the min or max element in constant time, and other selections (such as median or kth-element) can be done in sub-linear time on data that is in a heap.  Graph algorithms : By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are Prim's minimal-spanning-tree algorithm and Dijkstra's shortest-path algorithm.  Priority Queue : A priority queue is an abstract concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods.  Order statistics : The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array.", 
            "title": "Applications"
        }, 
        {
            "location": "/d_heap/#challenges", 
            "text": "\"Heaps: Find the Running Median\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_heap/#references", 
            "text": "\"Heaps\".  AllisonP, hackerrank . 2016  \"Heap (data structure)\".  wikipedia . 2016", 
            "title": "References"
        }, 
        {
            "location": "/d_trie/", 
            "text": "Introduction\n\n\nThere are many algorithms and data structures to index and search strings inside a text, some of them are included in the standard libraries, but not all of them; the trie data structure is a good example of one that isn\u2019t.\n\n\nLet word be a single string and let dictionary be a large set of words. If we have a dictionary, and we need to know if a single word is inside of the dictionary the tries are a data structure that can help us. But you may be asking yourself, \u201cWhy use tries if set \n and hash tables can do the same?\u201d\n\n\nThere are two main reasons:\n\n\n\n\n\n\nThe tries can insert and find strings in \n O(L) \n time (where L represent the length of a single word). This is much faster than set , but is it a bit faster than a hash table.\nThe set \n and the hash tables can only find in a dictionary words that match exactly with the single word that we are finding; the trie allow us to find words that have a single character different, a prefix in common, a character missing, etc.\n\n\n\n\n\n\nThe tries can be useful in TopCoder problems, but also have a great amount of applications in software engineering. For example, consider a web browser. Do you know how the web browser can auto complete your text or show you many possibilities of the text that you could be writing? Yes, with the trie you can do it very fast. Do you know how an orthographic corrector can check that every word that you type is in a dictionary? Again a trie. You can also use a trie for suggested corrections of the words that are present in the text but not in the dictionary.\n\n\n\n\n\n\nWhat is a Tree?\n\n\nYou may read about how wonderful the tries are, but maybe you don\u2019t know yet what the tries are and why the tries have this name. The word trie is an infix of the word \u201cretrieval\u201d because the trie can find a single word in a dictionary with only a prefix of the word. The main idea of the trie data structure consists of the following parts:\n\n\n\n\nThe trie is a tree where each vertex represents a single word or a prefix.\n\n\nThe root represents an empty string (\u201c\u201d), the vertexes that are direct sons of the root represent prefixes of length 1, the vertexes that are 2 edges of distance from the root represent prefixes of length 2, the vertexes that are 3 edges of distance from the root represent prefixes of length 3 and so on. In other words, a vertex that are k edges of distance of the root have an associated prefix of length k.\n\n\nLet v and w be two vertexes of the trie, and assume that v is a direct father of w, then v must have an associated prefix of w.\n\n\n\n\nThe next figure shows a trie with the words \u201ctree\u201d, \u201ctrie\u201d, \u201calgo\u201d, \u201cassoc\u201d, \u201call\u201d, and \u201calso.\u201d\n\n\n\n\n\n\n\n\n\nNote that every vertex of the tree does not store entire prefixes or entire words. The idea is that the program should remember the word that represents each vertex while lower in the tree.\n\n\nCoding a Trie\n\n\nThe tries can be implemented in many ways, some of them can be used to find a set of words in the dictionary where every word can be a little different than the target word, and other implementations of the tries can provide us with only words that match exactly with the target word. The implementation of the trie that will be exposed here will consist only of finding words that match exactly and counting the words that have some prefix. This implementation will be pseudo code because different coders can use different programming languages.\n\n\nWe will code these 4 functions:\n\n\n\n\naddWord\n. This function will add a single string word to the dictionary.\n\n\ncountPreffixes\n. This function will count the number of words in the dictionary that have a string prefix as prefix.\n\n\ncountWords\n. This function will count the number of words in the dictionary that match exactly with a given string word.\n\n\nOur trie will only support letters of the English alphabet.\n\n\n\n\nWe need to also code a structure with some fields that indicate the values stored in each vertex. As we want to know the number of words that match with a given string, every vertex should have a field to indicate that this vertex represents a complete word or only a prefix (for simplicity, a complete word is considered also a prefix) and how many words in the dictionary are represented by that prefix (there can be repeated words in the dictionary). This task can be done with only one integer field words.\n\n\nBecause we want to know the number of words that have like prefix a given string, we need another integer field prefixes that indicates how many words have the prefix of the vertex. Also, each vertex must have references to all his possible sons (26 references). Knowing all these details, our structure should have the following members:\n\n\nstructure Trie\n    integer words;\n    integer prefixes;\n    reference edges[26];\n\n\n\n\nAnd we also need the following functions:\n\n\ninitialize(vertex)\naddWord(vertex, word);\ninteger countPrefixes(vertex, prefix);\ninteger countWords(vertex, word);\n\n\n\n\nFirst of all, we have to initialize the vertexes with the following function:\n\n\ninitialize(vertex)\n    vertex.words=0\n    vertex.prefixes=0\n    for i=0 to 26\n        edges[i]=NoEdge\n\n\n\n\nThe addWord function consists of two parameters, the vertex of the insertion and the word that will be added. The idea is that when a string word is added to a vertex vertex, we will add word to the corresponding branch of vertex cutting the leftmost character of word. If the needed branch does not exist, we will have to create it. All the TopCoder languages can simulate the process of cutting a character in constant time instead of creating a copy of the original string or moving the other characters.\n\n\naddWord(vertex, word)\n    if isEmpty(word)\n        vertex.words=vertex.words+1\n    else\n        vertex.prefixes=vertex.prefixes+1\n        k=firstCharacter(word)\n        if(notExists(edges[k]))\n            edges[k]=createEdge()\n            initialize(edges[k])\n        cutLeftmostCharacter(word)\n        addWord(edges[k], word)\n\n\n\n\nThe functions countWords and countPrefixes are very similar. If we are finding an empty string we only have to return the number of words/prefixes associated with the vertex. If we are finding a non-empty string, we should to find in the corresponding branch of the tree, but if the branch does not exist, we have to return 0.\n\n\ncountWords(vertex, word)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.words\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(word)\n        return countWords(edges[k], word);\n\ncountPrefixes(vertex, prefix)\n    k=firstCharacter(prefix)\n    if isEmpty(word)\n        return vertex.prefixes\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(prefix)\n        return countWords(edges[k], prefix)\n\n\n\n\nComplexity Analysis\n\n\nIn the introduction you may read that the complexity of finding and inserting a trie is linear, but we have not done the analysis yet. In the insertion and finding notice that lowering a single level in the tree is done in constant time, and every time that the program lowers a single level in the tree, a single character is cut from the string; we can conclude that every function lowers L levels on the tree and every time that the function lowers a level on the tree, it is done in constant time, then the insertion and finding of a word in a trie can be done in O(L) time. The memory used in the tries depends on the methods to store the edges and how many words have prefixes in common.\n\n\nOther Kinds of Tries\n\n\nWe used the tries to store words with lowercase letters, but the tries can be used to store many other things. We can use bits or bytes instead of lowercase letters and every data type can be stored in the tree, not only strings. Let flow your imagination using tries! For example, suppose that you want to find a word in a dictionary but a single letter was deleted from the word. You can modify the countWords function:\n\n\ncountWords(vertex, word, missingLetters)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.word\n    else if notExists(edges[k]) and missingLetters=0\n        return 0\n    else if notExists(edges[k])\n        cutLeftmostCharacter(word)\n        return countWords(vertex, word, missingLetters-1)\n        Here we cut a character but we don't go lower in the tree\n    else\n        We are adding the two possibilities: the first\n        character has been deleted plus the first character is present\n        r=countWords(vertex, word, missingLetters-1)\n        cutLeftmostCharacter(word)\n        r=r+countWords(edges[k], word, missingLetters)\n        return r\n\n\n\n\nThe complexity of this function may be larger than the original, but it is faster than checking all the subsets of characters of a word.\n\n\nChallenges\n\n\n\n\n\"Tries: Contacts\". \nhackerrank\n. 2016\n\n\n\n\nReferences\n\n\n\n\n\"Using Tries \u2013 Topcoder\".\u00a0\nTopcoder.com\n. N.p., 2016. Web. 11 Oct. 2016.", 
            "title": "Tries"
        }, 
        {
            "location": "/d_trie/#introduction", 
            "text": "There are many algorithms and data structures to index and search strings inside a text, some of them are included in the standard libraries, but not all of them; the trie data structure is a good example of one that isn\u2019t.  Let word be a single string and let dictionary be a large set of words. If we have a dictionary, and we need to know if a single word is inside of the dictionary the tries are a data structure that can help us. But you may be asking yourself, \u201cWhy use tries if set   and hash tables can do the same?\u201d  There are two main reasons:    The tries can insert and find strings in   O(L)   time (where L represent the length of a single word). This is much faster than set , but is it a bit faster than a hash table.\nThe set   and the hash tables can only find in a dictionary words that match exactly with the single word that we are finding; the trie allow us to find words that have a single character different, a prefix in common, a character missing, etc.    The tries can be useful in TopCoder problems, but also have a great amount of applications in software engineering. For example, consider a web browser. Do you know how the web browser can auto complete your text or show you many possibilities of the text that you could be writing? Yes, with the trie you can do it very fast. Do you know how an orthographic corrector can check that every word that you type is in a dictionary? Again a trie. You can also use a trie for suggested corrections of the words that are present in the text but not in the dictionary.", 
            "title": "Introduction"
        }, 
        {
            "location": "/d_trie/#what-is-a-tree", 
            "text": "You may read about how wonderful the tries are, but maybe you don\u2019t know yet what the tries are and why the tries have this name. The word trie is an infix of the word \u201cretrieval\u201d because the trie can find a single word in a dictionary with only a prefix of the word. The main idea of the trie data structure consists of the following parts:   The trie is a tree where each vertex represents a single word or a prefix.  The root represents an empty string (\u201c\u201d), the vertexes that are direct sons of the root represent prefixes of length 1, the vertexes that are 2 edges of distance from the root represent prefixes of length 2, the vertexes that are 3 edges of distance from the root represent prefixes of length 3 and so on. In other words, a vertex that are k edges of distance of the root have an associated prefix of length k.  Let v and w be two vertexes of the trie, and assume that v is a direct father of w, then v must have an associated prefix of w.   The next figure shows a trie with the words \u201ctree\u201d, \u201ctrie\u201d, \u201calgo\u201d, \u201cassoc\u201d, \u201call\u201d, and \u201calso.\u201d     Note that every vertex of the tree does not store entire prefixes or entire words. The idea is that the program should remember the word that represents each vertex while lower in the tree.", 
            "title": "What is a Tree?"
        }, 
        {
            "location": "/d_trie/#coding-a-trie", 
            "text": "The tries can be implemented in many ways, some of them can be used to find a set of words in the dictionary where every word can be a little different than the target word, and other implementations of the tries can provide us with only words that match exactly with the target word. The implementation of the trie that will be exposed here will consist only of finding words that match exactly and counting the words that have some prefix. This implementation will be pseudo code because different coders can use different programming languages.  We will code these 4 functions:   addWord . This function will add a single string word to the dictionary.  countPreffixes . This function will count the number of words in the dictionary that have a string prefix as prefix.  countWords . This function will count the number of words in the dictionary that match exactly with a given string word.  Our trie will only support letters of the English alphabet.   We need to also code a structure with some fields that indicate the values stored in each vertex. As we want to know the number of words that match with a given string, every vertex should have a field to indicate that this vertex represents a complete word or only a prefix (for simplicity, a complete word is considered also a prefix) and how many words in the dictionary are represented by that prefix (there can be repeated words in the dictionary). This task can be done with only one integer field words.  Because we want to know the number of words that have like prefix a given string, we need another integer field prefixes that indicates how many words have the prefix of the vertex. Also, each vertex must have references to all his possible sons (26 references). Knowing all these details, our structure should have the following members:  structure Trie\n    integer words;\n    integer prefixes;\n    reference edges[26];  And we also need the following functions:  initialize(vertex)\naddWord(vertex, word);\ninteger countPrefixes(vertex, prefix);\ninteger countWords(vertex, word);  First of all, we have to initialize the vertexes with the following function:  initialize(vertex)\n    vertex.words=0\n    vertex.prefixes=0\n    for i=0 to 26\n        edges[i]=NoEdge  The addWord function consists of two parameters, the vertex of the insertion and the word that will be added. The idea is that when a string word is added to a vertex vertex, we will add word to the corresponding branch of vertex cutting the leftmost character of word. If the needed branch does not exist, we will have to create it. All the TopCoder languages can simulate the process of cutting a character in constant time instead of creating a copy of the original string or moving the other characters.  addWord(vertex, word)\n    if isEmpty(word)\n        vertex.words=vertex.words+1\n    else\n        vertex.prefixes=vertex.prefixes+1\n        k=firstCharacter(word)\n        if(notExists(edges[k]))\n            edges[k]=createEdge()\n            initialize(edges[k])\n        cutLeftmostCharacter(word)\n        addWord(edges[k], word)  The functions countWords and countPrefixes are very similar. If we are finding an empty string we only have to return the number of words/prefixes associated with the vertex. If we are finding a non-empty string, we should to find in the corresponding branch of the tree, but if the branch does not exist, we have to return 0.  countWords(vertex, word)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.words\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(word)\n        return countWords(edges[k], word);\n\ncountPrefixes(vertex, prefix)\n    k=firstCharacter(prefix)\n    if isEmpty(word)\n        return vertex.prefixes\n    else if notExists(edges[k])\n        return 0\n    else\n        cutLeftmostCharacter(prefix)\n        return countWords(edges[k], prefix)", 
            "title": "Coding a Trie"
        }, 
        {
            "location": "/d_trie/#complexity-analysis", 
            "text": "In the introduction you may read that the complexity of finding and inserting a trie is linear, but we have not done the analysis yet. In the insertion and finding notice that lowering a single level in the tree is done in constant time, and every time that the program lowers a single level in the tree, a single character is cut from the string; we can conclude that every function lowers L levels on the tree and every time that the function lowers a level on the tree, it is done in constant time, then the insertion and finding of a word in a trie can be done in O(L) time. The memory used in the tries depends on the methods to store the edges and how many words have prefixes in common.", 
            "title": "Complexity Analysis"
        }, 
        {
            "location": "/d_trie/#other-kinds-of-tries", 
            "text": "We used the tries to store words with lowercase letters, but the tries can be used to store many other things. We can use bits or bytes instead of lowercase letters and every data type can be stored in the tree, not only strings. Let flow your imagination using tries! For example, suppose that you want to find a word in a dictionary but a single letter was deleted from the word. You can modify the countWords function:  countWords(vertex, word, missingLetters)\n    k=firstCharacter(word)\n    if isEmpty(word)\n        return vertex.word\n    else if notExists(edges[k]) and missingLetters=0\n        return 0\n    else if notExists(edges[k])\n        cutLeftmostCharacter(word)\n        return countWords(vertex, word, missingLetters-1)\n        Here we cut a character but we don't go lower in the tree\n    else\n        We are adding the two possibilities: the first\n        character has been deleted plus the first character is present\n        r=countWords(vertex, word, missingLetters-1)\n        cutLeftmostCharacter(word)\n        r=r+countWords(edges[k], word, missingLetters)\n        return r  The complexity of this function may be larger than the original, but it is faster than checking all the subsets of characters of a word.", 
            "title": "Other Kinds of Tries"
        }, 
        {
            "location": "/d_trie/#challenges", 
            "text": "\"Tries: Contacts\".  hackerrank . 2016", 
            "title": "Challenges"
        }, 
        {
            "location": "/d_trie/#references", 
            "text": "\"Using Tries \u2013 Topcoder\".\u00a0 Topcoder.com . N.p., 2016. Web. 11 Oct. 2016.", 
            "title": "References"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Decomposition of Graphs"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Paths in Graphs"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Minimum Spanning Trees"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Advanced Shortest Paths Project"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/a_graph_theory/", 
            "text": "Graph Theory\n\n\nShortest Path Problem\n\n\n\n\nShortest path (A, C, E, D, F) between vertices A and F in the weighted directed graph\n\n\nIn graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.\n\n\n\n\n\n\n\n\na\n\n\nb\n\n\n\n\n\n\nc\n\n\nd\n\n\n\n\n\n\n\n\n\nSingle-source shortest path problem\n\n\nDijkstra's algorithm\n\n\n\n\nDijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.", 
            "title": "Graph Theory"
        }, 
        {
            "location": "/a_graph_theory/#graph-theory", 
            "text": "", 
            "title": "Graph Theory"
        }, 
        {
            "location": "/a_graph_theory/#shortest-path-problem", 
            "text": "Shortest path (A, C, E, D, F) between vertices A and F in the weighted directed graph  In graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.     a  b    c  d", 
            "title": "Shortest Path Problem"
        }, 
        {
            "location": "/a_graph_theory/#single-source-shortest-path-problem", 
            "text": "", 
            "title": "Single-source shortest path problem"
        }, 
        {
            "location": "/a_graph_theory/#dijkstras-algorithm", 
            "text": "Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.", 
            "title": "Dijkstra's algorithm"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Suffix Trees"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Burrows-Wheeler Transform and Suffix Arrays"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Knuth\u2013Morris\u2013Pratt Algorithm"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Constructing Suffix Arrays and Suffix Trees"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Complete coloring"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Clique cover problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Knapsack problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Bin packing problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Closest string"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Longest common subsequence problem"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Flows in Networks"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }, 
        {
            "location": "/", 
            "text": "Data Structures \n Algorithms Tutorial \nby MG\n\n\n\n\nAlgorithms + Data Structures = Programs\n\n\nIn computer science, a \ndata structure\n is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.\n\n\nIn mathematics and computer science, an \nalgorithm\n is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nIntroduction\n\n\nGreedy Algorithms\n\n\nDivide-and-Conquer\n\n\nDynamic Programming\n\n\n7 Steps to Solve Algorithm Problems\n\n\n\n\nData Structures\n\n\n\n\nBasic Data Structures\n\n\nDynamic Arrays and Amortized Analysis\n\n\nPriority Queues and Disjoint Sets\n\n\nHash Tables\n\n\nBinary Search Trees\n\n\n\n\nAlgorithms on Graphs\n\n\n\n\nDecomposition of Graphs\n\n\nPaths in Graphs\n\n\nMinimum Spanning Trees\n\n\nAdvanced Shortest Paths Project\n\n\n\n\nAlgorithms on Strings\n\n\n\n\nSuffix Trees\n\n\nBurrows-Wheeler Transform and Suffix Arrays\n\n\nKnuth\u2013Morris\u2013Pratt Algorithm\n\n\nConstructing Suffix Arrays and Suffix Trees\n\n\n\n\nNP-complete Problems\n\n\n\n\nComplete coloring\n\n\nClique cover problem\n\n\nKnapsack problem\n\n\nBin packing problem\n\n\nClosest string\n\n\nLongest common subsequence problem\n\n\n\n\nAdvanced Algorithms and Complexity\n\n\n\n\nFlows in Networks\n\n\nLinear Programming\n\n\n\n\nMiscellaneous\n\n\n\n\nBest algorithms and data structures books\n\n\nBest algorithms and data structures courses\n\n\nData Structures and Algorithms Challenges\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nChallenges\n\n\n\n\nhttps://www.topcoder.com/\n\n\nhttps://www.hackerrank.com/\n\n\nhttp://codeforces.com/\n\n\nhttps://www.codechef.com/\n\n\nhttp://www.spoj.com/\n\n\nhttps://projecteuler.net/", 
            "title": "Linear Programming"
        }, 
        {
            "location": "/#data-structures-algorithms-tutorial-by-mg", 
            "text": "Algorithms + Data Structures = Programs  In computer science, a  data structure  is a particular way of organizing data in a computer so that it can be used efficiently. Data structures can implement one or more particular abstract data types (ADT), which specify the operations that can be performed on a data structure and the computional complexity of those operations. In comparison, a data structure is a concrete implementation of the specification provided by an ADT.  In mathematics and computer science, an  algorithm  is a self-contained step-by-step set of operations to be performed. Algorithms perform calculation, data processing, and/or automated reasoning tasks.", 
            "title": "Data Structures &amp; Algorithms Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Introduction  Greedy Algorithms  Divide-and-Conquer  Dynamic Programming  7 Steps to Solve Algorithm Problems", 
            "title": "Get Started"
        }, 
        {
            "location": "/#data-structures", 
            "text": "Basic Data Structures  Dynamic Arrays and Amortized Analysis  Priority Queues and Disjoint Sets  Hash Tables  Binary Search Trees", 
            "title": "Data Structures"
        }, 
        {
            "location": "/#algorithms-on-graphs", 
            "text": "Decomposition of Graphs  Paths in Graphs  Minimum Spanning Trees  Advanced Shortest Paths Project", 
            "title": "Algorithms on Graphs"
        }, 
        {
            "location": "/#algorithms-on-strings", 
            "text": "Suffix Trees  Burrows-Wheeler Transform and Suffix Arrays  Knuth\u2013Morris\u2013Pratt Algorithm  Constructing Suffix Arrays and Suffix Trees", 
            "title": "Algorithms on Strings"
        }, 
        {
            "location": "/#np-complete-problems", 
            "text": "Complete coloring  Clique cover problem  Knapsack problem  Bin packing problem  Closest string  Longest common subsequence problem", 
            "title": "NP-complete Problems"
        }, 
        {
            "location": "/#advanced-algorithms-and-complexity", 
            "text": "Flows in Networks  Linear Programming", 
            "title": "Advanced Algorithms and Complexity"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best algorithms and data structures books  Best algorithms and data structures courses  Data Structures and Algorithms Challenges", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#challenges", 
            "text": "https://www.topcoder.com/  https://www.hackerrank.com/  http://codeforces.com/  https://www.codechef.com/  http://www.spoj.com/  https://projecteuler.net/", 
            "title": "Challenges"
        }
    ]
}