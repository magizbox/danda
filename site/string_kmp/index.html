<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Brother Rain">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Knuth–Morris–Pratt Algorithm - D&A</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../components/magiz-c-book/src/book.css" rel="stylesheet">
        <link href="../components/magiz-c-course/src/course.css" rel="stylesheet">
        <link href="../components/magiz-c-video/src/video.css" rel="stylesheet">
        <link href="../components/magiz-c-benchmark/src/benchmark.css" rel="stylesheet">
        <link href="../components/magiz-c-paper/src/paper.css" rel="stylesheet">
        <link href="../components/magiz-doc/style.css" rel="stylesheet">
        <link href="../components/magiz-doc/highlight.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-68978617-1', 'magizbox.com');
            ga('send', 'pageview');
        </script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">D&A</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Get Started <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../gs_introduction/">Introduction</a>
</li>
                            
<li >
    <a href="../gs_greedy_algorithms/">Greedy Algorithms</a>
</li>
                            
<li >
    <a href="../gs_divide_and_conquer/">Divide-and-Conquer</a>
</li>
                            
<li >
    <a href="../gs_dynamic_programming/">Dynamic Programming</a>
</li>
                            
<li >
    <a href="../7_steps/">7 Steps to Solve Algorithm Problems</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Data Structures <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../ds_array/">Arrays</a>
</li>
                            
<li >
    <a href="../ds_linked_list/">Linked List</a>
</li>
                            
<li >
    <a href="../ds_stack_queue/">Stacks & Queues</a>
</li>
                            
<li >
    <a href="../ds_tree/">Trees</a>
</li>
                            
<li >
    <a href="../ds_binary_search_tree/">Binary Search Trees</a>
</li>
                            
<li >
    <a href="../ds_heap/">Heaps</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Sort <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../sort_algorithms/">Sorting Algorithms</a>
</li>
                            
<li >
    <a href="../sort_bubble/">Bubble Sort</a>
</li>
                            
<li >
    <a href="../sort_insertion/">Insertion Sort</a>
</li>
                            
<li >
    <a href="../sort_selection/">Selection Sort</a>
</li>
                            
<li >
    <a href="../sort_merge/">Merge Sort</a>
</li>
                            
<li >
    <a href="../sort_shell/">Shell Sort</a>
</li>
                            
<li >
    <a href="../sort_quick/">Quick Sort</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Search <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../search_linear/">Linear Search</a>
</li>
                            
<li >
    <a href="../search_binary/">Binary Search</a>
</li>
                            
<li >
    <a href="../search_interpolation/">Interpolation Search</a>
</li>
                            
<li >
    <a href="../search_hash_table/">Hash Tables</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Graphs <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../graph_data_structure/">Graph Data Structure</a>
</li>
                            
<li >
    <a href="../graph_dfs/">DFS: Depth First Traversal</a>
</li>
                            
<li >
    <a href="../graph_bfs/">BFS: Breadth First Traversal</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Strings <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../string_string/">Introduction to Strings</a>
</li>
                            
<li >
    <a href="../string_tries/">Tries</a>
</li>
                            
<li >
    <a href="../string_suffix_arrays_suffix_trees/">Suffix Arrays and Suffix Trees</a>
</li>
                            
<li class="active">
    <a href="./">Knuth–Morris–Pratt Algorithm</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Advanced <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
  <li class="dropdown-submenu">
    <a href="#">NPs</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="..">Complete coloring</a>
</li>
            
<li >
    <a href="..">Clique cover problem</a>
</li>
            
<li >
    <a href="..">Knapsack problem</a>
</li>
            
<li >
    <a href="..">Bin packing problem</a>
</li>
            
<li >
    <a href="..">Closest string</a>
</li>
            
<li >
    <a href="..">Longest common subsequence problem</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="..">Flows in Networks</a>
</li>
                            
<li >
    <a href="..">Linear Programming</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../string_suffix_arrays_suffix_trees/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="..">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#knuth-morris-pratt-algorithm">Knuth-Morris-Pratt Algorithm</a></li>
        <li class="main "><a href="#skipping-outer-iterations">Skipping outer iterations</a></li>
        <li class="main "><a href="#skipping-inner-iterations">Skipping inner iterations</a></li>
        <li class="main "><a href="#kmp-time-analysis">KMP time analysis</a></li>
        <li class="main "><a href="#kmp-and-finite-automata">KMP and finite automata</a></li>
        <li class="main "><a href="#alternate-version-of-kmp">Alternate version of KMP</a></li>
        <li class="main "><a href="#computing-the-overlap-function">Computing the overlap function</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="knuth-morris-pratt-algorithm">Knuth-Morris-Pratt Algorithm</h1>
<p>The problem:</p>
<blockquote>
<p>given a (short) pattern and a (long) text, both strings, determine whether the pattern appears somewhere in the text.</p>
</blockquote>
<p>We'll go through the Knuth-Morris-Pratt (KMP) algorithm, which can be thought of as an efficient way to build these automata. I also have some working <a href="http://www.ics.uci.edu/~eppstein/161/kmp/">C++ source code</a> which might help you understand the algorithm better.</p>
<p>First let's look at a naive solution.</p>
<ul>
<li>suppose the text is in an array: char <script type="math/tex">T[n]</script>
</li>
<li>and the pattern is in another array: char <script type="math/tex">P[m]</script>.</li>
</ul>
<p>One simple method is just to try each possible position the pattern could appear in the text.</p>
<p><strong>Naive string matching:</strong></p>
<pre><code>for (i=0; T[i] != '\0'; i++)
{
    for (j=0; T[i+j] != '\0' &amp;&amp; P[j] != '\0' &amp;&amp; T[i+j]==P[j]; j++) ;
    if (P[j] == '\0') found a match
}
</code></pre>

<p>There are two nested loops; the inner one takes O(m) iterations and the outer one takes O(n) iterations so the total time is the product, O(mn). This is slow; we'd like to speed it up.</p>
<p>In practice this works pretty well -- not usually as bad as this O(mn) worst case analysis. This is because the inner loop usually finds a mismatch quickly and move on to the next position without going through all m steps. But this method still can take O(mn) for some inputs. In one bad example, all characters in T[] are "a"s, and P[] is all "a"'s except for one "b" at the end. Then it takes m comparisons each time to discover that you don't have a match, so mn overall.</p>
<p>Here's a more typical example. Each row represents an iteration of the outer loop, with each character in the row representing the result of a comparison (X if the comparison was unequal). Suppose we're looking for pattern "nano" in text "banananobano".</p>
<pre><code> 0  1  2  3  4  5  6  7  8  9 10 11
  T: b  a  n  a  n  a  n  o  b  a  n  o

i=0: X
i=1:    X
i=2:       n  a  n  X
i=3:          X
i=4:             n  a  n  o
i=5:                X
i=6:                   n  X
i=7:                         X
i=8:                            X
i=9:                               n  X
i=10:                                 X

</code></pre>

<p>Some of these comparisons are wasted work! For instance, after iteration i=2, we know from the comparisons we've done that T[3]="a", so there is no point comparing it to "n" in iteration i=3. And we also know that T[4]="n", so there is no point making the same comparison in iteration i=4.</p>
<h1 id="skipping-outer-iterations">Skipping outer iterations</h1>
<p>The Knuth-Morris-Pratt idea is, in this sort of situation, after you've invested a lot of work making comparisons in the inner loop of the code, you know a lot about what's in the text. Specifically, if you've found a partial match of j characters starting at position i, you know what's in positions T[i]...T[i+j-1].
You can use this knowledge to save work in two ways. First, you can skip some iterations for which no match is possible. Try overlapping the partial match you've found with the new match you want to find:</p>
<pre><code>    i=2: n  a  n
    i=3:    n  a  n  o
</code></pre>

<p>Here the two placements of the pattern conflict with each other -- we know from the i=2 iteration that T[3] and T[4] are "a" and "n", so they can't be the "n" and "a" that the i=3 iteration is looking for. We can keep skipping positions until we find one that doesn't conflict:</p>
<pre><code>    i=2: n  a  n
    i=4:       n  a  n  o
</code></pre>

<p>Here the two "n"'s coincide. Define the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. Here the overlap of "nan" and "nano" is just "n". (We don't allow the overlap to be all of x or y, so it's not "nan"). In general the value of i we want to skip to is the one corresponding to the largest overlap with the current partial match:</p>
<p><strong>String matching with skipped iterations:</strong></p>
<pre><code>    i=0;
    while (i&lt;n)
    {
    for (j=0; T[i+j] != '\0' &amp;&amp; P[j] != '\0' &amp;&amp; T[i+j]==P[j]; j++) ;
    if (P[j] == '\0') found a match;
    i = i + max(1, j-overlap(P[0..j-1],P[0..m]));
    }
</code></pre>

<h1 id="skipping-inner-iterations">Skipping inner iterations</h1>
<p>The other optimization that can be done is to skip some iterations in the inner loop. Let's look at the same example, in which we skipped from i=2 to i=4:</p>
<pre><code>    i=2: n  a  n
    i=4:       n  a  n  o
</code></pre>

<p>In this example, the "n" that overlaps has already been tested by the i=2 iteration. There's no need to test it again in the i=4 iteration. In general, if we have a nontrivial overlap with the last partial match, we can avoid testing a number of characters equal to the length of the overlap.
This change produces (a version of) the KMP algorithm:</p>
<p>KMP, version 1:</p>
<pre><code>    i=0;
    o=0;
    while (i&lt;n)
    {
    for (j=o; T[i+j] != '\0' &amp;&amp; P[j] != '\0' &amp;&amp; T[i+j]==P[j]; j++) ;
    if (P[j] == '\0') found a match;
    o = overlap(P[0..j-1],P[0..m]);
    i = i + max(1, j-o);
    }
</code></pre>

<p>The only remaining detail is how to compute the overlap function. This is a function only of j, and not of the characters in T[], so we can compute it once in a preprocessing stage before we get to this part of the algorithm. First let's see how fast this algorithm is.</p>
<h1 id="kmp-time-analysis">KMP time analysis</h1>
<p>We still have an outer loop and an inner loop, so it looks like the time might still be O(mn). But we can count it a different way to see that it's actually always less than that. The idea is that every time through the inner loop, we do one comparison T[i+j]==P[j]. We can count the total time of the algorithm by counting how many comparisons we perform.
We split the comparisons into two groups: those that return true, and those that return false. If a comparison returns true, we've determined the value of T[i+j]. Then in future iterations, as long as there is a nontrivial overlap involving T[i+j], we'll skip past that overlap and not make a comparison with that position again. So each position of T[] is only involved in one true comparison, and there can be n such comparisons total. On the other hand, there is at most one false comparison per iteration of the outer loop, so there can also only be n of those. As a result we see that this part of the KMP algorithm makes at most 2n comparisons and takes time O(n).</p>
<h1 id="kmp-and-finite-automata">KMP and finite automata</h1>
<p>If we look just at what happens to j during the algorithm above, it's sort of like a finite automaton. At each step j is set either to j+1 (in the inner loop, after a match) or to the overlap o (after a mismatch). At each step the value of o is just a function of j and doesn't depend on other information like the characters in T[]. So we can draw something like an automaton, with arrows connecting values of j and labeled with matches and mismatches.</p>
<p><img alt="" src="https://www.ics.uci.edu/~eppstein/161/kmp.gif" /></p>
<p>The difference between this and the automata we are used to is that it has only two arrows out of each circle, instead of one per character. But we can still simulate it just like any other automaton, by placing a marker on the start state (j=0) and moving it around the arrows. Whenever we get a matching character in T[] we move on to the next character of the text. But whenever we get a mismatch we look at the same character in the next step, except for the case of a mismatch in the state j=0.</p>
<p>So in this example (the same as the one above) the automaton goes through the sequence of states:</p>
<pre><code>    j=0
            mismatch T[0] != &quot;n&quot;
    j=0
            mismatch T[1] != &quot;n&quot;
    j=0
            match T[2] == &quot;n&quot;
    j=1
            match T[3] == &quot;a&quot;
    j=2
            match T[4] == &quot;n&quot;
    j=3
            mismatch T[5] != &quot;o&quot;
    j=1
            match T[5] == &quot;a&quot;
    j=2
            match T[6] == &quot;n&quot;
    j=3
            match T[7] == &quot;o&quot;
    j=4
            found match
    j=0
            mismatch T[8] != &quot;n&quot;
    j=0
            mismatch T[9] != &quot;n&quot;
    j=0
            match T[10] == &quot;n&quot;
    j=1
            mismatch T[11] != &quot;a&quot;
    j=0
            mismatch T[11] != &quot;n&quot;
</code></pre>

<p>This is essentially the same sequence of comparisons done by the KMP pseudocode above. So this automaton provides an equivalent definition of the KMP algorithm.
As one student pointed out in lecture, the one transition in this automaton that may not be clear is the one from j=4 to j=0. In general, there should be a transition from j=m to some smaller value of j, which should happen on any character (there are no more matches to test before making this transition). If we want to find all occurrences of the pattern, we should be able to find an occurrence even if it overlaps another one. So for instance if the pattern were "nana", we should find both occurrences of it in the text "nanana". So the transition from j=m should go to the next longest position that can match, which is simply j=overlap(pattern,pattern). In this case overlap("nano","nano") is empty (all suffixes of "nano" use the letter "o", and no prefix does) so we go to j=0.</p>
<h1 id="alternate-version-of-kmp">Alternate version of KMP</h1>
<p>The automaton above can be translated back into pseudo-code, looking a little different from the pseudo-code we saw before but performing the same comparisons.</p>
<p><strong>KMP, version 2:</strong></p>
<pre><code>    j = 0;
    for (i = 0; i &lt; n; i++)
    for (;;) {      // loop until break
        if (T[i] == P[j]) { // matches?
        j++;        // yes, move on to next state
        if (j == m) {   // maybe that was the last state
            found a match;
            j = overlap[j];
        }
        break;
        } else if (j == 0) break;   // no match in state j=0, give up
        else j = overlap[j];    // try shorter partial match
    }
</code></pre>

<p>The code inside each iteration of the outer loop is essentially the same as the function match from the C++ implementation I've made available. One advantage of this version of the code is that it tests characters one by one, rather than performing random access in the T[] array, so (as in the implementation) it can be made to work for stream-based input rather than having to read the whole text into memory first.
The overlap[j] array stores the values of overlap(pattern[0..j-1],pattern), which we still need to show how to compute.</p>
<p>Since this algorithm performs the same comparisons as the other version of KMP, it takes the same amount of time, O(n). One way of proving this bound directly is to note, first, that there is one true comparison (in which T[i]==P[j]) per iteration of the outer loop, since we break out of the inner loop when this happens. So there are n of these total. Each of these comparisons results in increasing j by one. Each iteration of the inner loop in which we don't break out of the loop results in executing the statement j=overlap[j], which decreases j. Since j can only decrease as many times as it's increased, the total number of times this happens is also O(n).</p>
<h1 id="computing-the-overlap-function">Computing the overlap function</h1>
<p>Recall that we defined the overlap of two strings x and y to be the longest word that's a suffix of x and a prefix of y. The missing component of the KMP algorithm is a computation of this overlap function: we need to know overlap(P[0..j-1],P) for each value of j&gt;0. Once we've computed these values we can store them in an array and look them up when we need them.
To compute these overlap functions, we need to know for strings x and y not just the longest word that's a suffix of x and a prefix of y, but all such words. The key fact to notice here is that if w is a suffix of x and a prefix of y, and it's not the longest such word, then it's also a suffix of overlap(x,y). (This follows simply from the fact that it's a suffix of x that is shorter than overlap(x,y) itself.) So we can list all words that are suffixes of x and prefixes of y by the following loop:</p>
<pre><code>    while (x != empty) {
    x = overlap(x,y);
    output x;
    }
</code></pre>

<p>Now let's make another definition: say that shorten(x) is the prefix of x with one fewer character. The next simple observation to make is that shorten(overlap(x,y)) is still a prefix of y, but is also a suffix of shorten(x).
So we can find overlap(x,y) by adding one more character to some word that's a suffix of shorten(x) and a prefix of y. We can just find all such words using the loop above, and return the first one for which adding one more character produces a valid overlap:</p>
<p>Overlap computation:</p>
<pre><code>    z = overlap(shorten(x),y)
    while (last char of x != y[length(z)])
    {
    if (z = empty) return overlap(x,y) = empty
    else z = overlap(z,y)
    }
    return overlap(x,y) = z
</code></pre>

<p>So this gives us a recursive algorithm for computing the overlap function in general. If we apply this algorithm for x=some prefix of the pattern, and y=the pattern itself, we see that all recursive calls have similar arguments. So if we store each value as we compute it, we can look it up instead of computing it again. (This simple idea of storing results instead of recomputing them is known as dynamic programming; we discussed it somewhat in the first lecture and will see it in more detail next time.)
So replacing x by P[0..j-1] and y by P[0..m-1] in the pseudocode above and replacing recursive calls by lookups of previously computed values gives us a routine for the problem we're trying to solve, of computing these particular overlap values. The following pseudocode is taken (with some names changed) from the initialization code of the C++ implementation I've made available. The value in overlap[0] is just a flag to make the rest of the loop simpler. The code inside the for loop is the part that computes each overlap value.</p>
<p>KMP overlap computation:</p>
<pre><code>    overlap[0] = -1;
    for (int i = 0; pattern[i] != '\0'; i++) {
    overlap[i + 1] = overlap[i] + 1;
    while (overlap[i + 1] &gt; 0 &amp;&amp;
           pattern[i] != pattern[overlap[i + 1] - 1])
        overlap[i + 1] = overlap[overlap[i + 1] - 1] + 1;
    }
    return overlap;
</code></pre>

<p>Let's finish by analyzing the time taken by this part of the KMP algorithm. The outer loop executes m times. Each iteration of the inner loop decreases the value of the formula overlap[i+1], and this formula's value only increases by one when we move from one iteration of the outer loop to the next. Since the number of decreases is at most the number of increases, the inner loop also has at most m iterations, and the total time for the algorithm is O(m).
The entire KMP algorithm consists of this overlap computation followed by the main part of the algorithm in which we scan the text (using the overlap values to speed up the scan). The first part takes O(m) and the second part takes O(n) time, so the total time is O(m+n).</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>
        <script src="../components/underscore/underscore.js"></script>
        <script src="../components/magiz-c-book/src/gspreadsheet.js"></script>
        <script src="../components/magiz-c-paper/src/paper.js"></script>
        <script src="../components/magiz-c-course/src/course.js"></script>
        <script src="../components/magiz-c-benchmark/src/benchmark.js"></script>
        <script src="../components/magiz-c-benchmark/src/bootstrap-popup.js"></script>
        <script src="../components/magiz-c-book/src/book.js"></script>
        <script src="../components/magiz-c-video/src/video.js"></script>
        <script src="../components/jquery/dist/jquery.js"></script>
        <script src="../components/magiz-doc/doc.js"></script>
        <script src="../components/magiz-doc/footer.js"></script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
